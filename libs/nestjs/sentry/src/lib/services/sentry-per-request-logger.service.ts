import { Inject, Injectable, Scope } from '@nestjs/common';
import { REQUEST } from '@nestjs/core';
import { Scope as SentryScope, Severity, withScope } from '@sentry/node';
import { Extras } from '@sentry/types';
import { Request } from 'express';

import { SENTRY_MODULE_OPTIONS } from '../constants';
import { Breadcrumb, BreadcrumbType, SentryModuleOptions } from '../interfaces';
import { SentryLogger } from './sentry-logger.service';

/**
 * This service will create a scope before sending the log/error and push all request's logs as breadcrumbs
 */
@Injectable({ scope: Scope.REQUEST })
export class SentryPerRequestLogger extends SentryLogger {
  protected readonly breadcrumbs: Breadcrumb[] = [];

  constructor(
    @Inject(REQUEST)
    protected readonly request: Request,
    @Inject(SENTRY_MODULE_OPTIONS)
    protected readonly opts: SentryModuleOptions,
  ) {
    super(opts);
  }

  /**
   * Push a new breadcrumb into the stack in order to be attached to the log later.
   * Can set all values of a breadcrumb.
   */
  pushBreadcrumb(breadcrumb: Breadcrumb): void {
    this.breadcrumbs.push({
      ...breadcrumb,
      timestamp: Date.now() / 1000, // Accept timestamps in seconds
    });
  }

  /**
   * Short function to push a new breadcrumb.
   * Calls pushBreadcrumb under the hood.
   */
  push(
    message: string,
    // eslint-disable-next-line default-param-last
    type: BreadcrumbType = 'default',
    category?: string,
  ): void {
    this.pushBreadcrumb({
      type,
      message,
      category,
    });
  }

  protected sendMessageToSentry(
    message: string,
    severity: Severity,
    context?: string,
  ) {
    try {
      withScope((scope) => {
        this.populateScope(scope);
        super.sendMessageToSentry(message, severity, context);
      });
    } catch (error) {
      this.handleSentryError(error, context);
    }
  }

  protected sendErrorToSentry(error: Error, extras?: Extras, context?: string) {
    try {
      withScope((scope) => {
        this.populateScope(scope, extras);
        super.sendErrorToSentry(error, undefined, context);
      });
    } catch (e) {
      this.handleSentryError(e, context);
    }
  }

  protected populateScope(scope: SentryScope, extras?: Extras): void {
    // Add tags
    scope.setTags({ requestId: this.getRequestId() });

    // Add extras if any
    if (extras) scope.setExtras(extras);

    // Retrieve and filter global breadcrumbs
    const globalBreadcrumbs = this.opts
      .pushGlobalBreadcrumbsWithPerRequestBreadcrumbs
      ? this.filterUnrelatedBreadcrumbs(this.getBreadcrumbsFromScope(scope))
      : [];

    // Concat with local breadcrumbs and sort them by timestamp
    const sortedBreadcrumbs = this.sortBreadcrumbsByTimestamp(
      globalBreadcrumbs.concat(this.breadcrumbs),
    );

    // Clear and push breadcrumbs to scope
    scope.clearBreadcrumbs();
    sortedBreadcrumbs.forEach((breadcrumb) => scope.addBreadcrumb(breadcrumb));
  }

  protected sortBreadcrumbsByTimestamp(
    breadcrumbs: Breadcrumb[],
  ): Breadcrumb[] {
    return breadcrumbs.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
  }

  /**
   * Remove breadcrumbs older than the request
   */
  protected filterUnrelatedBreadcrumbs(
    breadcrumbs: Breadcrumb[],
  ): Breadcrumb[] {
    const requestTimestampInSeconds =
      this.getRequestTimestampInMilliseconds() / 1000;

    return breadcrumbs.filter((breadcrumb) => {
      const breadcrumbTimestamp = breadcrumb.timestamp || 0;
      return breadcrumbTimestamp >= requestTimestampInSeconds;
    });
  }

  /**
   * Try to retrieve request timestamp from response object (module request-timestamp must be loaded)
   * Other, consider the request is N seconds old.
   * Returns in milliseconds
   */
  protected getRequestTimestampInMilliseconds(): number {
    return (
      (this.request.res?.locals.timestamp as number | undefined) ||
      Date.now() - this.opts.requestDefaultAge
    );
  }

  /**
   * Force breadcrumbs recovery from scope
   */
  protected getBreadcrumbsFromScope(scope: SentryScope): Breadcrumb[] {
    // eslint-disable-next-line no-underscore-dangle
    return (scope as never as { _breadcrumbs: Breadcrumb[] })._breadcrumbs;
  }

  /**
   * Get unique request id (given by front-end or generated by back-end)
   */
  protected getRequestId(): string {
    const header = this.request.headers['x-correlation-id'] || 'none';
    return typeof header === 'string' ? header : header[0];
  }
}
