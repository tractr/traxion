/* eslint-disable @typescript-eslint/ban-types */
import { Inject, Injectable } from '@nestjs/common';

<<if Fields enum and internal and not ownership>>
import {
  <<for Fields enum and internal and not ownership field>>
    <<Model pascal>><<field pascal>>,
  <<endfor>>
} from '../../../../models';
<<endif>>
import { <<Model constant>>_DATABASE_SERVICE } from '../<<Model kebab>>-model.constant';
import { <<Model pascal>>DatabaseService } from './<<Model kebab>>-database.service';

import { Prisma } from '@prisma/client';

@Injectable()
export class <<Model pascal>>Service {
  constructor(
    @Inject(<<Model constant>>_DATABASE_SERVICE)
    protected readonly <<Model camel>>DatabaseService: <<Model pascal>>DatabaseService,
  ) {}

  <<for Fields internal and ownership and not primary field>>
  /**
   *  Add <<field pascal>> ownership to data
   * */
  public add<<field pascal>>OwnerShip<T extends Partial<Prisma.<<Model pascal>>CreateInput>>(data: T, owner: Prisma.<<field.model pascal>>WhereUniqueInput):
    T &
    { '<<field camel>>': { connect: Prisma.<<field.model pascal>>WhereUniqueInput } }
  {
    return {
      ...data,
      '<<field camel>>': { connect: owner }
    };
  }
  <<endfor>>

  <<if Fields internal and not primary and (not entity or nullable)>>

  /**
   *  Return default internal fields
   **/
  public getDefaultInternals() {
    return {
      <<for Fields internal and not primary and (not entity or nullable) field>>
      <<field camel>>: this.getDefault<<field pascal>>(),
      <<endfor>>
    }
  }
  <<endif>>

  <<for Fields internal and not primary and (not entity or nullable) field>>
  /**
   * Return default value for internal field '<<field camel>>'
   * */
  public getDefault<<field pascal>>() {
<<< if (field.meta.default) { >>>
    return <<-field default raw>>;
<<< } else { >>>
  <<if field nullable>>
    return null;
  <<elseif field string >>
    return '';
  <<elseif field number >>
    return 0;
  <<elseif field boolean >>
    return false;
  <<elseif field datetime >>
    return new Date();
  <<elseif field enum>>
    return <<Model pascal>><<field pascal>>["<<for1 field.enum e>><<e raw>><<endfor>>"];
  <<else>>
    throw new Error("Field '<<field camel>>' need 'default' metadata");
  <<endif>>
<<<}>>>
  }
<<endfor>>

  /**
   * Find zero or one <<Model pascal>> that matches the filter.
   * @param {<<Model pascal>>FindUniqueArgs} args - Arguments to find a <<Model pascal>>
   * @example
   * // Get one <<Model pascal>>
   * const <<Model camel>> = await this.<<Model camel>>Service.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * */
  public async findUnique<T extends Prisma.<<Model pascal>>FindUniqueArgs>(
    args: Prisma.SelectSubset<T, Prisma.<<Model pascal>>FindUniqueArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.findUnique<Prisma.SelectSubset<T, Prisma.<<Model pascal>>FindUniqueArgs>>(args);
  }

  /**
   * Find the first <<Model pascal>> that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {<<Model pascal>>FindFirstArgs} args - Arguments to find a <<Model pascal>>
   * @example
   * // Get one <<Model pascal>>
   * const <<Model camel>> = await this.<<Model camel>>Service.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * */
  public async findFirst<T extends Prisma.<<Model pascal>>FindFirstArgs>(
    args?: Prisma.SelectSubset<T, Prisma.<<Model pascal>>FindFirstArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.findFirst<
      Prisma.SelectSubset<T, Prisma.<<Model pascal>>FindFirstArgs>
    >(args);
  }

  /**
   * Find zero or more <<Model pascal>>s that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {<<Model pascal>>FindManyArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all <<Model pascal>>s
   * const <<Model camel>>s = await this.<<Model camel>>Service.findMany()
   *
   * // Get first 10 <<Model pascal>>s
   * const <<Model camel>>s = await this.<<Model camel>>Service.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const <<Model camel>>WithIdOnly = await this.<<Model camel>>Service.findMany({ select: { id: true } })
   *
   * */
  public async findMany<T extends Prisma.<<Model pascal>>FindManyArgs>(
    args?: Prisma.SelectSubset<T, Prisma.<<Model pascal>>FindManyArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.findMany<
      Prisma.SelectSubset<T, Prisma.<<Model pascal>>FindManyArgs>
    >(args);
  }

  /**
   * Create a <<Model pascal>>.
   * @param {<<Model pascal>>CreateArgs} args - Arguments to create a <<Model pascal>>.
   * @example
   * // Create one <<Model pascal>>
   * const <<Model pascal>> = await this.<<Model camel>>Service.create({
   *   data: {
   *     // ... data to create a <<Model pascal>>
   *   }
   * })
   *
   * */
  public async create<T extends Prisma.<<Model pascal>>CreateArgs>(
    args: Prisma.SelectSubset<T, Prisma.<<Model pascal>>CreateArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.create<
      Prisma.SelectSubset<T, Prisma.<<Model pascal>>CreateArgs>
    >(args);
  }

  /**
   * Create many <<Model pascal>>s.
   * @param {<<Model pascal>>CreateManyArgs} args - Arguments to create many <<Model pascal>>s.
   * @example
   * // Create many <<Model pascal>>s
   * const <<Model camel>> = await this.<<Model camel>>Service.createMany({
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   * */
  public async createMany<T extends Prisma.<<Model pascal>>CreateManyArgs>(
    args?: Prisma.SelectSubset<T, Prisma.<<Model pascal>>CreateManyArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.createMany<
      Prisma.SelectSubset<T, Prisma.<<Model pascal>>CreateManyArgs>
    >(args);
  }

  /**
   * Delete a <<Model pascal>>.
   * @param {<<Model pascal>>DeleteArgs} args - Arguments to delete one <<Model pascal>>.
   * @example
   * // Delete one <<Model pascal>>
   * const <<Model pascal>> = await this.<<Model camel>>Service.delete({
   *   where: {
   *     // ... filter to delete one <<Model pascal>>
   *   }
   * })
   *
   * */
  public async delete<T extends Prisma.<<Model pascal>>DeleteArgs>(
    args: Prisma.SelectSubset<T, Prisma.<<Model pascal>>DeleteArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.delete<
      Prisma.SelectSubset<T, Prisma.<<Model pascal>>DeleteArgs>
    >(args);
  }

  /**
   * Update one <<Model pascal>>.
   * @param {<<Model pascal>>UpdateArgs} args - Arguments to update one <<Model pascal>>.
   * @example
   * // Update one <<Model pascal>>
   * const <<Model camel>> = await this.<<Model camel>>Service.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   * */
  public async update<T extends Prisma.<<Model pascal>>UpdateArgs>(
    args: Prisma.SelectSubset<T, Prisma.<<Model pascal>>UpdateArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.update<Prisma.SelectSubset<
      T, Prisma.<<Model pascal>>UpdateArgs>
    >(args);
  }

  /**
   * Delete zero or more <<Model pascal>>s.
   * @param {<<Model pascal>>DeleteManyArgs} args - Arguments to filter <<Model pascal>>s to delete.
   * @example
   * // Delete a few <<Model pascal>>s
   * const { count } = await this.<<Model camel>>Service.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   * */
  public async deleteMany<T extends Prisma.<<Model pascal>>DeleteManyArgs>(
    args?: Prisma.SelectSubset<T, Prisma.<<Model pascal>>DeleteManyArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.deleteMany<
      Prisma.SelectSubset<T, Prisma.<<Model pascal>>DeleteManyArgs>
    >(args);
  }

  /**
   * Update zero or more <<Model pascal>>s.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {<<Model pascal>>UpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many <<Model pascal>>s
   * const <<Model camel>> = await this.<<Model camel>>Service.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   * */
  public async updateMany<T extends Prisma.<<Model pascal>>UpdateManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.<<Model pascal>>UpdateManyArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.updateMany<
      Prisma.SelectSubset<T, Prisma.<<Model pascal>>UpdateManyArgs>
    >(args);
  }

  /**
   * Create or update one <<Model pascal>>.
   * @param {<<Model pascal>>UpsertArgs} args - Arguments to update or create a <<Model pascal>>.
   * @example
   * // Update or create a <<Model pascal>>
   * const <<Model camel>> = await this.<<Model camel>>Service.upsert({
   *   create: {
   *     // ... data to create a <<Model pascal>>
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the <<Model pascal>> we want to update
   *   }
   * })
   * */
  public async upsert<T extends Prisma.<<Model pascal>>UpsertArgs>(
    args: Prisma.SelectSubset<T, Prisma.<<Model pascal>>UpsertArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.upsert<
      Prisma.SelectSubset<T, Prisma.<<Model pascal>>UpsertArgs>
    >(args);
  }

  /**
   * Count the number of <<Model pascal>>s.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {<<Model pascal>>CountArgs} args - Arguments to filter <<Model pascal>>s to count.
   * @example
   * // Count the number of <<Model pascal>>s
   * const count = await this.<<Model camel>>Service.count({
   *   where: {
   *     // ... the filter for the <<Model pascal>>s we want to count
   *   }
   * })
   * */
  public async count<T extends Prisma.<<Model pascal>>CountArgs>(
    args?: Prisma.Subset<T, Prisma.<<Model pascal>>CountArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.count<
      Prisma.Subset<T, Prisma.<<Model pascal>>CountArgs>
    >(args);
  }

  /**
   * Allows you to perform aggregations operations on a <<Model pascal>>.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {<<Model pascal>>AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 <<Model camel>>s
   * const aggregations = await this.<<Model camel>>Service.aggregate({
   *   avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   * */
  public async aggregate<T extends Prisma.<<Model pascal>>AggregateArgs>(
    args: Prisma.Subset<T, Prisma.<<Model pascal>>AggregateArgs>,
  ) {
    return this.<<Model camel>>DatabaseService.aggregate<
      Prisma.Subset<T, Prisma.<<Model pascal>>AggregateArgs>
    >(args);
  }
}
