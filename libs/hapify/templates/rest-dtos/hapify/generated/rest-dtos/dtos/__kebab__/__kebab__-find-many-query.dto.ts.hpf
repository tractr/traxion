import {
  IsArray,

  <<if Fields boolean and searchable>>
  IsBoolean, 
  <<endif>>

  <<if Fields email and searchable>>
  IsEmail, 
  <<endif>>

  <<if Fields datetime and searchable>>
  IsDate, 
  <<endif>>

  IsIn,
  IsInt,
  IsNumber,
  IsOptional,
  IsString,

  <<if Fields (string and not text)>>
  MaxLength,
  <<endif>>

  <<if Fields url and searchable>>
  IsUrl, 
  <<endif>>

  <<if Fields entity and searchable>>
  IsUUID, 
  <<endif>>

  <<if Fields object and not internal>>
  IsObject, 
  <<endif>>
   
  Min,

} from 'class-validator';

<<if Fields searchable and not entity and not enum or object>>
import {
  <<if Fields searchable and boolean and not multiple>>
  BoolFilter,
  BoolFilterProps,
  <<endif>>
  <<if Fields searchable and datetime and not multiple>>
  DateTimeFilter,
  DateTimeFilterProps,
  <<endif>>
  <<if Fields searchable and number and not multiple>>
  IntFilter,
  IntFilterProps,
  <<endif>>
  <<if Fields object>>
  JsonObject,
  <<endif>>
  <<if Fields searchable and object and not multiple>>
  JsonFilter,
  JsonFilterProps,
  <<endif>>
  <<if Fields searchable and string and not multiple>>
  StringFilter,
  StringFilterProps,
  <<endif>>
} from '@tractr/common';
<<endif>>
  
import {
  <<for Fields enum enumField>>
  <<Model pascal>><<enumField pascal>>,
  <<endfor>>
  <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
  <<Model pascal>>Include,
  <<<}>>>
  SortOrder,
  <<Model pascal>>,
} from '../../../models';

import {
  <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
  TransformStringToArrayOfString,
  <<<}>>>

  <<if Fields boolean and searchable and not password>>
  TransformStringToBoolean,
  <<endif>>

  <<if Fields datetime and searchable>>
  TransformStringToDate,
  <<endif>>

  TransformStringToInt,
  } from '@tractr/common';
 
export class <<Model pascal>>FindManyQueryDto {
<<for Fields searchable and not password and not hidden field>>
  <<if field boolean>>
  @IsBoolean(<<=listModifier(field)>>)
  @TransformStringToBoolean()
  <<endif>>

  <<if field string or entity or enum>>
  @IsString(<<=listModifier(field)>>) 
  <<endif>>

  <<if field string and not text>>
  @MaxLength(<<< if (field.meta.maxLength) { >>><<-field maxLength raw>><<<}else{>>>255<<<}>>>, {
    message: '<<field pascal>> field is too long',
  })
  <<endif>>

  <<if field enum>>
  @IsIn(Object.values(<<Model pascal>><<field pascal>>), <<=listModifier(field)>>) 
  <<endif>>

  <<if field email and not searchable>>
  @IsEmail({}, <<=listModifier(field)>>) 
  <<endif>>

  <<if field entity>>
  @IsUUID("all", <<=listModifier(field)>>) 
  <<endif>>

  <<if field url and not searchable>>
  @IsUrl({}, <<=listModifier(field)>>) 
  <<endif>>

  <<if field number>>
  @IsNumber({<<if field not latitude and not longitude and not float>>maxDecimalPlaces: 0<<endif>>},<<=listModifier(field)>>)
  @TransformStringToInt()
  <<endif>>

  <<if field datetime>>
  @IsDate(<<=listModifier(field)>>)
  @TransformStringToDate()
  <<endif>>

  <<if field object>>
  @IsObject(<<=listModifier(field)>>) 
  <<< if (field.multiple) { >>>
  @IsArray()
  <<< } >>>
  <<endif>>

  @IsOptional()
  <<=optionalTypedProperty(field)>>

  <<if field searchable and not entity and not multiple and not enum >>
  @IsIn(<<=getType(field)>>FilterProps)
  @IsOptional()
  <<field camel>>FilterType: keyof <<=getType(field)>>Filter = '<<=getDefaultForType(field)>>';
  <<endif>>
 
<<endfor>>

<<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
  @TransformStringToArrayOfString()
  @IsArray()
  @IsString({ each: true })
  @IsIn(<<Model pascal>>Include, { each: true })
  @IsOptional()
  populate?: <<Model pascal>>Include[];
<<<}>>>
 
  @IsOptional()
  @IsString()
  @IsIn([
  <<for Fields sortable field>>
    '<<field camel>>',
  <<endfor>>
  ]) 
  sort: keyof <<Model pascal>> = '<<for Fields primary field>><<field camel>><<endfor>>';
 
  @IsOptional()
  @IsIn(Object.values(SortOrder)) 
  order: SortOrder = 'asc';
  
  @IsOptional()
  @IsNumber()
  @IsInt()
  @Min(1)
  @TransformStringToInt()
  take = 100;
 
  @IsOptional()
  @IsNumber()
  @IsInt()
  @Min(0)
  @TransformStringToInt()
  skip = 0;
}

<<<
function optionalTypedProperty(f) {
  let out = f.names.camel;
  out += "?: "
  if (f.type === "boolean") out += "boolean";
  else if (f.type === "string") out += "string";
  else if (f.type === "enum") out += `${root.names.pascal}${f.names.pascal}`;
  else if (f.type === "number") out += "number";
  else if (f.type === "datetime") out += "Date";
  else if (f.type === "object") out += "JsonObject";
  else if (f.type === "entity") {
    out +=  "string"
  }
  if (f.multiple) out += "[]";
  out += ";";
  return out;
}
>>>

<<<
function listModifier(f) {
  if (f.multiple) return "{ each: true}";
  else return "";
}
>>>

<<<
function getType(f) {
  let out = ""
  if (f.type === "boolean") return "Bool";
  else if (f.type === "string") return "String";
  else if (f.type === "number") return "Int";
  else if (f.type === "datetime") return "DateTime";
  else if (f.type === "object") return "Json";

  return "UnknownType";
}
function getDefaultForType(f) {
  let out = ""
  if (f.type === "boolean") return "equals";
  else if (f.type === "string") return "equals";
  else if (f.type === "number") return "equals";
  else if (f.type === "datetime") return "equals";
  else if (f.type === "object") return "equals";

  return "UnknownType";
}
>>>
