// -------------------------------------- //
// Generated schema (generated by hapify) //
// -------------------------------------- //

<<for Models model>>

<<# For each model form hapify we convert it to a prism model >>
  model <<model pascal>> {

<<# For each field in the model we generate the prisma schema >>
    <<for model.fields field>>
 
<<# If the field has a relation oneOne or oneMany >>
        <<if field oneOne or oneMany>>
    // Relation <<if field oneOne >>One To One<<else>>One to Many<<endif>> between <<model pascal>> and <<field.model pascal>>

<<# If the field has a relation oneOne or oneMany >>
<<# We generate the first relation prisma field >>
    <<=getMetadata(model, field)>>
    <<field camel>> <<field.model pascal>><<if field nullable>>?<<endif>> @relation("<<model pascal>>.<<field camel>>.<<field.model pascal>>.<<-field backRelation camel>>",fields: [<<field camel>><<=getReferencedEntityPrimary(field).names.pascal>>], references: [<<=getReferencedEntityPrimary(field).names.camel>>]<<=getOnDelete(field)>><<=getOnUpdate(field)>>)
 
    <<=getMetadata(model, field)>>
    <<field camel>><<=getReferencedEntityPrimary(field).names.pascal>> <<=getReferencedEntityPrimaryType(field)>>

<<# If the field has a relation manyMany >>
        <<elseif field manyMany>>
    // Relation Many to Many between <<field pascal>> and <<model pascal>>
    <<=getMetadata(model, field)>>
    <<field camel>> <<field.model pascal>>[] @relation("<<model pascal>>.<<field camel>>.<<field.model pascal>>.<<-field backRelation camel>>")
        <<else>>

<<# If the field has a no relation we get his prismaType >>

    <<=getMetadata(model, field)>>
    <<field camel>> <<=prismaType(field, model)>> <<=primary(field)>> <<=unique(field)>>
        <<endif>>
    <<endfor>>
 
    <<for model.referencedIn ref>>
    // Model referenced in <<ref pascal>>, use the backRelation field from hapify
        <<for ref.fields field>>
            <<if field oneOne>>
    <<-field backRelation camel>> <<ref pascal>>? @relation("<<ref pascal>>.<<field camel>>.<<model pascal>>.<<-field backRelation camel>>")
 
            <<elseif field oneMany>>
    <<-field backRelation camel>> <<ref pascal>>[] @relation("<<ref pascal>>.<<field camel>>.<<model pascal>>.<<-field backRelation camel>>")
 
            <<elseif field manyMany>>
    <<-field backRelation camel>> <<ref pascal>>[] @relation("<<ref pascal>>.<<field camel>>.<<model pascal>>.<<-field backRelation camel>>")
 
            <<endif>>
        <<endfor>>
    <<endfor>>
  }
   
<<endfor>>
 
<<for Models model>>
  <<for model.fields enum field>>
enum <<model pascal>><<field pascal>> {
   <<for field.enum enumValue>>
 <<enumValue raw>>
   <<endfor>>
}
  <<endfor>>
<<endfor>>

<<<
function getReferencedEntityPrimary(f) {
  return f.model.fields.primary
}
>>>

<<<
function getOnDelete(f) {
  if (f.meta.onDelete){
    return ", onDelete: " + f.meta.onDelete.raw;}
  return "";
}
>>>

<<<
function getOnUpdate(f) {
  if (f.meta.onUpdate)
    return ", onUpdate: " + f.meta.onUpdate.raw;
  return "";
}
>>>

<<<
function getMetadata(model, f) {
  let out = "";

  if (f.hidden) out += "/// @HideField()\n";

  switch(f.type) {
    case 'string':
      switch(f.subtype) {
        case 'text':
        case 'rich':
          break;
        case 'password':
        case 'url':
        default:
          out += "/// @Validator.MaxLength(" + (f.meta.maxLength ? f.meta.maxLength : 255) + ")\n";
      }
    case 'number':
      switch(f.subtype) {
        case 'integer':
          out += "/// @Validator.IsInt()\n";
        case 'float':
          out += "/// @Validator.IsFloat()\n";
        case 'latitude':
          out += "/// @Validator.IsLatitude()\n";
        case 'longitude':
          out += "/// @Validator.IsLongitude()\n";
      }
      break;
    case 'boolean':
        out += "/// @Validator.IsBoolean()\n";
      break;
    case 'datetime':
      switch(f.subtype) {
        case 'date':
        case 'time':
        default:
          out += "/// @Validator.IsDate()\n";
          break;
      }
      break;
    case 'entity':
      break;
    case 'object':
          out += "/// @Validator.IsObject()\n";
      break;
    case 'file':n
      switch(f.subtype) {
        case 'image':
        case 'video':
        case 'audio':
        case 'document':
          break;
      }
      break;
  }


  if (f.multiple) out += "/// @Validator.IsArray({ each: true })\n";
  if (f.enum) out+= "/// @Validator.IsEnum(" + model.names.pascal + f.names.pascal + ")\n";
  if (f.primary && f.type === 'string') out+= "/// @Validator.IsUUID()\n";
  return out;
}
>>>

<<<
function getReferencedEntityPrimaryType(f) {
  let out = "";
  if(f.model.fields.primary.type === "string") {
    out += "String";
  } else {
    throw new Error("Only type 'string' is allowed for primary key");
  }
  if(f.nullable){
    out += "?";
  }
  switch(f.model.fields.primary.subtype) {
    case 'text': return out += " @db.Text";
    default: return out += " @db.VarChar(" + (f.meta.maxLength ? f.meta.maxLength : 255) + ")";
  }
}
>>>

<<<
function prismaType(f, m) {
  let out = "";

  // Generate type for prisma
  if (f.type === "boolean") out += "Boolean";
  else if (f.type === "string") out += "String";
  else if (f.type === "enum") out += `${m.names.pascal}${f.names.pascal}`;
  else if (f.type === "number") {
    if(f.subtype === "float" || f.subtype === "latitude" || f.subtype === "longitude") out += "Float";
    else out += "Int";
  } else if (f.type === "datetime") out += "DateTime";
  else if (f.type === "object") out += "Json";
  else if (f.type === "entity") {
    out += f.m.names.pascal;
  }

  // Handle nullable and multiple fields
  if (f.multiple && f.type !== "object") out += "[]";
  else if (f.nullable) out += "?";

  switch(f.type) {
      case 'string':
          switch(f.subtype) {
              case 'text': return out += " @db.Text";
              default: return out += " @db.VarChar(" + (f.meta.maxLength ? f.meta.maxLength : 255) + ")";
          }
      case 'datetime':
          switch(f.subtype) {
              case 'date': return out += " @db.Date";
              case 'time': return out += " @db.Time(3)";
          }
      default: return out;
  }

  if (f.meta.default) {
    out += " @default(" + f.meta.default + ")";
  }

}
>>>


<<<
function primary(f) {
  if (!f.primary) return "";
  if (f.type === "string") return "@id @default(uuid())";
  if (f.type === "strnumbering") return "@id @default(autoincrement())";
}
>>>

<<<
function unique(f) {
  return f.unique ? "@unique": "";
}
>>>


