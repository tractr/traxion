// -------------------------------------- //
// Generated schema (generated by hapify) //
// -------------------------------------- //

<<for Models model>>

<<# For each model form hapify we convert it to a prism model >>
  model <<model pascal>> {

<<# For each field in the model we generate the prisma schema >>
    <<for model.fields field>>
 
<<# If the field has a relation oneOne or oneMany >>
        <<if field oneOne or oneMany>>
    // Relation <<if field oneOne >>One To One<<else>>One to Many<<endif>> between <<model pascal>> and <<field.model pascal>>

<<# If the field has a relation oneOne or oneMany >>
<<# We generate the first relation prisma field >>
    <<field camel>> <<field.model pascal>><<if field nullable>>?<<endif>> @relation("<<model pascal>>.<<field camel>>.<<field.model pascal>>.<<-field backRelation camel>>",fields: [<<field camel>><<=getReferencedEntityPrimary(field).names.pascal>>], references: [<<=getReferencedEntityPrimary(field).names.camel>>])
    <<field camel>><<=getReferencedEntityPrimary(field).names.pascal>> <<=getReferencedEntityPrimaryType(field)>>

<<# If the field has a relation manyMany >>
        <<elseif field manyMany>>
    // Relation Many to Many between <<field pascal>> and <<model pascal>>
    <<field camel>> <<field.model pascal>>[] @relation("<<model pascal>>.<<field camel>>.<<field.model pascal>>.<<-field backRelation camel>>")
        <<else>>

<<# If the field has a no relation we get his prismaType >>
    <<field camel>> <<=prismaType(field, model)>> <<=primary(field)>> <<=unique(field)>>
        <<endif>>
    <<endfor>>
 
    <<for model.referencedIn ref>>
    // Model referenced in <<ref pascal>>, use the backRelation field from hapify
        <<for ref.fields field>>
            <<if field oneOne>>
    <<-field backRelation camel>> <<ref pascal>>? @relation("<<ref pascal>>.<<field camel>>.<<model pascal>>.<<-field backRelation camel>>")
 
            <<elseif field oneMany>>
    <<-field backRelation camel>> <<ref pascal>>[] @relation("<<ref pascal>>.<<field camel>>.<<model pascal>>.<<-field backRelation camel>>")
 
            <<elseif field manyMany>>
    <<-field backRelation camel>> <<ref pascal>>[] @relation("<<ref pascal>>.<<field camel>>.<<model pascal>>.<<-field backRelation camel>>")
 
            <<endif>>
        <<endfor>>
    <<endfor>>
  }
   
<<endfor>>
 
<<for Models model>>
  <<for model.fields enum field>>
enum <<model pascal>><<field pascal>> {
   <<for field.enum enumValue>>
 <<enumValue raw>>
   <<endfor>>
}
  <<endfor>>
<<endfor>>

<<<
function getReferencedEntityPrimary(f) {
  return f.model.fields.primary
}
>>>

<<<
function getReferencedEntityPrimaryType(f) {
  let out = "";
  if(f.model.fields.primary.type === "string") {
    out += "String";
  } else {
    throw new Error("Only type 'string' is allowed for primary key");
  }
  if(f.nullable){
    out += "?";
  }
  switch(f.model.fields.primary.subtype) {
    case 'text': return out += " @db.Text";
    default: return out += " @db.VarChar(255)";
  }
}
>>>

<<<
function prismaType(f, m) {
  let out = "";

  // Generate type for prisma
  if (f.type === "boolean") out += "Boolean";
  else if (f.type === "string") out += "String";
  else if (f.type === "enum") out += `${m.names.pascal}${f.names.pascal}`;
  else if (f.type === "number") {
    if(f.subtype === "float" || f.subtype === "latitude" || f.subtype === "longitude") out += "Float";
    else out += "Int";
  } else if (f.type === "datetime") out += "DateTime";
  else if (f.type === "entity") {
    out += f.m.names.pascal;
  }

  // Handle nullable and multiple fields
  if (f.multiple) out += "[]";
  else if (f.nullable) out += "?";

  switch(f.type) {
      case 'string':
          switch(f.subtype) {
              case 'text': return out += " @db.Text";
              default: return out += " @db.VarChar(255)";
          }
      case 'datetime':
          switch(f.subtype) {
              case 'date': return out += " @db.Date";
              case 'time': return out += " @db.Time(3)";
          }
      default: return out;
  }

}
>>>


<<<
function primary(f) {
  if (!f.primary) return "";
  if (f.type === "string") return "@id @default(uuid())";
  if (f.type === "strnumbering") return "@id @default(autoincrement())";
}
>>>

<<<
function unique(f) {
  return f.unique ? "@unique": "";
}
>>>


