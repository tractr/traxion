// -------------------------------------- //
// Generated schema (generated by hapify) //
// -------------------------------------- //

<<for Models model>>

<<# For each model form hapify we convert it to a prism model >>
  model <<model pascal>> {

<<# For each field in the model we generate the prisma schema >>
    <<for model.fields field>>
 
<<# If the field has a relation oneOne or oneMany >>
        <<if field oneOne or oneMany>>
    // Relation <<if field oneOne >>One To One<<else>>One to Many<<endif>> between <<model pascal>> and <<field.model pascal>>

<<# If the field has a relation oneOne or oneMany >>
<<# We generate the first relation prisma field >>
    <<field camel>> <<field.model pascal>><<if field nullable>>?<<endif>> @relation("<<model pascal>>.<<field camel>>.<<field.model pascal>>.<<-field backRelation camel>>",fields: [<<field camel>><<=getReferencedEntityPrimary(field).names.pascal>>], references: [<<=getReferencedEntityPrimary(field).names.camel>>])
    <<field camel>><<=getReferencedEntityPrimary(field).names.pascal>> <<=getReferencedEntityPrimaryType(field)>><<if field nullable>>?<<endif>>

<<# If the field has a relation manyMany >>
        <<elseif field manyMany>>
    // Relation Many to Many between <<field pascal>> and <<model pascal>>
    <<field camel>> <<field.model pascal>>[] @relation("<<model pascal>>.<<field camel>>.<<field.model pascal>>.<<-field backRelation camel>>")
        <<else>>

<<# If the field has a no relation we get his prismaType >>
    <<field camel>> <<=prismaType(field, model)>> <<=primary(field)>> <<=unique(field)>>
        <<endif>>
    <<endfor>>
 
    <<for model.referencedIn ref>>
    // Model referenced in <<ref pascal>>, use the backRelation field from hapify
        <<for ref.fields field>>
            <<if field oneOne>>
    <<-field backRelation camel>> <<ref pascal>>? @relation("<<ref pascal>>.<<field camel>>.<<model pascal>>.<<-field backRelation camel>>")
 
            <<elseif field oneMany>>
    <<-field backRelation camel>> <<ref pascal>>[] @relation("<<ref pascal>>.<<field camel>>.<<model pascal>>.<<-field backRelation camel>>")
 
            <<elseif field manyMany>>
    <<-field backRelation camel>> <<ref pascal>>[] @relation("<<ref pascal>>.<<field camel>>.<<model pascal>>.<<-field backRelation camel>>")
 
            <<endif>>
        <<endfor>>
    <<endfor>>
  }
   
<<endfor>>
 
<<for Models model>>
  <<for model.fields enum field>>
enum <<model pascal>><<field pascal>> {
   <<for field.enum enumValue>>
 <<enumValue raw>>
   <<endfor>>
}
  <<endfor>>
<<endfor>>

<<<
function getReferencedEntityPrimary(f) {
  return f.model.fields.primary
}
>>>

<<<
function getReferencedEntityPrimaryType(f) {
  if (f.model.fields.primary.type === 'string') return 'String';
  if (f.model.fields.primary.type === 'number') return 'Int';
  throw new Error("Only types 'number' and 'string' are allowed for primary key")
}
>>>

<<<
function getEntityPrimaryType(m) {
  if (m.fields.primary.type === 'string') return 'String';
  if (m.fields.primary.type === 'number') return 'Int';
  throw new Error("Only types 'number' and 'string' are allowed for primary key")
}
>>>

<<<
function prismaType(f, m) {
  let out = "";

  // Generate type for prisma
  if (f.type === "boolean") out += "Boolean";
  else if (f.type === "string") out += "String";
  else if (f.type === "enum") out += `${m.names.pascal}${f.names.pascal}`;
  else if (f.type === "number") out += "Int";
  else if (f.type === "integer") out += "Int";
  else if (f.type === "float") out += "Float";
  else if (f.type === "datetime") out += "DateTime";
  else if (f.type === "entity")  {
    out += f.m.names.pascal;
  }

  // Handle nullable and multiple fields
  if (f.multiple) out += "[]";
  else if (f.nullable) out += "?";
  return out;
}
>>>

<<<
function primary(f) {
  if (!f.primary) return "";
  if (f.type === "string") return "@id @default(uuid())";
  if (f.type === "strnumbering") return "@id @default(autoincrement())";
}
>>>

<<<
function unique(f) {
  return f.unique ? "@unique": "";
}
>>>


