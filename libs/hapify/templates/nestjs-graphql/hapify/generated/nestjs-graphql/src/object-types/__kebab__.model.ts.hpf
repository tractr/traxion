import { Field, ID, ObjectType, registerEnumType } from '@nestjs/graphql';
 
<<<for (const relation of getRelations()) {>>>
import {
 <<relation pascal>>Gql as <<relation pascal>>,
} from './<<relation kebab>>.model';
<<<}>>>

<<if Fields object>>
import { GraphQLJSONObject } from 'graphql-type-json';
<<endif>>
 
<<if Fields enum>>
import {
  <<for Fields enum enumField>>
  <<Model pascal>><<enumField pascal>>,
  <<endfor>>
} from '../../models';
<<endif>>

<<if Fields enum>>
<<for Fields enum enumField>>
 
registerEnumType(<<Model pascal>><<enumField pascal>>, {
  name: '<<Model pascal>><<enumField pascal>>',
});
 
<<endfor>>
<<endif>>

<<if Model hasNotes>> 
 /**
  * <<!Model>>
  */
<<endif>>
@ObjectType('<<Model pascal>>')
export class <<Model pascal>>Gql {
<<for Fields field>>
<<if Model hasNotes>> 
  /**
   * <<!field>>
   */
<<endif>>

  @Field(<<if field primary or entity or object or enum>>
    () =>
    <<if field.multiple>>[<<endif>>
    <<if field primary>><<if field string>>ID<<elseif field number>>Int<<endif>>
    <<elseif field entity>><<= field.model.names.pascal>><<<if (root.name === field.model.name) {>>>Gql<<<}>>>
    <<elseif field object>>GraphQLJSONObject
    <<elseif field enum>><<Model pascal>><<field pascal>>
    <<endif>><<if field.multiple>>]<<endif>>,<<endif>><<if field nullable>>{ nullable: true, defaultValue: null }<<endif>>)
  <<=typedProperty(field)>>
 
<<endfor>>

<<for Fields oneOne or oneMany field>>
  /**
   * Reference to the associated <<field pascal>>
   */
  @Field(() => String<<if field nullable>>,{ nullable: true, defaultValue: null }<<endif>>)
  <<field camel>>Id<<if field nullable>>: string | null = null;<<else>>!: string;<<endif>>
  
<<endfor>>
<<for root.referencedIn ref>>
  <<for ref.fields field>>
  /**
   * Associated <<-field backRelation pascal>>
   */
  @Field(() => <<if field oneMany or manyMany>>[<<endif>><<ref pascal>><<<if (root.name === ref.name) {>>>Gql<<<}>>><<if field oneMany or manyMany>>]<<endif>><<if field nullable>>,{ nullable: true, defaultValue: null }<<endif>>)
  <<-field backRelation camel>>?: <<ref pascal>><<<if (root.name === ref.name) {>>>Gql<<<}>>><<if field oneMany or manyMany>>[]<<endif>>;
    
  <<endfor>>
<<endfor>>
}

<<<
function typedProperty(f) {
  let out = f.names.camel;
  if (f.type === "entity") out += "?: ";
  else out += "!: ";
  if (f.type === "boolean") out += "boolean";
  else if (f.type === "string") out += "string";
  else if (f.type === "enum") out += `${root.names.pascal}${f.names.pascal}`;
  else if (f.type === "number") out += "number";
  else if (f.type === "datetime") out += "Date";
  else if (f.type === "object") out += "Record<string, unknown>";
  else if (f.type === "entity") {
    out +=  f.model.names.pascal + (f.model.name === root.name ? 'Gql' : '');
  }
  if (f.multiple) out += "[]";
  out += ";";
  return out;
}
>>>

<<<
function listModifier(f) {
  if (f.multiple) return "{ each: true}";
  else return "";
}
>>>

<<<
function getRelations() {
  const seen = { [root.id]: true };
  return [ ...root.dependencies.list, ...root.referencedIn ]
    .filter((m) => (seen[m.id] ? false : (seen[m.id] = true)));
}
>>>

