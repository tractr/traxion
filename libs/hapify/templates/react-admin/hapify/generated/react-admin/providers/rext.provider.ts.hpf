import { DataProvider } from 'ra-core';
import { lastValueFrom, Observable } from 'rxjs';
import { map } from 'rxjs/operators';
 
import { ResourceType } from '../interfaces';
import { formatData } from '../helpers';
import { RextClient } from '../../rext-client';
 
/**
 * Maps react-admin queries to a REXT API
 *
 * This REXT dialect is the REST API generated by hapify to fetch the nestjs generated API
 *
 * @example
 *
 * getList   => GET http://my.api.url/posts?sort=['title','ASC']&range=[0, 24]
 * getOne    => GET http://my.api.url/posts/123
 * getMany   => GET http://my.api.url/posts?filter={id:[123,456,789]}
 * update    => PUT http://my.api.url/posts/123
 * create    => POST http://my.api.url/posts
 * delete    => DELETE http://my.api.url/posts/123
 *
 * @example
 *
 * import * as React from "react";
 * import { Admin, Resource } from 'react-admin';
 * import simpleRestProvider from 'ra-data-simple-rest';
 *
 * import { PostList } from './posts';
 *
 * const App = () => (
 *   <Admin dataProvider={simpleRestProvider('http://path.to.my.api/')}>
 *     <Resource name="posts" list={PostList} />
 *   </Admin>
 * );
 *
 * export default App;
 */
export function rextClientProvider(apiUrl: string | URL): DataProvider {
  const rextClient = new RextClient(apiUrl);
  return {
    getList: async (resource, params) => {
      const { page, perPage } = params.pagination;
      const { field, order } = params.sort;
 
      // TODO make the filter works
      return lastValueFrom(
        (
          rextClient[resource as unknown as ResourceType].findMany$({
            sort: 'id',
            order: order.toLowerCase(),
            take: perPage,
            skip: (page - 1) * perPage,
          }) as Observable<any>
        ).pipe(
          withLatestFrom(
            rextClient[resource as unknown as ResourceType].count$(
              {},
            ) as Observable<any>,
          ),
          map(([data, total]) => ({ data, total })),
        ),
      );
    },


 
    getOne: (resource, params) => 
      lastValueFrom(
        (
          rextClient[resource as unknown as ResourceType].findUnique$({
            id: `${params.id}`,
          }) as Observable<any>
        ).pipe(map((data) => ({ data }))),
      ),
 
    getMany: (resource, params) => {
      return lastValueFrom(
        (
          rextClient[resource as unknown as ResourceType].findMany$({
            order: 'asc',
            skip: 0,
            sort: 'id',
            take: 1000,
            // FIXME make possible the fetch of multiple ids
            id: `${params.ids[0]}`,
          }) as Observable<any>
        ).pipe(map((data) => ({ data }))),
      );
    },
 
    getManyReference: (resource, params) => {
      const { page, perPage } = params.pagination;
      const { field, order } = params.sort;
      const query = {
        sort: JSON.stringify([field, order]),
        range: JSON.stringify([(page - 1) * perPage, page * perPage - 1]),
        filter: JSON.stringify({
          ...params.filter,
          [params.target]: params.id,
        }),
      };
 
      // TODO make the filter works
      return lastValueFrom(
        (
          rextClient[resource as unknown as ResourceType].findMany$({
            sort: 'id',
            order: order.toLowerCase(),
            take: perPage,
            skip: (page - 1) * perPage,
          }) as Observable<any>
        ).pipe(map((data) => ({ data, total: data.length }))),
      );
    },
 
    update: (resource, params) => {
      const resourceName = resource as unknown as ResourceType;
      const toUpdate = formatData[resourceName]({ ...params.data });

      return lastValueFrom(
        (
          rextClient[resource as unknown as ResourceType].patch$({
            id: `${params.id}`,
          }, toUpdate) as Observable<any>
        ).pipe(map((data) => ({ data }))),
      );
    },
 
    // rext client doesn't provide an updateMany method, so we fallback to calling update n times instead
    updateMany: (resource, params) => {
      const resourceName = resource as unknown as ResourceType;
      const toUpdate = formatData[resourceName]({ ...params.data });
 
      return Promise.all(
        params.ids.map((id) =>
          lastValueFrom(
            (
              rextClient[resourceName].patch$({
                id: `${id}`,
              }, toUpdate) as Observable<any>
            ),
          ),
        )
      ).then(responses => ({ data: responses.map(({ id }) => id) }));
    },
 
    create: (resource, params) => {
      const resourceName = resource as unknown as ResourceType;
      const toCreate = formatData[resourceName]({ ...params.data });
 
      return lastValueFrom(
        (
          rextClient[resourceName].create$(
            toCreate as any
          ) as Observable<any>
        ).pipe(map((data) => ({ data }))),
      );
    },
 
    delete: (resource, params) =>
      lastValueFrom(
        (
          rextClient[resource as unknown as ResourceType].delete$({
            id: `${params.id}`,
          }) as Observable<any>
        ).pipe(map((data) => ({ data }))),
      ),
 
    // rext client doesn't provide an deleteMany method, so we fallback to calling delete n times instead
    deleteMany: (resource, params) =>
      Promise.all(
        params.ids.map(id =>
          lastValueFrom(
            (
              rextClient[resource as unknown as ResourceType].delete$({
                id: `${id}`,
              }) as Observable<any>
            ),
          ),
        )
      ).then(responses => ({ data: responses.map(({ id }) => id) })),
  };
}
 