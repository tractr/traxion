/* eslint-disable @typescript-eslint/unbound-method */
import { AbilityBuilder } from '@casl/ability';
import {
  CanActivate,
  ExecutionContext,
  INestApplication,
  Injectable,
} from '@nestjs/common';
import { APP_GUARD, APP_INTERCEPTOR } from '@nestjs/core';
import { Test, TestingModule } from '@nestjs/testing';
import { User } from '@prisma/client';
import { mockDeep, MockProxy } from 'jest-mock-extended';
import * as request from 'supertest';

import { <<Model pascal>>Controller } from './<<Model kebab>>.controller';
import { <<Model pascal>>RestDtoService } from '../services';
import { <<Model constant>>_REST_DTO_SERVICE } from '../<<Model kebab>>-rest.constant';
import {
  mock<<Model pascal>>CountQueryDtoFactory,
  mock<<Model pascal>>CreateBodyDtoFactory,
  mock<<Model pascal>>FindManyQueryDtoFactory,
  mock<<Model pascal>>UpdateBodyDtoFactory,
  mock<<Model pascal>>UpsertBodyDtoFactory,
} from '../../../rest-dtos/mock';

import { Actions, AppAbility } from '../../../../casl';
import {
  <<<if (root.names.pascal !== 'User') { >>>mockUserFactory,<<< }>>>
  mock<<Model pascal>>Factory,
  mock<<Model pascal>>sFactory,
} from '../../../../models/mock';
import {
  <<Model constant>>_DATABASE_SERVICE,
  <<Model constant>>_SERVICE,
  <<Model pascal>>Service,
} from '../../../../nestjs-models-common';
import {
  <<Model pascal>>CreateBodyDto,
  <<Model pascal>>UpdateBodyDto,
  <<Model pascal>>UpsertBodyDto,
} from '../../../../rest-dtos';
<<if Fields not ownership and not primary and internal and enum>>
import {
<<for Fields not ownership and not primary and internal and enum field>>
  <<Model pascal>><<field pascal>>,
<<endfor>>
} from '../../../../models';
<<endif>>
import { CaslExceptionInterceptor } from '@trxn/nestjs-casl';
import { LoggerModule, TraxionValidationPipe } from '@trxn/nestjs-core';

describe('<<Model pascal>>Controller', () => {
  let app: INestApplication;
  let mock<<Model pascal>>Service: MockProxy<<<Model pascal>>Service>;
  let mockReqAbilities: jest.Mock<AppAbility>;
  let mockReqUser: jest.Mock<User>;

  <<if Fields internal and not primary and (not entity or nullable)>>
  const fakedInternals = {
    __fake: true
  }
  <<endif>>

  beforeAll(async () => {
    mock<<Model pascal>>Service = mockDeep<<<Model pascal>>Service>();
    mockReqAbilities = jest.fn(undefined);
    mockReqUser = jest.fn(undefined);

    class Guard implements CanActivate {
      canActivate(context: ExecutionContext) {
        const req = context.switchToHttp().getRequest();
        req.abilities = mockReqAbilities();
        req.user = mockReqUser();
        return true;
      }
    }
    Injectable()(Guard);

    const moduleFixture: TestingModule = await Test.createTestingModule({
      controllers: [<<Model pascal>>Controller],
      imports: [LoggerModule],
      providers: [
        {
          provide: <<Model constant>>_SERVICE,
          useValue: mock<<Model pascal>>Service,
        },
        {
          provide: <<Model constant>>_REST_DTO_SERVICE,
          useClass: <<Model pascal>>RestDtoService,
        },
        { provide: APP_GUARD, useClass: Guard },
        { provide: APP_INTERCEPTOR, useClass: CaslExceptionInterceptor },
      ],
    }).compile();

    app = moduleFixture.createNestApplication();

    app.useGlobalPipes(new TraxionValidationPipe());

    await app.init();

    <<if Fields internal and not primary and (not entity or nullable)>>
    // Add faked default internals
    (
      mock<<Model pascal>>Service.getDefaultInternals as jest.Mock
    ).mockReturnValue(fakedInternals);
    <<endif>>

  });

  afterEach(async () => {
    mock<<Model pascal>>Service.create.mockReset();
    mock<<Model pascal>>Service.count.mockReset();
    mock<<Model pascal>>Service.findMany.mockReset();
    mock<<Model pascal>>Service.findUnique.mockReset();
    mock<<Model pascal>>Service.update.mockReset();
    mock<<Model pascal>>Service.upsert.mockReset();
    mock<<Model pascal>>Service.delete.mockReset();
    <<if Fields internal and not primary and (not entity or nullable)>>
    mock<<Model pascal>>Service.getDefaultInternals.mockClear();
    <<endif>>
    <<if Fields ownership and not primary and internal>>
    mock<<Model pascal>>Service.getDefaultOwnerships.mockClear();
    <<endif>>
    mockReqAbilities.mockReset();
    mockReqUser.mockReset();
    if (app) await app.close();
  });

  it('<<Model pascal>>Controller should be able to be used by nestjs', async () => {
    expect(app.get(<<Model pascal>>Controller)).toBeDefined();
  });

  describe('POST /<<Model kebab>>', () => {
    it('should create a <<Model camel>>', async () => {
      const <<Model camel>>: <<Model pascal>>CreateBodyDto = mock<<Model pascal>>CreateBodyDtoFactory();

      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      (mock<<Model pascal>>Service.getDefaultOwnerships as jest.Mock).mockReturnValue({
        <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser },
        <<endfor>>
      });
      <<endif>>

      await request(app.getHttpServer()).post('/<<Model kebab>>').send(<<Model camel>>).expect(201);

      <<if Fields internal and not primary and (not entity or nullable)>>
      expect(mock<<Model pascal>>Service.getDefaultInternals).toHaveBeenCalled();
      <<endif>>

      <<if Fields ownership and not primary and internal>>
      expect(mock<<Model pascal>>Service.getDefaultOwnerships).toHaveBeenCalledTimes(1);
      <<endif>>

      expect(mock<<Model pascal>>Service.create).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.create).toHaveBeenCalledWith({
        data: {
          <<if Fields internal and not primary and (not entity or nullable)>>
          ...fakedInternals,
          <<endif>>
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal and not manyOne field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
      });
    });

    it('should create a <<Model camel>> and check the right with casl', async () => {
      const <<Model camel>>: <<Model pascal>>CreateBodyDto = mock<<Model pascal>>CreateBodyDtoFactory();

      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      (mock<<Model pascal>>Service.getDefaultOwnerships as jest.Mock).mockReturnValue({
        <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser },
        <<endfor>>
      });
      <<endif>>

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.CREATE, '<<Model pascal>>');
      mockReqAbilities.mockReturnValue(build());

      await request(app.getHttpServer()).post('/<<Model kebab>>').send(<<Model camel>>).expect(201);

      <<if Fields internal and not primary and (not entity or nullable)>>
      expect(mock<<Model pascal>>Service.getDefaultInternals).toHaveBeenCalled();
      <<endif>>

      <<if Fields ownership and not primary and internal>>
      expect(mock<<Model pascal>>Service.getDefaultOwnerships).toHaveBeenCalledTimes(1);
      <<endif>>

      expect(mock<<Model pascal>>Service.create).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.create).toHaveBeenCalledWith({
        data: {
          <<if Fields internal and not primary and (not entity or nullable)>>
          ...fakedInternals,
          <<endif>>
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal and not manyOne field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
      });
    });
  });

  describe('GET /<<Model kebab>>/count', () => {
    it('should get the <<Model camel>> count', async () => {
      await request(app.getHttpServer()).get('/<<Model kebab>>/count').expect(200);

      expect(mock<<Model pascal>>Service.count).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.count).toHaveBeenCalledWith({});
    });

    it('should get the <<Model camel>> count with filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>CountQueryDtoFactory();

      await request(app.getHttpServer())
        .get('/<<Model kebab>>/count')
      <<for Fields searchable and not password and not hidden and not manyOne field>>
        .query(`<<field camel>>=${mock<<Model pascal>>.<<field camel>>}`)
      <<endfor>>
        .expect(200);

      expect(mock<<Model pascal>>Service.count).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.count).toHaveBeenCalledWith({
        where: {
        <<for Fields searchable and not password and not hidden and not manyOne field>>
          <<field camel>>: {
            <<if field manyMany>>some<<elseif field entity>>id<<else>>equals<<endif>>: <<if field manyMany>>{ id: { in: mock<<Model pascal>>.<<field camel>>?.reverse() } }<<elseif field oneMany>>{ in: [mock<<Model pascal>>.<<field camel>>] }<<elseif field number>>Number(mock<<Model pascal>>.<<field camel>>)<<elseif field boolean>>mock<<Model pascal>>.<<field camel>> === 'true'<<elseif field datetime>>new Date(mock<<Model pascal>>.<<field camel>> as string)<<elseif field object or multiple>>JSON.parse(mock<<Model pascal>>.<<field camel>> as string)<<else>>mock<<Model pascal>>.<<field camel>><<endif>>
          },
        <<endfor>>
        },
      });
    });

    <<if Fields ownership>>
    it('should get the <<Model camel>> count with casl abilities filter', async () => {
      const <<Model camel>> = mock<<Model pascal>>Factory();

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: <<Model camel>>.id });
      mockReqAbilities.mockReturnValue(build());

      await request(app.getHttpServer()).get('/<<Model kebab>>/count').expect(200);

      expect(mock<<Model pascal>>Service.count).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.count).toHaveBeenCalledWith({
        where: {
          AND: [
            {
              OR: [{ id: <<Model camel>>.id }],
            },
            {},
          ],
        },
      });
    });

    it('should get the <<Model camel>> count with casl abilities filter and with filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>CountQueryDtoFactory();

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());

      await request(app.getHttpServer())
        .get('/<<Model kebab>>/count')
      <<for Fields searchable and not password and not hidden and not manyOne field>>
        .query(`<<field camel>>=${mock<<Model pascal>>.<<field camel>>}`)
      <<endfor>>
        .expect(200);

      expect(mock<<Model pascal>>Service.count).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.count).toHaveBeenCalledWith({
        where: {
          AND: [
            {
              OR: [{ id: mock<<Model pascal>>.id }],
            },
            {
            <<for Fields searchable and not password and not hidden and not manyOne field>>
              <<field camel>>: {
                <<if field manyMany>>some<<elseif field entity>>id<<else>>equals<<endif>>: <<if field manyMany>>{ id: { in: mock<<Model pascal>>.<<field camel>>?.reverse() } }<<elseif field oneMany>>{ in: [mock<<Model pascal>>.<<field camel>>] }<<elseif field number>>Number(mock<<Model pascal>>.<<field camel>>)<<elseif field boolean>>mock<<Model pascal>>.<<field camel>> === 'true'<<elseif field datetime>>new Date(mock<<Model pascal>>.<<field camel>> as string)<<elseif field object or multiple>>JSON.parse(mock<<Model pascal>>.<<field camel>> as string)<<else>>mock<<Model pascal>>.<<field camel>><<endif>>
              },
            <<endfor>>
            },
          ],
        },
      });
    });
    <<endif>>
  });

  describe('GET /<<Model kebab>>/:id', () => {
    it('should return 404 if no <<Model camel>> found', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();

      await request(app.getHttpServer())
        .get(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(404);

      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledWith({
        where: {
          id: mock<<Model pascal>>.id,
        },
      });
    });

    it('should get the <<Model camel>>', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      await request(app.getHttpServer())
        .get(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(200);

      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledWith({
        where: {
          id: mock<<Model pascal>>.id,
        },
      });
    });

    <<if Fields ownership>>
    it('should get the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());

      await request(app.getHttpServer())
        .get(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(200);

      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });

    it('should forbid the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: 'foo' });
      mockReqAbilities.mockReturnValue(build());

      await request(app.getHttpServer())
        .get(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(403);

      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
    <<endif>>
  });

  describe('GET /<<Model kebab>>', () => {
    it('should get a list of <<Model pascal>>s and have default options', async () => {
      const mock<<Model pascal>>s = mock<<Model pascal>>sFactory({}, 5);
      mock<<Model pascal>>Service.findMany.mockResolvedValue(mock<<Model pascal>>s);

      const res = await request(app.getHttpServer()).get('/<<Model kebab>>').expect(200);

      expect(res.body.length).toEqual(mock<<Model pascal>>s.length);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledWith({
        orderBy: { id: 'asc' },
        take: 100,
      });
    });

    it('should get a list of <<Model pascal>>s and take a specific number them', async () => {
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
        .query('take=5')
        .expect(200);

      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledWith({
        orderBy: { id: 'asc' },
        take: 5,
      });
    });

    it('should get a list of <<Model pascal>>s and skip a specific number them', async () => {
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
        .query('skip=5')
        .expect(200);

      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledWith({
        orderBy: { id: 'asc' },
        skip: 5,
        take: 100,
      });
    });

    it('should get a list of <<Model pascal>>s and order by them', async () => {
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
        <<for Fields sortable field>>
        .query('sort[]=<<field camel>>')
        <<endfor>>
        .expect(200);

      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledWith({
        orderBy: {
        <<for Fields sortable field>>
          <<field camel>>: 'asc',
        <<endfor>>
        },
        take: 100,
      });
    });

    it('should get a list of <<Model pascal>>s and order by them desc', async () => {
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
        <<for Fields sortable field>>
        .query('sort[]=<<field camel>>')
        <<endfor>>
        .query('order=desc')
        .expect(200);

      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledWith({
        orderBy: {
        <<for Fields sortable field>>
          <<field camel>>: 'desc',
        <<endfor>>
        },
        take: 100,
      });
    });

    it('should get a list of <<Model pascal>>s and order by them desc', async () => {
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
        <<for Fields sortable field>>
        .query('sort[]=<<field camel>>:desc')
        <<endfor>>
        .expect(200);

      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledWith({
        orderBy: {
        <<for Fields sortable field>>
          <<field camel>>: 'desc',
        <<endfor>>
        },
        take: 100,
      });
    });

    it('should get a list of <<Model pascal>>s and filter them with value', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>FindManyQueryDtoFactory();

      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
      <<for Fields searchable and not password and not hidden and not manyOne field>>
        .query(`<<field camel>>=${mock<<Model pascal>>.<<field camel>>}`)
      <<endfor>>
        .expect(200);

      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledWith({
        where: {
        <<for Fields searchable and not password and not hidden and not manyOne field>>
          <<field camel>>: {
            <<if field manyMany>>some<<elseif field entity>>id<<else>>equals<<endif>>: <<if field manyMany>>{ id: { in: mock<<Model pascal>>.<<field camel>>?.reverse() } }<<elseif field oneMany>>{ in: [mock<<Model pascal>>.<<field camel>>] }<<elseif field number>>Number(mock<<Model pascal>>.<<field camel>>)<<elseif field boolean>>mock<<Model pascal>>.<<field camel>> === 'true'<<elseif field datetime>>new Date(mock<<Model pascal>>.<<field camel>> as string)<<elseif field object or multiple>>JSON.parse(mock<<Model pascal>>.<<field camel>> as string)<<else>>mock<<Model pascal>>.<<field camel>><<endif>>
          },
        <<endfor>>
        },
        orderBy: { id: 'asc' },
        take: 100,
      });
    });

    it('should get a list of <<Model pascal>>s and combine all query params', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>FindManyQueryDtoFactory();

      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
      <<for Fields searchable and not password and not hidden and not manyOne field>>
        .query(`<<field camel>>=${mock<<Model pascal>>.<<field camel>>}<<if field string>>:contains<<endif>>`)
      <<endfor>>
        .query('skip=5')
        .query('take=5')
        <<for Fields sortable field>>
        .query('sort[]=<<field camel>>:desc')
        <<endfor>>
        .expect(200);

      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledWith({
        where: {
        <<for Fields searchable and not password and not hidden and not manyOne field>>
          <<field camel>>: {
            <<if field string>>contains<<elseif field manyMany>>some<<elseif field entity>>id<<else>>equals<<endif>>: <<if field manyMany>>{ id: { in: mock<<Model pascal>>.<<field camel>>?.reverse() } }<<elseif field oneMany>>{ in: [mock<<Model pascal>>.<<field camel>>] }<<elseif field number>>Number(mock<<Model pascal>>.<<field camel>>)<<elseif field boolean>>mock<<Model pascal>>.<<field camel>> === 'true'<<elseif field datetime>>new Date(mock<<Model pascal>>.<<field camel>> as string)<<elseif field object or multiple>>JSON.parse(mock<<Model pascal>>.<<field camel>> as string)<<else>>mock<<Model pascal>>.<<field camel>><<endif>>
          },
        <<endfor>>
        },
        skip: 5,
        take: 5,
        orderBy: {
        <<for Fields sortable field>>
          <<field camel>>: 'desc',
        <<endfor>>
        },
      });
    });

    <<if Fields ownership>>
    it('should get the <<Model camel>>s with casl abilities', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>FindManyQueryDtoFactory();

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());

      await request(app.getHttpServer()).get('/<<Model kebab>>').expect(200);

      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledWith({
        where: {
          AND: [
            {
              OR: [{ id: mock<<Model pascal>>.id }],
            },
            {},
          ],
        },
        take: 100,
        orderBy: { id: 'asc' },
      });
    });

    it('should get the <<Model camel>>s with casl abilities and with filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>FindManyQueryDtoFactory();

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());

      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
      <<for Fields searchable and not password and not hidden and not manyOne field>>
        .query(`<<field camel>>=${mock<<Model pascal>>.<<field camel>>}`)
      <<endfor>>
        .expect(200);

      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findMany).toHaveBeenCalledWith({
        where: {
          AND: [
            {
              OR: [{ id: mock<<Model pascal>>.id }],
            },
            {
            <<for Fields searchable and not password and not hidden and not manyOne field>>
              <<field camel>>: {
                <<if field manyMany>>some<<elseif field entity>>id<<else>>equals<<endif>>: <<if field manyMany>>{ id: { in: mock<<Model pascal>>.<<field camel>>?.reverse() } }<<elseif field oneMany>>{ in: [mock<<Model pascal>>.<<field camel>>] }<<elseif field number>>Number(mock<<Model pascal>>.<<field camel>>)<<elseif field boolean>>mock<<Model pascal>>.<<field camel>> === 'true'<<elseif field datetime>>new Date(mock<<Model pascal>>.<<field camel>> as string)<<elseif field object or multiple>>JSON.parse(mock<<Model pascal>>.<<field camel>> as string)<<else>>mock<<Model pascal>>.<<field camel>><<endif>>
              },
            <<endfor>>
            },
          ],
        },
        take: 100,
        orderBy: { id: 'asc' },
      });
    });
    <<endif>>
  });

  describe('PATCH /<<Model kebab>>/:id', () => {
    it('should update a <<Model camel>>', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      const <<Model camel>>: <<Model pascal>>UpdateBodyDto = mock<<Model pascal>>UpdateBodyDtoFactory();

      await request(app.getHttpServer())
        .patch(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(200);

      expect(mock<<Model pascal>>Service.update).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.update).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
        data: {
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { set: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
        },
      });
    });

    it('should return 404 if no <<Model camel>> found', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(null as any);

      const <<Model camel>>: <<Model pascal>>UpdateBodyDto = mock<<Model pascal>>UpdateBodyDtoFactory();

      await request(app.getHttpServer())
        .patch(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(404);

      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });

    <<if Fields ownership>>
    it('should update the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());

      const <<Model camel>>: <<Model pascal>>UpdateBodyDto = mock<<Model pascal>>UpdateBodyDtoFactory();

      await request(app.getHttpServer())
        .patch(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(200);

      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });

    it('should forbid the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: 'foo' });
      mockReqAbilities.mockReturnValue(build());

      const <<Model camel>>: <<Model pascal>>UpdateBodyDto = mock<<Model pascal>>UpdateBodyDtoFactory();

      await request(app.getHttpServer())
        .patch(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(403);

      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
    <<endif>>
  });

  describe('PUT /<<Model kebab>>(/:id)?', () => {
    it('should update a <<Model camel>> if <<Model camel>> id is not found in the database', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(null as any);

      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      (mock<<Model pascal>>Service.getDefaultOwnerships as jest.Mock).mockReturnValue({
        <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser },
        <<endfor>>
      });

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      can(Actions.CREATE, '<<Model pascal>>');
      mockReqAbilities.mockReturnValue(build());
      <<endif>>

      const <<Model camel>>: <<Model pascal>>UpsertBodyDto = mock<<Model pascal>>UpsertBodyDtoFactory();

      await request(app.getHttpServer())
        .put(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(200);

      <<if Fields internal and not primary and (not entity or nullable)>>
      expect(mock<<Model pascal>>Service.getDefaultInternals).toHaveBeenCalled();
      <<endif>>

      <<if Fields ownership and not primary and internal>>
      expect(mock<<Model pascal>>Service.getDefaultOwnerships).toHaveBeenCalledTimes(1);
      <<endif>>

      expect(mock<<Model pascal>>Service.upsert).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.upsert).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
        create: {
          <<if Fields internal and not primary and (not entity or nullable)>>
          ...fakedInternals,
          <<endif>>
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
        update: {
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { set: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
        },
      });
    });

    it('should update a <<Model camel>> if <<Model camel>> id is found in the database', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      (mock<<Model pascal>>Service.getDefaultOwnerships as jest.Mock).mockReturnValue({
        <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser },
        <<endfor>>
      });

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      can(Actions.CREATE, '<<Model pascal>>');
      mockReqAbilities.mockReturnValue(build());
      <<endif>>

      const <<Model camel>>: <<Model pascal>>UpsertBodyDto = mock<<Model pascal>>UpsertBodyDtoFactory();

      await request(app.getHttpServer())
        .put(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(200);

      <<if Fields internal and not primary and (not entity or nullable)>>
      expect(mock<<Model pascal>>Service.getDefaultInternals).toHaveBeenCalled();
      <<endif>>

      <<if Fields ownership and not primary and internal>>
      expect(mock<<Model pascal>>Service.getDefaultOwnerships).toHaveBeenCalledTimes(1);
      <<endif>>

      expect(mock<<Model pascal>>Service.upsert).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.upsert).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
        create: {
          <<if Fields internal and not primary and (not entity or nullable)>>
          ...fakedInternals,
          <<endif>>
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
        update: {
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { set: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
        },
      });
    });

    it('should create a <<Model camel>> if no id is provided', async () => {
      const { id } = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(null as any);

      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      (mock<<Model pascal>>Service.getDefaultOwnerships as jest.Mock).mockReturnValue({
        <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser },
        <<endfor>>
      });

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id });
      can(Actions.CREATE, '<<Model pascal>>');
      mockReqAbilities.mockReturnValue(build());
      <<endif>>

      const <<Model camel>>: <<Model pascal>>UpsertBodyDto = mock<<Model pascal>>UpsertBodyDtoFactory();

      await request(app.getHttpServer())
        .put(`/<<Model kebab>>`)
        .send(<<Model camel>>)
        .expect(200);

      <<if Fields internal and not primary and (not entity or nullable)>>
      expect(mock<<Model pascal>>Service.getDefaultInternals).toHaveBeenCalled();
      <<endif>>

      <<if Fields ownership and not primary and internal>>
      expect(mock<<Model pascal>>Service.getDefaultOwnerships).toHaveBeenCalledTimes(1);
      <<endif>>

      expect(mock<<Model pascal>>Service.upsert).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.upsert).toHaveBeenCalledWith({
        where: { id: undefined },
        create: {
          <<if Fields internal and not primary and (not entity or nullable)>>
          ...fakedInternals,
          <<endif>>
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
        update: {
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { set: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
        },
      });
    });

    it('should update a <<Model camel>> if an id is provided', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      (mock<<Model pascal>>Service.getDefaultOwnerships as jest.Mock).mockReturnValue({
        <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser },
        <<endfor>>
      });

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      can(Actions.CREATE, '<<Model pascal>>');
      mockReqAbilities.mockReturnValue(build());
      <<endif>>

      const <<Model camel>>: <<Model pascal>>UpsertBodyDto = mock<<Model pascal>>UpsertBodyDtoFactory();

      await request(app.getHttpServer())
        .put(`/<<Model kebab>>`)
        .send({ ...<<Model camel>>, id: mock<<Model pascal>>.id })
        .expect(200);

      <<if Fields internal and not primary and (not entity or nullable)>>
      expect(mock<<Model pascal>>Service.getDefaultInternals).toHaveBeenCalled();
      <<endif>>

      <<if Fields ownership and not primary and internal>>
      expect(mock<<Model pascal>>Service.getDefaultOwnerships).toHaveBeenCalledTimes(1);
      <<endif>>

      expect(mock<<Model pascal>>Service.upsert).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.upsert).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
        create: {
          <<if Fields internal and not primary and (not entity or nullable)>>
          ...fakedInternals,
          <<endif>>
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
        update: {
          <<for Fields not primary and not internal and not manyOne field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { set: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
        },
      });
    });
  });

  describe('DELETE /<<Model kebab>>/:id', () => {
    it('should delete a <<Model camel>>', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      await request(app.getHttpServer())
        .delete(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(200);

      expect(mock<<Model pascal>>Service.delete).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.delete).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });

    it('should return 404 if no <<Model camel>> found', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(null as any);

      await request(app.getHttpServer())
        .delete(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(404);

      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });

    <<if Fields ownership>>
    it('should delete the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.REMOVE, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());

      await request(app.getHttpServer())
        .delete(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(200);

      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });

    it('should forbid the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      mock<<Model pascal>>Service.findUnique.mockResolvedValue(mock<<Model pascal>> as any);

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: 'foo' });
      mockReqAbilities.mockReturnValue(build());

      await request(app.getHttpServer())
        .delete(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(403);

      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>Service.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
    <<endif>>
  });
});
