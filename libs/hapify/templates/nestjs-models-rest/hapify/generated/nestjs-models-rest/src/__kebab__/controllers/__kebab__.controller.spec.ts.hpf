/* eslint-disable @typescript-eslint/unbound-method */
import { AbilityBuilder } from '@casl/ability';
import {
  CanActivate,
  ExecutionContext,
  INestApplication,
  Injectable,
} from '@nestjs/common';
import { APP_GUARD, APP_INTERCEPTOR } from '@nestjs/core';
import { Test, TestingModule } from '@nestjs/testing';
import { User } from '@prisma/client';
import { mockDeep, MockProxy } from 'jest-mock-extended';
import * as request from 'supertest';
	
import { <<Model pascal>>Controller } from './<<Model kebab>>.controller';
import { <<Model pascal>>RestDtoService } from '../services';
import { <<Model constant>>_REST_DTO_SERVICE } from '../<<Model kebab>>-rest.constant';
import {
  mock<<Model pascal>>CountQueryDtoFactory,
  mock<<Model pascal>>CreateBodyDtoFactory,
  mock<<Model pascal>>FindManyQueryDtoFactory,
  mock<<Model pascal>>UpdateBodyDtoFactory,
  mock<<Model pascal>>UpsertBodyDtoFactory,
} from '../../../rest-dtos/mock';
	
import { Actions, AppAbility } from '../../../../casl';
import {
  <<<if (root.names.pascal !== 'User') { >>>mockUserFactory,<<< }>>>
  mock<<Model pascal>>Factory,
  mock<<Model pascal>>sFactory,
} from '../../../../models/mock';
import {
  <<Model constant>>_DATABASE_SERVICE,
  <<Model constant>>_SERVICE,
  <<Model pascal>>Service,
} from '../../../../nestjs-models-common';
import {
  <<Model pascal>>CreateBodyDto,
  <<Model pascal>>UpdateBodyDto,
  <<Model pascal>>UpsertBodyDto,
} from '../../../../rest-dtos';
<<if Fields not ownership and not primary and internal and enum>>
import {
<<for Fields not ownership and not primary and internal and enum field>>
  <<Model pascal>><<field pascal>>,
<<endfor>>
} from '../../../../models';
<<endif>>
import { CaslExceptionInterceptor } from '@tractr/nestjs-casl';
import { LoggerModule, TraxionValidationPipe } from '@tractr/nestjs-core';
	
describe('<<Model pascal>>Controller', () => {
  let app: INestApplication;
  let mock<<Model pascal>>DatabaseService: MockProxy<<<Model pascal>>Service>;
  let mockReqAbilities: jest.Mock<AppAbility>;
  let mockReqUser: jest.Mock<User>;
	
  beforeAll(async () => {
    mock<<Model pascal>>DatabaseService = mockDeep<<<Model pascal>>Service>();
    mockReqAbilities = jest.fn(undefined);
    mockReqUser = jest.fn(undefined);
	
    class Guard implements CanActivate {
      canActivate(context: ExecutionContext) {
        const req = context.switchToHttp().getRequest();
        req.abilities = mockReqAbilities();
        req.user = mockReqUser();
        return true;
      }
    }
    Injectable()(Guard);
	
    const moduleFixture: TestingModule = await Test.createTestingModule({
      controllers: [<<Model pascal>>Controller],
      imports: [LoggerModule],
      providers: [
        {
          provide: <<Model constant>>_SERVICE,
          useClass: <<Model pascal>>Service,
        },
        {
          provide: <<Model constant>>_DATABASE_SERVICE,
          useValue: mock<<Model pascal>>DatabaseService,
        },
        {
          provide: <<Model constant>>_REST_DTO_SERVICE,
          useClass: <<Model pascal>>RestDtoService,
        },
        { provide: APP_GUARD, useClass: Guard },
        { provide: APP_INTERCEPTOR, useClass: CaslExceptionInterceptor },
      ],
    }).compile();
	
    app = moduleFixture.createNestApplication();
	
    app.useGlobalPipes(new TraxionValidationPipe());
	
    await app.init();
  });
	
  afterEach(async () => {
    mock<<Model pascal>>DatabaseService.create.mockReset();
    mock<<Model pascal>>DatabaseService.count.mockReset();
    mock<<Model pascal>>DatabaseService.findMany.mockReset();
    mock<<Model pascal>>DatabaseService.findUnique.mockReset();
    mock<<Model pascal>>DatabaseService.update.mockReset();
    mock<<Model pascal>>DatabaseService.upsert.mockReset();
    mock<<Model pascal>>DatabaseService.delete.mockReset();
    mockReqAbilities.mockReset();
    mockReqUser.mockReset();
    if (app) await app.close();
  });
	
  it('<<Model pascal>>Controller should be able to be used by nestjs', async () => {
    expect(app.get(<<Model pascal>>Controller)).toBeDefined();
  });
	
  describe('POST /<<Model kebab>>', () => {
    it('should create a <<Model camel>>', async () => {
      const <<Model camel>>: <<Model pascal>>CreateBodyDto = mock<<Model pascal>>CreateBodyDtoFactory();
	
      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      <<endif>>
	
      await request(app.getHttpServer()).post('/<<Model kebab>>').send(<<Model camel>>).expect(201);
	
      expect(mock<<Model pascal>>DatabaseService.create).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.create).toHaveBeenCalledWith({
        data: {
          <<for Fields not ownership and not primary and internal field>>
          <<field camel>>:<<< if (field.meta.default) { >>><<-field default raw>><<< } else { >>>
            <<if field datetime>>expect.any(Date)
            <<elseif field boolean>>false
            <<elseif field enum>><<Model pascal>><<field pascal>>["<<for1 field.enum e>><<e raw>><<endfor>>"]
            <<elseif field nullable>>null
            <<elseif field number>>0
            <<elseif field string>>''<<endif>>
          <<< } >>>,
          <<endfor>>
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
      });
    });

    it('should create a <<Model camel>> and check the right with casl', async () => {
      const <<Model camel>>: <<Model pascal>>CreateBodyDto = mock<<Model pascal>>CreateBodyDtoFactory();
	
      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      <<endif>>

      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.CREATE, '<<Model pascal>>');
      mockReqAbilities.mockReturnValue(build());
	
      await request(app.getHttpServer()).post('/<<Model kebab>>').send(<<Model camel>>).expect(201);
	
      expect(mock<<Model pascal>>DatabaseService.create).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.create).toHaveBeenCalledWith({
        data: {
          <<for Fields not ownership and not primary and internal field>>
          <<field camel>>:<<< if (field.meta.default) { >>><<-field default raw>><<< } else { >>>
            <<if field datetime>>expect.any(Date)
            <<elseif field boolean>>false
            <<elseif field enum>><<Model pascal>><<field pascal>>["<<for1 field.enum e>><<e raw>><<endfor>>"]
            <<elseif field nullable>>null
            <<elseif field number>>0
            <<elseif field string>>''<<endif>>
          <<< } >>>,
          <<endfor>>
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
      });
    });
  });
	
  describe('GET /<<Model kebab>>/count', () => {
    it('should get the <<Model camel>> count', async () => {
      await request(app.getHttpServer()).get('/<<Model kebab>>/count').expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.count).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.count).toHaveBeenCalledWith({});
    });
	
    it('should get the <<Model camel>> count with filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>CountQueryDtoFactory();
	
      await request(app.getHttpServer())
        .get('/<<Model kebab>>/count')
      <<for Fields searchable and not password and not hidden field>>
        .query(`<<field camel>>=${mock<<Model pascal>>.<<field camel>>}`)
      <<endfor>>
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.count).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.count).toHaveBeenCalledWith({
        where: {
        <<for Fields searchable and not password and not hidden field>>
          <<field camel>>: {
            <<if field enum>>hasSome<<elseif field manyMany>>some<<elseif field entity>>id<<else>>equals<<endif>>: <<if field manyMany>>{ id: { in: mock<<Model pascal>>.<<field camel>> } }<<elseif field number>>Number(mock<<Model pascal>>.<<field camel>>)<<elseif field boolean>>mock<<Model pascal>>.<<field camel>> === 'true'<<elseif field datetime>>new Date(mock<<Model pascal>>.<<field camel>> as string)<<elseif field object or multiple>>JSON.parse(mock<<Model pascal>>.<<field camel>> as string)<<else>>mock<<Model pascal>>.<<field camel>><<endif>>
          },
        <<endfor>>
        },
      });
    });
	
    <<if Fields ownership>>
    it('should get the <<Model camel>> count with casl abilities filter', async () => {
      const <<Model camel>> = mock<<Model pascal>>Factory();
  
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: <<Model camel>>.id });
      mockReqAbilities.mockReturnValue(build());
  
      await request(app.getHttpServer()).get('/<<Model kebab>>/count').expect(200);
  
      expect(mock<<Model pascal>>DatabaseService.count).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.count).toHaveBeenCalledWith({
        where: {
          AND: [
            {
              OR: [{ id: <<Model camel>>.id }],
            },
            {},
          ],
        },
      });
    });
	
    it('should get the <<Model camel>> count with casl abilities filter and with filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>CountQueryDtoFactory();
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());
	
      await request(app.getHttpServer())
        .get('/<<Model kebab>>/count')
      <<for Fields searchable and not password and not hidden field>>
        .query(`<<field camel>>=${mock<<Model pascal>>.<<field camel>>}`)
      <<endfor>>
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.count).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.count).toHaveBeenCalledWith({
        where: {
          AND: [
            {
              OR: [{ id: mock<<Model pascal>>.id }],
            },
            {
            <<for Fields searchable and not password and not hidden field>>
              <<field camel>>: {
                <<if field enum>>hasSome<<elseif field manyMany>>some<<elseif field entity>>id<<else>>equals<<endif>>: <<if field manyMany>>{ id: { in: mock<<Model pascal>>.<<field camel>> } }<<elseif field number>>Number(mock<<Model pascal>>.<<field camel>>)<<elseif field boolean>>mock<<Model pascal>>.<<field camel>> === 'true'<<elseif field datetime>>new Date(mock<<Model pascal>>.<<field camel>> as string)<<elseif field object or multiple>>JSON.parse(mock<<Model pascal>>.<<field camel>> as string)<<else>>mock<<Model pascal>>.<<field camel>><<endif>>
              },
            <<endfor>>
            },
          ],
        },
      });
    });
    <<endif>>
  });
	
  describe('GET /<<Model kebab>>/:id', () => {
    it('should return 404 if no <<Model camel>> found', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
	
      await request(app.getHttpServer())
        .get(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(404);
	
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledWith({
        where: {
          id: mock<<Model pascal>>.id,
        },
      });
    });
	
    it('should get the <<Model camel>>', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      await request(app.getHttpServer())
        .get(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledWith({
        where: {
          id: mock<<Model pascal>>.id,
        },
      });
    });
  
    <<if Fields ownership>>
    it('should get the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());
	
      await request(app.getHttpServer())
        .get(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
	
    it('should forbid the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: 'foo' });
      mockReqAbilities.mockReturnValue(build());
	
      await request(app.getHttpServer())
        .get(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(403);
	
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
    <<endif>>
  });
	
  describe('GET /<<Model kebab>>', () => {
    it('should get a list of <<Model pascal>>s and have default options', async () => {
      const mock<<Model pascal>>s = mock<<Model pascal>>sFactory({}, 5);
      mock<<Model pascal>>DatabaseService.findMany.mockResolvedValue(mock<<Model pascal>>s);
	
      const res = await request(app.getHttpServer()).get('/<<Model kebab>>').expect(200);
	
      expect(res.body.length).toEqual(mock<<Model pascal>>s.length);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledWith({
        orderBy: { id: 'asc' },
        take: 100,
      });
    });
	
    it('should get a list of <<Model pascal>>s and take a specific number them', async () => {
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
        .query('take=5')
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledWith({
        orderBy: { id: 'asc' },
        take: 5,
      });
    });
	
    it('should get a list of <<Model pascal>>s and skip a specific number them', async () => {
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
        .query('skip=5')
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledWith({
        orderBy: { id: 'asc' },
        skip: 5,
        take: 100,
      });
    });
	
    it('should get a list of <<Model pascal>>s and order by them', async () => {
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
        <<for Fields sortable field>>
        .query('sort[]=<<field camel>>')
        <<endfor>>
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledWith({
        orderBy: {
        <<for Fields sortable field>>
          <<field camel>>: 'asc',
        <<endfor>>
        },
        take: 100,
      });
    });
	
    it('should get a list of <<Model pascal>>s and order by them desc', async () => {
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
        <<for Fields sortable field>>
        .query('sort[]=<<field camel>>')
        <<endfor>>
        .query('order=desc')
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledWith({
        orderBy: {
        <<for Fields sortable field>>
          <<field camel>>: 'desc',
        <<endfor>>
        },
        take: 100,
      });
    });
	
    it('should get a list of <<Model pascal>>s and order by them desc', async () => {
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
        <<for Fields sortable field>>
        .query('sort[]=<<field camel>>:desc')
        <<endfor>>
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledWith({
        orderBy: {
        <<for Fields sortable field>>
          <<field camel>>: 'desc',
        <<endfor>>
        },
        take: 100,
      });
    });
	
    it('should get a list of <<Model pascal>>s and filter them with value', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>FindManyQueryDtoFactory();
	
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
      <<for Fields searchable and not password and not hidden field>>
        .query(`<<field camel>>=${mock<<Model pascal>>.<<field camel>>}`)
      <<endfor>>
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledWith({
        where: {
        <<for Fields searchable and not password and not hidden field>>
          <<field camel>>: {
            <<if field enum>>hasSome<<elseif field manyMany>>some<<elseif field entity>>id<<else>>equals<<endif>>: <<if field manyMany>>{ id: { in: mock<<Model pascal>>.<<field camel>> } }<<elseif field number>>Number(mock<<Model pascal>>.<<field camel>>)<<elseif field boolean>>mock<<Model pascal>>.<<field camel>> === 'true'<<elseif field datetime>>new Date(mock<<Model pascal>>.<<field camel>> as string)<<elseif field object or multiple>>JSON.parse(mock<<Model pascal>>.<<field camel>> as string)<<else>>mock<<Model pascal>>.<<field camel>><<endif>>
          },
        <<endfor>>
        },
        orderBy: { id: 'asc' },
        take: 100,
      });
    });
	
    it('should get a list of <<Model pascal>>s and combine all query params', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>FindManyQueryDtoFactory();
	
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
      <<for Fields searchable and not password and not hidden field>>
        .query(`<<field camel>>=${mock<<Model pascal>>.<<field camel>>}<<if field string>>:contains<<endif>>`)
      <<endfor>>
        .query('skip=5')
        .query('take=5')
        <<for Fields sortable field>>
        .query('sort[]=<<field camel>>:desc')
        <<endfor>>
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledWith({
        where: {
        <<for Fields searchable and not password and not hidden field>>
          <<field camel>>: {
            <<if field enum>>hasSome<<elseif field string>>contains<<elseif field manyMany>>some<<elseif field entity>>id<<else>>equals<<endif>>: <<if field manyMany>>{ id: { in: mock<<Model pascal>>.<<field camel>> } }<<elseif field number>>Number(mock<<Model pascal>>.<<field camel>>)<<elseif field boolean>>mock<<Model pascal>>.<<field camel>> === 'true'<<elseif field datetime>>new Date(mock<<Model pascal>>.<<field camel>> as string)<<elseif field object or multiple>>JSON.parse(mock<<Model pascal>>.<<field camel>> as string)<<else>>mock<<Model pascal>>.<<field camel>><<endif>>
          },
        <<endfor>>
        },
        skip: 5,
        take: 5,
        orderBy: {
        <<for Fields sortable field>>
          <<field camel>>: 'desc',
        <<endfor>>
        },
      });
    });
  
    <<if Fields ownership>>
    it('should get the <<Model camel>>s with casl abilities', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>FindManyQueryDtoFactory();
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());
	
      await request(app.getHttpServer()).get('/<<Model kebab>>').expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledWith({
        where: {
          AND: [
            {
              OR: [{ id: mock<<Model pascal>>.id }],
            },
            {},
          ],
        },
        take: 100,
        orderBy: { id: 'asc' },
      });
    });
	
    it('should get the <<Model camel>>s with casl abilities and with filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>FindManyQueryDtoFactory();
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.READ, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());
	
      await request(app.getHttpServer())
        .get('/<<Model kebab>>')
      <<for Fields searchable and not password and not hidden field>>
        .query(`<<field camel>>=${mock<<Model pascal>>.<<field camel>>}`)
      <<endfor>>
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findMany).toHaveBeenCalledWith({
        where: {
          AND: [
            {
              OR: [{ id: mock<<Model pascal>>.id }],
            },
            {
            <<for Fields searchable and not password and not hidden field>>
              <<field camel>>: {
                <<if field enum>>hasSome<<elseif field manyMany>>some<<elseif field entity>>id<<else>>equals<<endif>>: <<if field manyMany>>{ id: { in: mock<<Model pascal>>.<<field camel>> } }<<elseif field number>>Number(mock<<Model pascal>>.<<field camel>>)<<elseif field boolean>>mock<<Model pascal>>.<<field camel>> === 'true'<<elseif field datetime>>new Date(mock<<Model pascal>>.<<field camel>> as string)<<elseif field object or multiple>>JSON.parse(mock<<Model pascal>>.<<field camel>> as string)<<else>>mock<<Model pascal>>.<<field camel>><<endif>>
              },
            <<endfor>>
            },
          ],
        },
        take: 100,
        orderBy: { id: 'asc' },
      });
    });
    <<endif>>
  });
	
  describe('PATCH /<<Model kebab>>/:id', () => {
    it('should update a <<Model camel>>', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      const <<Model camel>>: <<Model pascal>>UpdateBodyDto = mock<<Model pascal>>UpdateBodyDtoFactory();
	
      await request(app.getHttpServer())
        .patch(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.update).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.update).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
        data: {
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { set: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
        },
      });
    });
	
    it('should return 404 if no <<Model camel>> found', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(null);
	
      const <<Model camel>>: <<Model pascal>>UpdateBodyDto = mock<<Model pascal>>UpdateBodyDtoFactory();
	
      await request(app.getHttpServer())
        .patch(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(404);
	
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
  
    <<if Fields ownership>>
    it('should update the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());
	
      const <<Model camel>>: <<Model pascal>>UpdateBodyDto = mock<<Model pascal>>UpdateBodyDtoFactory();
	
      await request(app.getHttpServer())
        .patch(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
	
    it('should forbid the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: 'foo' });
      mockReqAbilities.mockReturnValue(build());
	
      const <<Model camel>>: <<Model pascal>>UpdateBodyDto = mock<<Model pascal>>UpdateBodyDtoFactory();
	
      await request(app.getHttpServer())
        .patch(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(403);
	
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
    <<endif>>
  });
	
  describe('PUT /<<Model kebab>>(/:id)?', () => {
    it('should update a <<Model camel>> if <<Model camel>> id is not found in the database', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(null);
      
      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      can(Actions.CREATE, '<<Model pascal>>');
      mockReqAbilities.mockReturnValue(build());
      <<endif>>
	
      const <<Model camel>>: <<Model pascal>>UpsertBodyDto = mock<<Model pascal>>UpsertBodyDtoFactory();
	
      await request(app.getHttpServer())
        .put(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.upsert).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.upsert).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
        create: {
          <<for Fields not ownership and not primary and internal field>>
          <<field camel>>:<<< if (field.meta.default) { >>><<-field default raw>><<< } else { >>>
            <<if field datetime>>expect.any(Date)
            <<elseif field boolean>>false
            <<elseif field enum>><<Model pascal>><<field pascal>>["<<for1 field.enum e>><<e raw>><<endfor>>"]
            <<elseif field nullable>>null
            <<elseif field number>>0
            <<elseif field string>>''<<endif>>
          <<< } >>>,
          <<endfor>>
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
        update: {
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { set: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
        },
      });
    });
	
    it('should update a <<Model camel>> if <<Model camel>> id is found in the database', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      can(Actions.CREATE, '<<Model pascal>>');
      mockReqAbilities.mockReturnValue(build());
      <<endif>>
	
      const <<Model camel>>: <<Model pascal>>UpsertBodyDto = mock<<Model pascal>>UpsertBodyDtoFactory();
	
      await request(app.getHttpServer())
        .put(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .send(<<Model camel>>)
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.upsert).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.upsert).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
        create: {
          <<for Fields not ownership and not primary and internal field>>
          <<field camel>>:<<< if (field.meta.default) { >>><<-field default raw>><<< } else { >>>
            <<if field datetime>>expect.any(Date)
            <<elseif field boolean>>false
            <<elseif field enum>><<Model pascal>><<field pascal>>["<<for1 field.enum e>><<e raw>><<endfor>>"]
            <<elseif field nullable>>null
            <<elseif field number>>0
            <<elseif field string>>''<<endif>>
          <<< } >>>,
          <<endfor>>
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
        update: {
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { set: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
        },
      });
    });
	
    it('should create a <<Model camel>> if no id is provided', async () => {
      const { id } = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(null);
	
      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id });
      can(Actions.CREATE, '<<Model pascal>>');
      mockReqAbilities.mockReturnValue(build());
      <<endif>>
	
      const <<Model camel>>: <<Model pascal>>UpsertBodyDto = mock<<Model pascal>>UpsertBodyDtoFactory();
	
      await request(app.getHttpServer())
        .put(`/<<Model kebab>>`)
        .send(<<Model camel>>)
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.upsert).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.upsert).toHaveBeenCalledWith({
        where: { id: undefined },
        create: {
          <<for Fields not ownership and not primary and internal field>>
          <<field camel>>:<<< if (field.meta.default) { >>><<-field default raw>><<< } else { >>>
            <<if field datetime>>expect.any(Date)
            <<elseif field boolean>>false
            <<elseif field enum>><<Model pascal>><<field pascal>>["<<for1 field.enum e>><<e raw>><<endfor>>"]
            <<elseif field nullable>>null
            <<elseif field number>>0
            <<elseif field string>>''<<endif>>
          <<< } >>>,
          <<endfor>>
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
        update: {
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { set: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
        },
      });
    });
	
    it('should update a <<Model camel>> if an id is provided', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      <<if Fields ownership and not primary and internal>>
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      can(Actions.CREATE, '<<Model pascal>>');
      mockReqAbilities.mockReturnValue(build());
      <<endif>>
	
      const <<Model camel>>: <<Model pascal>>UpsertBodyDto = mock<<Model pascal>>UpsertBodyDtoFactory();
	
      await request(app.getHttpServer())
        .put(`/<<Model kebab>>`)
        .send({ ...<<Model camel>>, id: mock<<Model pascal>>.id })
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.upsert).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.upsert).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
        create: {
          <<for Fields not ownership and not primary and internal field>>
          <<field camel>>:<<< if (field.meta.default) { >>><<-field default raw>><<< } else { >>>
            <<if field datetime>>expect.any(Date)
            <<elseif field boolean>>false
            <<elseif field enum>><<Model pascal>><<field pascal>>["<<for1 field.enum e>><<e raw>><<endfor>>"]
            <<elseif field nullable>>null
            <<elseif field number>>0
            <<elseif field string>>''<<endif>>
          <<< } >>>,
          <<endfor>>
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { connect: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
          <<for Fields ownership and not primary and internal field>>
          <<field camel>>: { connect: mockUser }
          <<endfor>>
        },
        update: {
          <<for Fields not primary and not internal field>>
          <<if field oneOne or oneMany>>
          <<field camel>>: { connect: { id: <<Model camel>>.<<field camel>> } },
          <<elseif field manyMany>>
          <<field camel>>: { set: <<Model camel>>.<<field camel>>?.map((id) => ({ id })) },
          <<else>>
          <<field camel>>: <<Model camel>>.<<field camel>>,
          <<endif>>
          <<endfor>>
        },
      });
    });
  });
	
  describe('DELETE /<<Model kebab>>/:id', () => {
    it('should delete a <<Model camel>>', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      await request(app.getHttpServer())
        .delete(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.delete).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.delete).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
	
    it('should return 404 if no <<Model camel>> found', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(null);
	
      await request(app.getHttpServer())
        .delete(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(404);
	
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
  
    <<if Fields ownership>>
    it('should delete the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.REMOVE, '<<Model pascal>>', { id: mock<<Model pascal>>.id });
      mockReqAbilities.mockReturnValue(build());
	
      await request(app.getHttpServer())
        .delete(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(200);
	
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
	
    it('should forbid the <<Model camel>> with casl abilities filter', async () => {
      const mock<<Model pascal>> = mock<<Model pascal>>Factory();
      <<< if (root.names.pascal !== 'User') { >>>const mockUser = mockUserFactory();<<< }>>>
      mockReqUser.mockReturnValue(mockUser);
      mock<<Model pascal>>DatabaseService.findUnique.mockResolvedValue(mock<<Model pascal>>);
	
      const { can, build } = new AbilityBuilder(AppAbility);
      can(Actions.UPDATE, '<<Model pascal>>', { id: 'foo' });
      mockReqAbilities.mockReturnValue(build());
	
      await request(app.getHttpServer())
        .delete(`/<<Model kebab>>/${mock<<Model pascal>>.id}`)
        .expect(403);
	
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledTimes(1);
      expect(mock<<Model pascal>>DatabaseService.findUnique).toHaveBeenCalledWith({
        where: { id: mock<<Model pascal>>.id },
      });
    });
    <<endif>>
  });
});
