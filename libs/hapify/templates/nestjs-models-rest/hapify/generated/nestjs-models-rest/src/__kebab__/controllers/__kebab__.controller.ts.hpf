import {
  Body,
  Controller,
  Delete,
  Get,
  Inject,
  NotFoundException,
  Param,
  Patch,
  Post,
  Put,
  Query,
<<if Fields ownership>>
  Req,
<<endif>>
} from '@nestjs/common';
import { 
  CurrentAbilities, 
  Policies,
  <<if Model not noGuest>>
    Public,
  <<endif>>
} from '@tractr/nestjs-core';

import { <<if Fields ownership >><<<if (root.names.pascal !== 'User') {>>><<Model pascal>>, <<<}>>>User, <<endif>>Prisma } from '@prisma/client';
import { <<if Fields ownership >>Actions, AppAbility, <<endif>>Permission } from '../../../../casl';
import { <<Model pascal>>Service, <<Model constant>>_SERVICE } from '../../../../nestjs-models-common';
import {
  <<Model pascal>>CountQueryDto,
  <<Model pascal>>CreateBodyDto,
  <<Model pascal>>DeleteParamsDto,
  <<Model pascal>>FindManyQueryDto,
  <<Model pascal>>FindUniqueParamsDto,
<<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
  <<Model pascal>>FindUniqueQueryDto,
<<<}>>>
  <<Model pascal>>UpdateBodyDto,
  <<Model pascal>>UpdateParamsDto,
  <<Model pascal>>UpsertBodyDto,
  <<Model pascal>>UpsertParamsDto,
} from '../../../../rest-dtos';
import { <<Model constant>>_REST_DTO_SERVICE } from '../<<Model kebab>>-rest.constant';
import { <<Model pascal>>RestDtoService } from '../services';

<<if Fields ownership >>
import { accessibleBy } from '@casl/prisma';
import { ForbiddenError, subject } from '@casl/ability';
import { CurrentUser } from '@tractr/nestjs-authentication';
<<endif>>
 
@Controller(['<<Model kebab>>'])
export class <<Model pascal>>Controller {
  constructor(
    @Inject(<<Model constant>>_SERVICE)
    protected <<Model camel>>Service: <<Model pascal>>Service,
    @Inject(<<Model constant>>_REST_DTO_SERVICE)
    protected <<Model camel>>RestDtoService: <<Model pascal>>RestDtoService,
  ) {}
 
  /**
   * Create a new <<Model pascal>>
   *
   * @param bodyDto - Dto of the request body
   * @returns a new <<Model pascal>>
   */
  @Post()
  <<if CreateAccess guest>>
    @Public()
  <<endif>>
  @Policies(Permission.CREATE_<<Model constant>>)
  public create(
    @Body() bodyDto: <<Model pascal>>CreateBodyDto,
    <<if Fields ownership and not primary>>
    @CurrentUser() user: User,
    @CurrentAbilities() abilities: AppAbility,
    <<endif>>
  ) {
    <<if Fields ownership and not primary>>
    let<<else>>const<<endif>> formattedParams = this.<<Model camel>>RestDtoService.formatCreateDto(
      bodyDto
    );
    
    <<if Fields ownership and not primary>>
    formattedParams.data = {
      ...this.<<Model camel>>Service.getDefaultOwnerships(user),
      ...formattedParams.data,
    } as Prisma.<<Model pascal>>CreateInput;
 
    ForbiddenError.from(abilities).throwUnlessCan(
      Actions.CREATE,
      subject(
        '<<Model pascal>>',
        this.<<Model camel>>RestDtoService.transformCreateDtoTo<<Model pascal>>(
          bodyDto,
        ) as <<Model pascal>>,
      ),
    );
    <<endif>>

    return this.<<Model camel>>Service.create(formattedParams as Prisma.<<Model pascal>>CreateArgs);
  }
 
  /**
  * Count the number of <<Model pascal>> entities that matches the filter
  *
  * @param queryDto - Dto of the request query
  * @returns the number of <<Model pascal>>
  */
  @Get('count')
  <<if CountAccess guest>>
    @Public()
  <<endif>>
  @Policies(Permission.COUNT_<<Model constant>>)
  public async count(
    @Query() queryDto: <<Model pascal>>CountQueryDto,  
    <<if Fields ownership >>
    @CurrentAbilities() abilities: AppAbility,
    <<endif>>
  ): Promise<number> {
    let formattedParams = this.<<Model camel>>RestDtoService.formatCountDto(queryDto);
 
    <<if Fields ownership >>
    formattedParams = {
      ...formattedParams,
      where: {
        AND: [accessibleBy(abilities).<<Model pascal>>, formattedParams?.where ?? {}],
      },
    };
    <<endif>>
 
    return this.<<Model camel>>Service.count(formattedParams);
  }
 
  /**
   * Find zero or one <<Model pascal>> that matches the filter
   *
   * @param paramsDto - Dto of the request param
   * @param queryDto - Dto of the request query
   * @returns a <<Model pascal>> or null
   */
  @Get(':id')
  <<if ReadAccess guest>>
    @Public()
  <<endif>>
  @Policies(Permission.READ_<<Model constant>>)
  public async findUnique(
    @Param() paramsDto: <<Model pascal>>FindUniqueParamsDto,
    <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
    @Query() queryDto: <<Model pascal>>FindUniqueQueryDto,
    <<<}>>>
    <<if Fields ownership >>
    @CurrentAbilities() abilities: AppAbility,
    <<endif>>
  ) {
    const formattedParams = this.<<Model camel>>RestDtoService.formatFindUniqueDtos(
      paramsDto,
    <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
      queryDto,
    <<<}>>>
    );
 
    const <<Model camel>> = await this.<<Model camel>>Service.findUnique(formattedParams);
 
    if (!<<Model camel>>) throw new NotFoundException();
    <<if Fields ownership >>
 
    ForbiddenError.from(abilities).throwUnlessCan(
      Actions.READ,
      subject('<<Model pascal>>', <<Model camel>>),
    );
    <<endif>>
 
    return <<Model camel>>;
  }
 
  /**
   * Find zero or more <<Model pascal>> entities that matches the filter
   *
   * @param queryDto - Dto of the request query
   * @returns an array of <<Model pascal>> entities
   */
  @Get()
  <<if SearchAccess guest>>
    @Public()
  <<endif>>
  @Policies(Permission.SEARCH_<<Model constant>>)
  public findMany(
    @Query() queryDto: <<Model pascal>>FindManyQueryDto,
    <<if Fields ownership >>
    @CurrentAbilities() abilities: AppAbility,
    <<endif>>
  ) {
    let formattedParams = this.<<Model camel>>RestDtoService
      .formatFindManyDto(queryDto);
 
    <<if Fields ownership >>
    formattedParams = {
      ...formattedParams,
      where: {
        AND: [accessibleBy(abilities).<<Model pascal>>, formattedParams?.where ?? {}],
      },
    };
    <<endif>>
 
    return this.<<Model camel>>Service.findMany(formattedParams);
  }
 
  /**
   * Update one <<Model pascal>>
   *
   * @Remarks
   *
   * Partial updates are allowed with this method
   *
   * @param paramsDto - Dto of the request param
   * @param bodyDto - Dto of the request body
   * @returns the updated <<Model pascal>>
   */
  @Patch(':id')
  <<if UpdateAccess guest>>
    @Public()
  <<endif>>
  @Policies(Permission.UPDATE_<<Model constant>>)
  public async update(
    @Param() paramsDto: <<Model pascal>>UpdateParamsDto,
    @Body() bodyDto: <<Model pascal>>UpdateBodyDto,
    <<if Fields ownership >>
    @CurrentAbilities() abilities: AppAbility,
    <<endif>>
  ) {
    const <<Model camel>> = await this.<<Model camel>>Service.findUnique({
      where: {
        <<=root.fields.primary.names.camel>>: paramsDto.id,
      },
    });
 
    if (!<<Model camel>>) throw new NotFoundException();
 
    <<if Fields ownership >>
    ForbiddenError.from(abilities).throwUnlessCan(
      Actions.UPDATE,
      subject('<<Model pascal>>', <<Model camel>>),
    );
    <<endif>>
 
    const formattedParams = this.<<Model camel>>RestDtoService.formatUpdateDtos(
      paramsDto,
      bodyDto,
    );
 
    return this.<<Model camel>>Service.update(formattedParams);
  }
 
  /**
   * Update or create one <<Model pascal>>
   *
   * @Remarks
   *
   * Partial updates are forbidden with this method. It will
   * fully replace the matched entity
   *
   * @param paramsDto - Dto of the request param
   * @param bodyDto - Dto of the request body
   * @returns the updated <<Model pascal>>
   */
  @Put(':id')
  <<if CreateAccess guest>>
    <<if UpdateAccess guest>>
    @Public()
    <<endif>>
  <<endif>>
  @Policies(Permission.UPDATE_<<Model constant>>)
  public async upsert(
    @Param() paramsDto: <<Model pascal>>UpsertParamsDto,
    @Body() bodyDto: <<Model pascal>>UpsertBodyDto,
    <<if Fields internal and ownership and not primary>>
    @Req() { user }: { user: { id: string } },
    <<endif>>
    <<if Fields ownership >>
    @CurrentAbilities() abilities: AppAbility,
    <<endif>>
  ) {
    const <<Model camel>> = await this.<<Model camel>>Service.findUnique({
      where: {
        <<=root.fields.primary.names.camel>>: paramsDto.id,
      },
    });
 
    if (!<<Model camel>>) throw new NotFoundException();
 
    <<if Fields ownership >>
    ForbiddenError.from(abilities).throwUnlessCan(
      Actions.UPDATE,
      subject('<<Model pascal>>', <<Model camel>>),
    );
    <<endif>>
 
    const formattedParams = this.<<Model camel>>RestDtoService.formatUpsertDtos(
      paramsDto,
      bodyDto
    );
  
    <<for Fields internal and ownership and not primary field>>
    // Add <<field camel>> ownership
    formattedParams.create = this.<<Model camel>>Service.add<<field pascal>>OwnerShip(formattedParams.create, { id: user.id });
    <<endfor>>
 
    return this.<<Model camel>>Service.upsert(formattedParams as Prisma.<<Model pascal>>UpsertArgs);
  }
 
  /**
   * Delete one <<Model pascal>>
   *
   * @param paramsDto - Dto of the request param
   * @returns the updated <<Model pascal>>
   */
  @Delete(':id')
  <<if RemoveAccess guest>>
    @Public()
  <<endif>>
  @Policies(Permission.REMOVE_<<Model constant>>)
  public async delete(
    @Param() paramsDto: <<Model pascal>>DeleteParamsDto,
    <<if Fields ownership >>
    @CurrentAbilities() abilities: AppAbility,
    <<endif>>
  ) {
    const <<Model camel>> = await this.<<Model camel>>Service.findUnique({
      where: {
        <<=root.fields.primary.names.camel>>: paramsDto.id,
      },
    });
 
    if (!<<Model camel>>) throw new NotFoundException();
 
    <<if Fields ownership >>
    ForbiddenError.from(abilities).throwUnlessCan(
      Actions.REMOVE,
      subject('<<Model pascal>>', <<Model camel>>),
    );
    <<endif>>
 
    const formattedParams = this.<<Model camel>>RestDtoService.formatDeleteDto(paramsDto);
    return this.<<Model camel>>Service.delete(formattedParams);
  }
}
