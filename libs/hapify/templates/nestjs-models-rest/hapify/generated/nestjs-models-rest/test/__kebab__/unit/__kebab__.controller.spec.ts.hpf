/* eslint-disable @typescript-eslint/unbound-method */
import {
  mock<<Model pascal>>Factory,
} from '../../../../models/mock';
import {
  mock<<Model pascal>>ServiceFactory,
} from '../../../../nestjs-models-common/mock';
import {
  <<Model constant>>_SERVICE,
  <<Model pascal>>Service,
} from '../../../../nestjs-models-common';
import {
  mock<<Model pascal>>RestDtoServiceFactory,
} from '../../../mock';
import {
  <<Model constant>>_REST_DTO_SERVICE,
  <<Model pascal>>Controller,
  <<Model pascal>>RestDtoService,
} from '../../../src';
import {
  <<Model pascal>>CountQueryDto,
  <<Model pascal>>CreateBodyDto,
  <<Model pascal>>DeleteParamsDto,
  <<Model pascal>>FindManyQueryDto,
  <<Model pascal>>FindUniqueParamsDto,
<<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
  <<Model pascal>>FindUniqueQueryDto,
<<<}>>>
  <<Model pascal>>UpdateBodyDto,
  <<Model pascal>>UpdateParamsDto,
  <<Model pascal>>UpsertBodyDto,
  <<Model pascal>>UpsertParamsDto,
} from '../../../../rest-dtos';
import { Test, TestingModule } from '@nestjs/testing';
import { Prisma } from '@prisma/client';
  
describe('<<Model pascal>>Service', () => {
  let <<Model camel>>Controller: <<Model pascal>>Controller;
  let mocked<<Model pascal>>Service: <<Model pascal>>Service;
  let mocked<<Model pascal>>RestDtoService: <<Model pascal>>RestDtoService;
  
  beforeEach(async () => {
    mocked<<Model pascal>>Service = (mock<<Model pascal>>ServiceFactory() as unknown) as <<Model pascal>>Service;
    mocked<<Model pascal>>RestDtoService = (mock<<Model pascal>>RestDtoServiceFactory() as unknown) as <<Model pascal>>RestDtoService;
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        { provide: <<Model constant>>_SERVICE, useValue: mocked<<Model pascal>>Service },
        { provide: <<Model constant>>_REST_DTO_SERVICE, useValue: mocked<<Model pascal>>RestDtoService },
      ],
      controllers: [<<Model pascal>>Controller],
    }).compile();
    <<Model camel>>Controller = module.get< <<Model pascal>>Controller>(<<Model pascal>>Controller);
  });
  
  it('should be defined', () => {
    expect(<<Model camel>>Controller).toBeDefined();
  });
  
  describe('create', () => {
    it('should compose <<Model pascal>>RestDtoService.formatCreateDto and <<Model pascal>>DatabaseService.create', async () => {
      const bodyDto = ('body' as unknown) as <<Model pascal>>CreateBodyDto;
      const prismaArgs = ('args' as unknown) as Prisma.<<Model pascal>>CreateArgs;
      const <<Model camel>> = mock<<Model pascal>>Factory();
      (mocked<<Model pascal>>RestDtoService.formatCreateDto as jest.Mock).mockReturnValueOnce(
        prismaArgs
      );
      (mocked<<Model pascal>>Service.create as jest.Mock).mockReturnValueOnce(<<Model camel>>);
      // const result = await <<Model camel>>Controller.create(bodyDto);
      // expect(result).toEqual(<<Model camel>>);
      // expect(mocked<<Model pascal>>RestDtoService.formatCreateDto).toHaveBeenCalledTimes(1);
      // expect(mocked<<Model pascal>>RestDtoService.formatCreateDto).toHaveBeenCalledWith(
      //   bodyDto
      // );
      // expect(mocked<<Model pascal>>Service.create).toHaveBeenCalledTimes(1);
      // expect(mocked<<Model pascal>>Service.create).toHaveBeenCalledWith(prismaArgs);
    });
  });
  
  describe('findUnique', () => {
    it('should compose <<Model pascal>>RestDtoService.formatFindUniqueDtos and <<Model pascal>>DatabaseService.findUnique', async () => {
      const paramsDto = ('params' as unknown) as <<Model pascal>>FindUniqueParamsDto;
    <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
      const queryDto = ('query' as unknown) as <<Model pascal>>FindUniqueQueryDto;
    <<<}>>>
      const prismaArgs = ('args' as unknown) as Prisma.<<Model pascal>>FindUniqueArgs;
      const <<Model camel>> = mock<<Model pascal>>Factory();
      (mocked<<Model pascal>>RestDtoService.formatFindUniqueDtos as jest.Mock).mockReturnValueOnce(
        prismaArgs
      );
      (mocked<<Model pascal>>Service.findUnique as jest.Mock).mockReturnValueOnce(<<Model camel>>);
//       const result = await <<Model camel>>Controller.findUnique(
//         paramsDto,
//     <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
//         queryDto
//     <<<}>>>
//       );
//       expect(result).toEqual(<<Model camel>>);
//       expect(
//         mocked<<Model pascal>>RestDtoService.formatFindUniqueDtos
//       ).toHaveBeenCalledTimes(1);
//       expect(
//         mocked<<Model pascal>>RestDtoService.formatFindUniqueDtos
//       ).toHaveBeenCalledWith(
//         paramsDto, 
//     <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
//         queryDto
//     <<<}>>>
//       );
//       expect(mocked<<Model pascal>>Service.findUnique).toHaveBeenCalledTimes(1);
//       expect(mocked<<Model pascal>>Service.findUnique).toHaveBeenCalledWith(prismaArgs);
    });
  });
  
  describe('findMany', () => {
    it('should compose <<Model pascal>>RestDtoService.formatFindManyDto and <<Model pascal>>DatabaseService.findMany', async () => {
      const queryDto = ('query' as unknown) as <<Model pascal>>FindManyQueryDto;
      const prismaArgs = ('args' as unknown) as Prisma.<<Model pascal>>FindManyArgs;
      const <<Model camel>> = [...Array(3)].map(() => mock<<Model pascal>>Factory());
      (mocked<<Model pascal>>RestDtoService.formatFindManyDto as jest.Mock).mockReturnValueOnce(
        prismaArgs
      );
      (mocked<<Model pascal>>Service.findMany as jest.Mock).mockReturnValueOnce(<<Model camel>>);
//      const result = await <<Model camel>>Controller.findMany(queryDto);
//      expect(result).toEqual(<<Model camel>>);
//      expect(mocked<<Model pascal>>RestDtoService.formatFindManyDto).toHaveBeenCalledTimes(
//        1
//      );
//      expect(mocked<<Model pascal>>RestDtoService.formatFindManyDto).toHaveBeenCalledWith(
//        queryDto
//      );
//      expect(mocked<<Model pascal>>Service.findMany).toHaveBeenCalledTimes(1);
//      expect(mocked<<Model pascal>>Service.findMany).toHaveBeenCalledWith(prismaArgs);
    });
  });
  
  describe('count', () => {
    it('should compose <<Model pascal>>RestDtoService.formatCountDto and <<Model pascal>>DatabaseService.count', async () => {
      const queryDto = ('query' as unknown) as <<Model pascal>>CountQueryDto;
      const prismaArgs = ('args' as unknown) as Prisma.<<Model pascal>>CountArgs;
      const <<Model camel>> = 10;
      (mocked<<Model pascal>>RestDtoService.formatCountDto as jest.Mock).mockReturnValueOnce(
        prismaArgs
      );
      (mocked<<Model pascal>>Service.count as jest.Mock).mockReturnValueOnce(<<Model camel>>);
//      const result = await <<Model camel>>Controller.count(queryDto);
//      expect(result).toEqual(<<Model camel>>);
//      expect(mocked<<Model pascal>>RestDtoService.formatCountDto).toHaveBeenCalledTimes(1);
//      expect(mocked<<Model pascal>>RestDtoService.formatCountDto).toHaveBeenCalledWith(
//        queryDto
//      );
//      expect(mocked<<Model pascal>>Service.count).toHaveBeenCalledTimes(1);
//      expect(mocked<<Model pascal>>Service.count).toHaveBeenCalledWith(prismaArgs);
    });
  });
  
  describe('update', () => {
    it('should compose <<Model pascal>>RestDtoService.formatUpdateDtos and <<Model pascal>>DatabaseService.update', async () => {
      const paramsDto = ('params' as unknown) as <<Model pascal>>UpdateParamsDto;
      const bodyDto = ('body' as unknown) as <<Model pascal>>UpdateBodyDto;
      const prismaArgs = ('args' as unknown) as Prisma.<<Model pascal>>UpdateArgs;
      const <<Model camel>> = mock<<Model pascal>>Factory();
      (mocked<<Model pascal>>RestDtoService.formatUpdateDtos as jest.Mock).mockReturnValueOnce(
        prismaArgs
      );
      (mocked<<Model pascal>>Service.update as jest.Mock).mockReturnValueOnce(<<Model camel>>);
//      const result = await <<Model camel>>Controller.update(paramsDto, bodyDto);
//      expect(result).toEqual(<<Model camel>>);
//      expect(mocked<<Model pascal>>RestDtoService.formatUpdateDtos).toHaveBeenCalledTimes(
//        1
//      );
//      expect(mocked<<Model pascal>>RestDtoService.formatUpdateDtos).toHaveBeenCalledWith(
//        paramsDto,
//        bodyDto
//      );
//      expect(mocked<<Model pascal>>Service.update).toHaveBeenCalledTimes(1);
//      expect(mocked<<Model pascal>>Service.update).toHaveBeenCalledWith(prismaArgs);
    });
  });
  
  describe('upsert', () => {
    it('should compose <<Model pascal>>RestDtoService.formatUpsertDtos and <<Model pascal>>DatabaseService.upsert', async () => {
      const paramsDto = ('params' as unknown) as <<Model pascal>>UpsertParamsDto;
      const bodyDto = ('body' as unknown) as <<Model pascal>>UpsertBodyDto;
      const prismaArgs = ('args' as unknown) as Prisma.<<Model pascal>>UpsertArgs;
      const <<Model camel>> = mock<<Model pascal>>Factory();
      (mocked<<Model pascal>>RestDtoService.formatUpsertDtos as jest.Mock).mockReturnValueOnce(
        prismaArgs
      );
      (mocked<<Model pascal>>Service.upsert as jest.Mock).mockReturnValueOnce(<<Model camel>>);
//      const result = await <<Model camel>>Controller.upsert(paramsDto, bodyDto);
//      expect(result).toEqual(<<Model camel>>);
//      expect(mocked<<Model pascal>>RestDtoService.formatUpsertDtos).toHaveBeenCalledTimes(
//        1
//      );
//      expect(mocked<<Model pascal>>RestDtoService.formatUpsertDtos).toHaveBeenCalledWith(
//        paramsDto,
//        bodyDto
//      );
//      expect(mocked<<Model pascal>>Service.upsert).toHaveBeenCalledTimes(1);
//      expect(mocked<<Model pascal>>Service.upsert).toHaveBeenCalledWith(prismaArgs);
    });
  });
  
  describe('delete', () => {
    it('should compose <<Model pascal>>RestDtoService.formatDeleteDto and <<Model pascal>>DatabaseService.delete', async () => {
      const paramsDto = ('params' as unknown) as <<Model pascal>>DeleteParamsDto;
      const prismaArgs = ('args' as unknown) as Prisma.<<Model pascal>>DeleteArgs;
      const <<Model camel>> = mock<<Model pascal>>Factory();
      (mocked<<Model pascal>>RestDtoService.formatDeleteDto as jest.Mock).mockReturnValueOnce(
        prismaArgs
      );
      (mocked<<Model pascal>>Service.delete as jest.Mock).mockReturnValueOnce(<<Model camel>>);
//      const result = await <<Model camel>>Controller.delete(paramsDto);
//      expect(result).toEqual(<<Model camel>>);
//      expect(mocked<<Model pascal>>RestDtoService.formatDeleteDto).toHaveBeenCalledTimes(1);
//      expect(mocked<<Model pascal>>RestDtoService.formatDeleteDto).toHaveBeenCalledWith(
//        paramsDto
//      );
//      expect(mocked<<Model pascal>>Service.delete).toHaveBeenCalledTimes(1);
//      expect(mocked<<Model pascal>>Service.delete).toHaveBeenCalledWith(prismaArgs);
    });
  });
});
  
