/* eslint-disable  @typescript-eslint/no-explicit-any */
import { <<Model pascal>>RestModule, } from '@generated/<<Model kebab>>/rest';
import { Module, ValidationPipe } from '@nestjs/common';
import { CoreModule } from '@tractr/nestjs-core';
import { DatabaseModule } from '@tractr/nestjs-database';
import { createTestContext, TestContext } from '@tractr/nestjs-testing';
import request from 'supertest';
import {
  <<Model pascal>>,
  <<for Fields manyMany field>>
  <<field.model pascal>>
  <<endfor>>
} from '@prisma/client';
import { APP_PIPE } from '@nestjs/core';
 
@Module({
  imports: [
    <<Model pascal>>RestModule.register(),
    DatabaseModule,
    CoreModule,
  ],
  providers: [
    {
      provide: APP_PIPE,
      useValue: new ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
        transformOptions: {
          enableImplicitConversion: true,
        },
      }),
    },
  ],
})
class TestModule {};
  
const context = createTestContext(TestModule, {
  migrate: false,
  seed: false,
  prisma: false,
});
  
describe('Find <<Model lower>> (e2e)', () => {
   
<<for Fields searchable field>>
  it('should not accept payload with invalid <<field lower>>', () => {
    const { app } = context;
    const queryDto = { <<field camel>>: <<=getInvalidFieldValue(field)>> };
    return request(app.getHttpServer()).get('/<<Model kebab>>')
      .query(queryDto)
      .then(({status, body}) => {
        expect(status).toEqual(400);
      });
  })
    
<<endfor>>
});

<<<
function getInvalidTypeValue(f) {
  if (f.type === 'boolean') return `'invalid boolean'`;
  if (f.type === 'entity') return `'invalid uuid'`;
  if (f.subtype === 'enum') return `'invalid enum'`;
  if (f.subtype === 'email') return `'invalid@email'`;
  if (f.subtype === 'password') return `'invalidpassword'`;
  if (f.subtype === 'url') return `'https://invalidurl???'`;
  if (f.type === 'number') return `'invalid number'`;
  if (f.type === 'datetime') return `'invalid datetime'`;
  if (f.type === 'string') return `['invalid string']`;
}

function getInvalidFieldValue(f) {
  if (f.multiple) return `[...Array(3)].fill(${getInvalidTypeValue(f)})`;
  else return getInvalidTypeValue(f);
}
>>>
