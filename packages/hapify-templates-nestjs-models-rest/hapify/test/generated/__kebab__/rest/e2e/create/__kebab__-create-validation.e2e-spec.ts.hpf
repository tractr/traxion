import { mock<<Model pascal>>CreateBodyDtoFactory } from '@generated-mock/<<Model kebab>>/rest';
import { 
  <<Model pascal>>RestModule,
  <<Model pascal>>CreateBodyDto,
} from '@generated/<<Model kebab>>/rest';
import { Module, ValidationPipe } from '@nestjs/common';
import { CoreModule } from '@tractr/nestjs-core';
import { DatabaseModule } from '@tractr/nestjs-database';
import { createTestContext } from '@tractr/nestjs-testing';
import request from 'supertest';
<<if Fields entity>>
import {
  <<for Fields entity field>>
  <<field.model pascal>>,
  <<endfor>>
} from '@prisma/client';
<<endif>>
import { APP_PIPE } from '@nestjs/core';
 
@Module({
  imports: [
    <<Model pascal>>RestModule.register(),
    DatabaseModule,
    CoreModule,
  ],
  providers: [
    {
      provide: APP_PIPE,
      useValue: new ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
        transformOptions: {
          enableImplicitConversion: true,
        },
      }),
    },
  ],
})
class TestModule {};
  
const context = createTestContext(TestModule, {
  migrate: false,
  seed: false,
  prisma: false,
});
 
describe('Create a <<Model lower>> (e2e)', () => {

 
  describe('Payload validation', () => {
  <<for Fields not internal field>>
    it('should not accept payload with invalid <<field lower>>', async () => {
      const { app } = context;
      const bodyDto = mock<<Model pascal>>CreateBodyDtoFactory(({
        <<field camel>>: <<=getInvalidFieldValue(field)>>,
      } as unknown) as Partial < <<Model pascal>>CreateBodyDto>);
      return request(app.getHttpServer()).post('/<<Model kebab>>').send(bodyDto)
        .then(({status}) => {
          expect(status).toEqual(400);
        });
    })
      
  <<endfor>>
  });
});

<<<
function getInvalidTypeValue(f) {
  if (f.type === 'boolean') return `'invalid boolean'`;
  if (f.type === 'entity') return `'invalid uuid'`;
  if (f.subtype === 'enum') return `'invalid enum'`;
  if (f.subtype === 'email') return `'invalid@email'`;
  if (f.subtype === 'password') return `'invalidpassword'`;
  if (f.subtype === 'url') return `'https://invalidurl???'`;
  if (f.type === 'number') return `'invalid number'`;
  if (f.type === 'datetime') return `'invalid datetime'`;
  if (f.type === 'string') return `['invalid string']`;
}

function getInvalidFieldValue(f) {
  if (f.multiple) return `[...Array(3)].fill(${getInvalidTypeValue(f)})`;
  else return getInvalidTypeValue(f);
}
>>>


