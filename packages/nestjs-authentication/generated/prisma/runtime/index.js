var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __markAsModule2 = (target) => __defProp2(target, "__esModule", {value: true});
var __commonJS2 = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, {get: all[name], enumerable: true});
};
var __exportStar2 = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp2.call(target, key) && key !== "default")
        __defProp2(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule2 = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar2(__markAsModule2(__defProp2(module2 != null ? __create2(__getProtoOf2(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows2 = __commonJS2((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs2 = require("fs");
  function checkPathExt(path2, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path2, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path2, options);
  }
  function isexe(path2, options, cb) {
    fs2.stat(path2, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path2, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs2.statSync(path2), path2, options);
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode2 = __commonJS2((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs2 = require("fs");
  function isexe(path2, options, cb) {
    fs2.stat(path2, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs2.statSync(path2), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod2 = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
    return ret;
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe2 = __commonJS2((exports2, module2) => {
  var fs2 = require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows2();
  } else {
    core = require_mode2();
  }
  module2.exports = isexe;
  isexe.sync = sync;
  function isexe(path2, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path2, options || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core(path2, options || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path2, options) {
    try {
      return core.sync(path2, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which2 = __commonJS2((exports2, module2) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path2 = require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe2();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path2.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, {pathExt: pathExtExe});
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module2.exports = which;
  which.sync = whichSync;
});

// ../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key2 = __commonJS2((exports2, module2) => {
  "use strict";
  var pathKey = (options = {}) => {
    const environment = options.env || process.env;
    const platform = options.platform || process.platform;
    if (platform !== "win32") {
      return "PATH";
    }
    return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  };
  module2.exports = pathKey;
  module2.exports.default = pathKey;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  var which = require_which2();
  var getPathKey = require_path_key2();
  function resolveCommandAttempt(parsed, withoutPathExt) {
    const env = parsed.options.env || process.env;
    const cwd = process.cwd();
    const hasCustomCwd = parsed.options.cwd != null;
    const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
    if (shouldSwitchCwd) {
      try {
        process.chdir(parsed.options.cwd);
      } catch (err) {
      }
    }
    let resolved;
    try {
      resolved = which.sync(parsed.command, {
        path: env[getPathKey({env})],
        pathExt: withoutPathExt ? path2.delimiter : void 0
      });
    } catch (e) {
    } finally {
      if (shouldSwitchCwd) {
        process.chdir(cwd);
      }
    }
    if (resolved) {
      resolved = path2.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
    }
    return resolved;
  }
  function resolveCommand(parsed) {
    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
  }
  module2.exports = resolveCommand;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js
var require_escape2 = __commonJS2((exports2, module2) => {
  "use strict";
  var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
  function escapeCommand(arg) {
    arg = arg.replace(metaCharsRegExp, "^$1");
    return arg;
  }
  function escapeArgument(arg, doubleEscapeMetaChars) {
    arg = `${arg}`;
    arg = arg.replace(/(\\*)"/g, '$1$1\\"');
    arg = arg.replace(/(\\*)$/, "$1$1");
    arg = `"${arg}"`;
    arg = arg.replace(metaCharsRegExp, "^$1");
    if (doubleEscapeMetaChars) {
      arg = arg.replace(metaCharsRegExp, "^$1");
    }
    return arg;
  }
  module2.exports.command = escapeCommand;
  module2.exports.argument = escapeArgument;
});

// ../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = /^#!(.*)/;
});

// ../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command2 = __commonJS2((exports2, module2) => {
  "use strict";
  var shebangRegex = require_shebang_regex2();
  module2.exports = (string = "") => {
    const match = string.match(shebangRegex);
    if (!match) {
      return null;
    }
    const [path2, argument] = match[0].replace(/#! ?/, "").split(" ");
    const binary = path2.split("/").pop();
    if (binary === "env") {
      return argument;
    }
    return argument ? `${binary} ${argument}` : binary;
  };
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang2 = __commonJS2((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var shebangCommand = require_shebang_command2();
  function readShebang(command) {
    const size = 150;
    const buffer = Buffer.alloc(size);
    let fd;
    try {
      fd = fs2.openSync(command, "r");
      fs2.readSync(fd, buffer, 0, size, 0);
      fs2.closeSync(fd);
    } catch (e) {
    }
    return shebangCommand(buffer.toString());
  }
  module2.exports = readShebang;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js
var require_parse4 = __commonJS2((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  var resolveCommand = require_resolveCommand2();
  var escape = require_escape2();
  var readShebang = require_readShebang2();
  var isWin = process.platform === "win32";
  var isExecutableRegExp = /\.(?:com|exe)$/i;
  var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
  function detectShebang(parsed) {
    parsed.file = resolveCommand(parsed);
    const shebang = parsed.file && readShebang(parsed.file);
    if (shebang) {
      parsed.args.unshift(parsed.file);
      parsed.command = shebang;
      return resolveCommand(parsed);
    }
    return parsed.file;
  }
  function parseNonShell(parsed) {
    if (!isWin) {
      return parsed;
    }
    const commandFile = detectShebang(parsed);
    const needsShell = !isExecutableRegExp.test(commandFile);
    if (parsed.options.forceShell || needsShell) {
      const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
      parsed.command = path2.normalize(parsed.command);
      parsed.command = escape.command(parsed.command);
      parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
      parsed.command = process.env.comspec || "cmd.exe";
      parsed.options.windowsVerbatimArguments = true;
    }
    return parsed;
  }
  function parse2(command, args, options) {
    if (args && !Array.isArray(args)) {
      options = args;
      args = null;
    }
    args = args ? args.slice(0) : [];
    options = Object.assign({}, options);
    const parsed = {
      command,
      args,
      options,
      file: void 0,
      original: {
        command,
        args
      }
    };
    return options.shell ? parsed : parseNonShell(parsed);
  }
  module2.exports = parse2;
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js
var require_enoent2 = __commonJS2((exports2, module2) => {
  "use strict";
  var isWin = process.platform === "win32";
  function notFoundError(original, syscall) {
    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${syscall} ${original.command}`,
      path: original.command,
      spawnargs: original.args
    });
  }
  function hookChildProcess(cp, parsed) {
    if (!isWin) {
      return;
    }
    const originalEmit = cp.emit;
    cp.emit = function(name, arg1) {
      if (name === "exit") {
        const err = verifyENOENT(arg1, parsed, "spawn");
        if (err) {
          return originalEmit.call(cp, "error", err);
        }
      }
      return originalEmit.apply(cp, arguments);
    };
  }
  function verifyENOENT(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawn");
    }
    return null;
  }
  function verifyENOENTSync(status, parsed) {
    if (isWin && status === 1 && !parsed.file) {
      return notFoundError(parsed.original, "spawnSync");
    }
    return null;
  }
  module2.exports = {
    hookChildProcess,
    verifyENOENT,
    verifyENOENTSync,
    notFoundError
  };
});

// ../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js
var require_cross_spawn2 = __commonJS2((exports2, module2) => {
  "use strict";
  var cp = require("child_process");
  var parse2 = require_parse4();
  var enoent = require_enoent2();
  function spawn(command, args, options) {
    const parsed = parse2(command, args, options);
    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
    enoent.hookChildProcess(spawned, parsed);
    return spawned;
  }
  function spawnSync(command, args, options) {
    const parsed = parse2(command, args, options);
    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
    return result;
  }
  module2.exports = spawn;
  module2.exports.spawn = spawn;
  module2.exports.sync = spawnSync;
  module2.exports._parse = parse2;
  module2.exports._enoent = enoent;
});

// ../generator-helper/dist/byline.js
var require_byline = __commonJS2((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createLineStream = void 0;
  var stream = require("stream");
  var util = require("util");
  function byline(readStream, options) {
    return module2.exports.createStream(readStream, options);
  }
  exports2.default = byline;
  module2.exports.createStream = function(readStream, options) {
    if (readStream) {
      return createLineStream(readStream, options);
    } else {
      return new LineStream(options);
    }
  };
  function createLineStream(readStream, options) {
    if (!readStream) {
      throw new Error("expected readStream");
    }
    if (!readStream.readable) {
      throw new Error("readStream must be readable");
    }
    const ls = new LineStream(options);
    readStream.pipe(ls);
    return ls;
  }
  exports2.createLineStream = createLineStream;
  module2.exports.LineStream = LineStream;
  function LineStream(options) {
    stream.Transform.call(this, options);
    options = options || {};
    this._readableState.objectMode = true;
    this._lineBuffer = [];
    this._keepEmptyLines = options.keepEmptyLines || false;
    this._lastChunkEndedWithCR = false;
    this.on("pipe", function(src) {
      if (!this.encoding) {
        if (src instanceof stream.Readable) {
          this.encoding = src._readableState.encoding;
        }
      }
    });
  }
  util.inherits(LineStream, stream.Transform);
  LineStream.prototype._transform = function(chunk, encoding, done) {
    encoding = encoding || "utf8";
    if (Buffer.isBuffer(chunk)) {
      if (encoding == "buffer") {
        chunk = chunk.toString();
        encoding = "utf8";
      } else {
        chunk = chunk.toString(encoding);
      }
    }
    this._chunkEncoding = encoding;
    const lines = chunk.split(/\r\n|\r|\n/g);
    if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
      lines.shift();
    }
    if (this._lineBuffer.length > 0) {
      this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
      lines.shift();
    }
    this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
    this._lineBuffer = this._lineBuffer.concat(lines);
    this._pushBuffer(encoding, 1, done);
  };
  LineStream.prototype._pushBuffer = function(encoding, keep, done) {
    while (this._lineBuffer.length > keep) {
      const line = this._lineBuffer.shift();
      if (this._keepEmptyLines || line.length > 0) {
        if (!this.push(this._reencode(line, encoding))) {
          const self = this;
          setImmediate(function() {
            self._pushBuffer(encoding, keep, done);
          });
          return;
        }
      }
    }
    done();
  };
  LineStream.prototype._flush = function(done) {
    this._pushBuffer(this._chunkEncoding, 0, done);
  };
  LineStream.prototype._reencode = function(line, chunkEncoding) {
    if (this.encoding && this.encoding != chunkEncoding) {
      return Buffer.from(line, chunkEncoding).toString(this.encoding);
    } else if (this.encoding) {
      return line;
    } else {
      return Buffer.from(line, chunkEncoding);
    }
  };
});

// ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS2((exports2, module2) => {
  var cssKeywords = require_color_name2();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  module2.exports = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const {channels, labels} = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", {value: channels});
    Object.defineProperty(convert[model], "labels", {value: labels});
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min2 = Math.min(r, g, b);
    const max2 = Math.max(r, g, b);
    const delta = max2 - min2;
    let h;
    let s;
    if (max2 === min2) {
      h = 0;
    } else if (r === max2) {
      h = (g - b) / delta;
    } else if (g === max2) {
      h = 2 + (b - r) / delta;
    } else if (b === max2) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min2 + max2) / 2;
    if (max2 === min2) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max2 + min2);
    } else {
      s = delta / (2 - max2 - min2);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max2 = Math.max(Math.max(r, g), b);
    const min2 = Math.min(Math.min(r, g), b);
    const chroma = max2 - min2;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min2 / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max2 === r) {
      hue = (g - b) / chroma % 6;
    } else if (max2 === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route2 = __commonJS2((exports2, module2) => {
  var conversions = require_conversions2();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  }
  module2.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert2 = __commonJS2((exports2, module2) => {
  var conversions = require_conversions2();
  var route = require_route2();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert;
});

// ../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS2((exports2, module2) => {
  "use strict";
  var wrapAnsi16 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `[${code + offset}m`;
  };
  var wrapAnsi256 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `[${38 + offset};5;${code}m`;
  };
  var wrapAnsi16m = (fn, offset) => (...args) => {
    const rgb = fn(...args);
    return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  var ansi2ansi = (n) => n;
  var rgb2rgb = (r, g, b) => [r, g, b];
  var setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  var colorConvert;
  var makeDynamicStyles = (wrap, targetSpace, identity2, isBackground) => {
    if (colorConvert === void 0) {
      colorConvert = require_color_convert2();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name] = wrap(identity2, offset);
      } else if (typeof suite === "object") {
        styles[name] = wrap(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS2((exports2, module2) => {
  "use strict";
  var os = require("os");
  var tty = require("tty");
  var hasFlag = require_has_flag2();
  var {env} = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// ../../node_modules/.pnpm/chalk@4.1.0/node_modules/chalk/source/util.js
var require_util3 = __commonJS2((exports2, module2) => {
  "use strict";
  var stringReplaceAll = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  module2.exports = {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  };
});

// ../../node_modules/.pnpm/chalk@4.1.0/node_modules/chalk/source/templates.js
var require_templates2 = __commonJS2((exports2, module2) => {
  "use strict";
  var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk6, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk6;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  }
  module2.exports = (chalk6, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : buildStyle(chalk6, styles)(string));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk6, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
});

// ../../node_modules/.pnpm/chalk@4.1.0/node_modules/chalk/source/index.js
var require_source2 = __commonJS2((exports2, module2) => {
  "use strict";
  var ansiStyles = require_ansi_styles2();
  var {stdout: stdoutColor, stderr: stderrColor} = require_supports_color2();
  var {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = require_util3();
  var {isArray} = Array;
  var levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  var styles = Object.create(null);
  var applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  var ChalkClass = class {
    constructor(options) {
      return chalkFactory(options);
    }
  };
  var chalkFactory = (options) => {
    const chalk7 = {};
    applyOptions(chalk7, options);
    chalk7.template = (...arguments_) => chalkTag(chalk7.template, ...arguments_);
    Object.setPrototypeOf(chalk7, Chalk.prototype);
    Object.setPrototypeOf(chalk7.template, chalk7);
    chalk7.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk7.template.Instance = ChalkClass;
    return chalk7.template;
  };
  function Chalk(options) {
    return chalkFactory(options);
  }
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, {value: builder});
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", {value: builder});
      return builder;
    }
  };
  var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, {
    ...styles,
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  });
  var createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  var createBuilder = (self, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
        return applyStyle(builder, chalkTag(builder, ...arguments_));
      }
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    Object.setPrototypeOf(builder, proto);
    builder._generator = self;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  var applyStyle = (self, string) => {
    if (self.level <= 0 || !string) {
      return self._isEmpty ? "" : string;
    }
    let styler = self._styler;
    if (styler === void 0) {
      return string;
    }
    const {openAll, closeAll} = styler;
    if (string.indexOf("") !== -1) {
      while (styler !== void 0) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  var template;
  var chalkTag = (chalk7, ...strings) => {
    const [firstString] = strings;
    if (!isArray(firstString) || !isArray(firstString.raw)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1; i < firstString.length; i++) {
      parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    }
    if (template === void 0) {
      template = require_templates2();
    }
    return template(chalk7, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  var chalk6 = Chalk();
  chalk6.supportsColor = stdoutColor;
  chalk6.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
  chalk6.stderr.supportsColor = stderrColor;
  module2.exports = chalk6;
});

// ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms2 = __commonJS2((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// ../debug/dist/common.js
var require_common6 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.setup = void 0;
  function setup(env) {
    const createDebug = (namespace, logger3) => {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      const debug4 = (...args) => {
        const self = debug4;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self, args);
        if (logger3 && typeof logger3 === "function") {
          logger3.apply(self, args);
        }
        if (debug4.enabled) {
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
      };
      debug4.namespace = namespace;
      debug4.useColors = createDebug.useColors();
      debug4.color = createDebug.selectColor(namespace);
      debug4.extend = extend;
      debug4.destroy = createDebug.destroy;
      Object.defineProperty(debug4, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug4);
      }
      return debug4;
    };
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms2();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  exports2.setup = setup;
});

// ../debug/dist/node.js
var require_node3 = __commonJS2((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tty = require("tty");
  var util = require("util");
  exports2.init = init;
  exports2.log = log4;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require("supports-color");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log4(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug4) {
    debug4.inspectOpts = {};
    const keys2 = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys2.length; i++) {
      debug4.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
    }
  }
  var common_1 = require_common6();
  var mod2 = common_1.setup(exports2);
  module2.exports = mod2;
  exports2.default = mod2;
  var {formatters} = mod2;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// ../debug/dist/index.js
var require_dist7 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getLogs = exports2.Debug = void 0;
  var node_1 = __importDefault2(require_node3());
  var cache = [];
  var MAX_LOGS = 100;
  function Debug2(namespace) {
    const debug4 = node_1.default(namespace, (...args) => {
      cache.push(args);
      if (cache.length > MAX_LOGS) {
        cache.shift();
      }
    });
    return debug4;
  }
  exports2.default = Debug2;
  exports2.Debug = Debug2;
  Debug2.enable = (namespace) => {
    node_1.default.enable(namespace);
  };
  Debug2.enabled = (namespace) => node_1.default.enabled(namespace);
  function getLogs(numChars = 7500) {
    const output = cache.map((c) => c.map((item) => {
      if (typeof item === "string") {
        return item;
      }
      return JSON.stringify(item);
    }).join("  ")).join("\n");
    if (output.length < numChars) {
      return output;
    }
    return output.slice(-numChars);
  }
  exports2.getLogs = getLogs;
});

// ../generator-helper/dist/GeneratorProcess.js
var require_GeneratorProcess = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.GeneratorProcess = exports2.GeneratorError = void 0;
  var child_process_12 = require("child_process");
  var cross_spawn_1 = require_cross_spawn2();
  var byline_12 = __importDefault2(require_byline());
  var chalk_12 = __importDefault2(require_source2());
  var debug_12 = __importDefault2(require_dist7());
  var debug4 = debug_12.default("prisma:GeneratorProcess");
  var globalMessageId = 1;
  var GeneratorError = class extends Error {
    constructor(message, code, data) {
      super(message);
      this.code = code;
      this.data = data;
    }
  };
  exports2.GeneratorError = GeneratorError;
  var GeneratorProcess = class {
    constructor(executablePath, isNode) {
      this.executablePath = executablePath;
      this.isNode = isNode;
      this.listeners = {};
      this.exitCode = null;
      this.stderrLogs = "";
    }
    async init() {
      if (!this.initPromise) {
        this.initPromise = this.initSingleton();
      }
      return this.initPromise;
    }
    initSingleton() {
      return new Promise((resolve, reject) => {
        try {
          if (this.isNode) {
            this.child = child_process_12.fork(this.executablePath, [], {
              stdio: ["pipe", "inherit", "pipe", "ipc"],
              env: {
                ...process.env,
                PRISMA_GENERATOR_INVOCATION: "true"
              },
              execArgv: ["--max-old-space-size=8096"]
            });
          } else {
            this.child = cross_spawn_1.spawn(this.executablePath, {
              stdio: ["pipe", "inherit", "pipe"],
              env: {
                ...process.env,
                PRISMA_GENERATOR_INVOCATION: "true"
              },
              shell: true
            });
          }
          this.child.on("exit", (code) => {
            this.exitCode = code;
            if (code && code > 0 && this.currentGenerateDeferred) {
              this.currentGenerateDeferred.reject(new Error(this.stderrLogs.split("\n").slice(-5).join("\n")));
            }
          });
          this.child.on("error", (err) => {
            this.lastError = err;
            if (err.message.includes("EACCES")) {
              reject(new Error(`The executable at ${this.executablePath} lacks the right chmod. Please use ${chalk_12.default.bold(`chmod +x ${this.executablePath}`)}`));
            } else {
              reject(err);
            }
          });
          byline_12.default(this.child.stderr).on("data", (line) => {
            const response = String(line);
            this.stderrLogs += response + "\n";
            let data;
            try {
              data = JSON.parse(response);
            } catch (e) {
              debug4(response);
            }
            if (data) {
              this.handleResponse(data);
            }
          });
          setTimeout(() => {
            if (this.exitCode && this.exitCode > 0) {
              reject(new Error(`Generator at ${this.executablePath} could not start:

${this.stderrLogs}`));
            } else {
              resolve();
            }
          }, 200);
        } catch (e) {
          reject(e);
        }
      });
    }
    handleResponse(data) {
      if (data.jsonrpc && data.id) {
        if (typeof data.id !== "number") {
          throw new Error(`message.id has to be a number. Found value ${data.id}`);
        }
        if (this.listeners[data.id]) {
          if (data.error) {
            const error = new GeneratorError(data.error.message, data.error.code, data.error.data);
            this.listeners[data.id](null, error);
          } else {
            this.listeners[data.id](data.result);
          }
          delete this.listeners[data.id];
        }
      }
    }
    registerListener(messageId, cb) {
      this.listeners[messageId] = cb;
    }
    sendMessage(message) {
      this.child.stdin.write(JSON.stringify(message) + "\n");
    }
    getMessageId() {
      return globalMessageId++;
    }
    stop() {
      if (!this.child.killed) {
        this.child.kill();
      }
    }
    getManifest(config2) {
      return new Promise((resolve, reject) => {
        const messageId = this.getMessageId();
        this.registerListener(messageId, (result, error) => {
          if (error) {
            return reject(error);
          }
          if (result.manifest) {
            resolve(result.manifest);
          } else {
            resolve(null);
          }
        });
        this.sendMessage({
          jsonrpc: "2.0",
          method: "getManifest",
          params: config2,
          id: messageId
        });
      });
    }
    generate(options) {
      return new Promise((resolve, reject) => {
        const messageId = this.getMessageId();
        this.currentGenerateDeferred = {resolve, reject};
        this.registerListener(messageId, (result, error) => {
          if (error) {
            reject(error);
            this.currentGenerateDeferred = void 0;
            return;
          }
          resolve(result);
          this.currentGenerateDeferred = void 0;
        });
        this.sendMessage({
          jsonrpc: "2.0",
          method: "generate",
          params: options,
          id: messageId
        });
      });
    }
  };
  exports2.GeneratorProcess = GeneratorProcess;
});

// ../generator-helper/dist/generatorHandler.js
var require_generatorHandler = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.generatorHandler = void 0;
  var byline_12 = __importDefault2(require_byline());
  function generatorHandler(handler) {
    byline_12.default(process.stdin).on("data", async (line) => {
      const json = JSON.parse(String(line));
      if (json.method === "generate" && json.params) {
        try {
          const result = await handler.onGenerate(json.params);
          respond({
            jsonrpc: "2.0",
            result,
            id: json.id
          });
        } catch (e) {
          respond({
            jsonrpc: "2.0",
            error: {
              code: -32e3,
              message: e.stack || e.message,
              data: null
            },
            id: json.id
          });
        }
      }
      if (json.method === "getManifest") {
        if (handler.onManifest) {
          try {
            const manifest = handler.onManifest(json.params);
            respond({
              jsonrpc: "2.0",
              result: {
                manifest
              },
              id: json.id
            });
          } catch (e) {
            respond({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: e.stack || e.message,
                data: null
              },
              id: json.id
            });
          }
        } else {
          respond({
            jsonrpc: "2.0",
            result: {
              manifest: null
            },
            id: json.id
          });
        }
      }
    });
    process.stdin.resume();
  }
  exports2.generatorHandler = generatorHandler;
  function respond(response) {
    console.error(JSON.stringify(response));
  }
});

// ../generator-helper/dist/types.js
var require_types = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
});

// ../generator-helper/dist/dmmf.js
var require_dmmf = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DMMF = void 0;
  var DMMF2;
  (function(DMMF3) {
    let ModelAction;
    (function(ModelAction2) {
      ModelAction2["findUnique"] = "findUnique";
      ModelAction2["findFirst"] = "findFirst";
      ModelAction2["findMany"] = "findMany";
      ModelAction2["create"] = "create";
      ModelAction2["createMany"] = "createMany";
      ModelAction2["update"] = "update";
      ModelAction2["updateMany"] = "updateMany";
      ModelAction2["upsert"] = "upsert";
      ModelAction2["delete"] = "delete";
      ModelAction2["deleteMany"] = "deleteMany";
      ModelAction2["groupBy"] = "groupBy";
      ModelAction2["count"] = "count";
      ModelAction2["aggregate"] = "aggregate";
    })(ModelAction = DMMF3.ModelAction || (DMMF3.ModelAction = {}));
  })(DMMF2 = exports2.DMMF || (exports2.DMMF = {}));
});

// ../generator-helper/dist/index.js
var require_dist8 = __commonJS2((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar3 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.generatorHandler = exports2.GeneratorError = exports2.GeneratorProcess = void 0;
  var GeneratorProcess_1 = require_GeneratorProcess();
  Object.defineProperty(exports2, "GeneratorProcess", {enumerable: true, get: function() {
    return GeneratorProcess_1.GeneratorProcess;
  }});
  Object.defineProperty(exports2, "GeneratorError", {enumerable: true, get: function() {
    return GeneratorProcess_1.GeneratorError;
  }});
  var generatorHandler_1 = require_generatorHandler();
  Object.defineProperty(exports2, "generatorHandler", {enumerable: true, get: function() {
    return generatorHandler_1.generatorHandler;
  }});
  __exportStar3(require_types(), exports2);
  __exportStar3(require_dmmf(), exports2);
});

// ../../node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/util.js
var require_util4 = __commonJS2((exports2, module2) => {
  "use strict";
  var stringReplaceAll = (string, substring, replacer) => {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.substr(endIndex);
    return returnValue;
  };
  module2.exports = {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  };
});

// ../../node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/templates.js
var require_templates3 = __commonJS2((exports2, module2) => {
  "use strict";
  var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    if (u && bracket) {
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number)) {
        results.push(number);
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk6, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk6;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2)) {
        continue;
      }
      if (!(styleName in current)) {
        throw new Error(`Unknown Chalk style: ${styleName}`);
      }
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  }
  module2.exports = (chalk6, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter) {
        chunk.push(unescape(escapeCharacter));
      } else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : buildStyle(chalk6, styles)(string));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk6, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(character);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
});

// ../../node_modules/.pnpm/chalk@4.1.1/node_modules/chalk/source/index.js
var require_source3 = __commonJS2((exports2, module2) => {
  "use strict";
  var ansiStyles = require_ansi_styles2();
  var {stdout: stdoutColor, stderr: stderrColor} = require_supports_color2();
  var {
    stringReplaceAll,
    stringEncaseCRLFWithFirstIndex
  } = require_util4();
  var {isArray} = Array;
  var levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  var styles = Object.create(null);
  var applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  var ChalkClass = class {
    constructor(options) {
      return chalkFactory(options);
    }
  };
  var chalkFactory = (options) => {
    const chalk7 = {};
    applyOptions(chalk7, options);
    chalk7.template = (...arguments_) => chalkTag(chalk7.template, ...arguments_);
    Object.setPrototypeOf(chalk7, Chalk.prototype);
    Object.setPrototypeOf(chalk7.template, chalk7);
    chalk7.template.constructor = () => {
      throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
    };
    chalk7.template.Instance = ChalkClass;
    return chalk7.template;
  };
  function Chalk(options) {
    return chalkFactory(options);
  }
  for (const [styleName, style] of Object.entries(ansiStyles)) {
    styles[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
        Object.defineProperty(this, styleName, {value: builder});
        return builder;
      }
    };
  }
  styles.visible = {
    get() {
      const builder = createBuilder(this, this._styler, true);
      Object.defineProperty(this, "visible", {value: builder});
      return builder;
    }
  };
  var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
  for (const model of usedModels) {
    styles[model] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  for (const model of usedModels) {
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const {level} = this;
        return function(...arguments_) {
          const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
          return createBuilder(this, styler, this._isEmpty);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, {
    ...styles,
    level: {
      enumerable: true,
      get() {
        return this._generator.level;
      },
      set(level) {
        this._generator.level = level;
      }
    }
  });
  var createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  var createBuilder = (self, _styler, _isEmpty) => {
    const builder = (...arguments_) => {
      if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
        return applyStyle(builder, chalkTag(builder, ...arguments_));
      }
      return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    };
    Object.setPrototypeOf(builder, proto);
    builder._generator = self;
    builder._styler = _styler;
    builder._isEmpty = _isEmpty;
    return builder;
  };
  var applyStyle = (self, string) => {
    if (self.level <= 0 || !string) {
      return self._isEmpty ? "" : string;
    }
    let styler = self._styler;
    if (styler === void 0) {
      return string;
    }
    const {openAll, closeAll} = styler;
    if (string.indexOf("") !== -1) {
      while (styler !== void 0) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  var template;
  var chalkTag = (chalk7, ...strings) => {
    const [firstString] = strings;
    if (!isArray(firstString) || !isArray(firstString.raw)) {
      return strings.join(" ");
    }
    const arguments_ = strings.slice(1);
    const parts = [firstString.raw[0]];
    for (let i = 1; i < firstString.length; i++) {
      parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
    }
    if (template === void 0) {
      template = require_templates3();
    }
    return template(chalk7, parts.join(""));
  };
  Object.defineProperties(Chalk.prototype, styles);
  var chalk6 = Chalk();
  chalk6.supportsColor = stdoutColor;
  chalk6.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
  chalk6.stderr.supportsColor = stderrColor;
  module2.exports = chalk6;
});

// ../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js
var require_indent_string2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (string, count = 1, options) => {
    options = {
      indent: " ",
      includeEmptyLines: false,
      ...options
    };
    if (typeof string !== "string") {
      throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
    }
    if (typeof count !== "number") {
      throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
    }
    if (typeof options.indent !== "string") {
      throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
    }
    if (count === 0) {
      return string;
    }
    const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string.replace(regex, options.indent.repeat(count));
  };
});

// ../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js
var require_js_levenshtein = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = function() {
    function _min(d0, d1, d2, bx, ay) {
      return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;
    }
    return function(a, b) {
      if (a === b) {
        return 0;
      }
      if (a.length > b.length) {
        var tmp = a;
        a = b;
        b = tmp;
      }
      var la = a.length;
      var lb = b.length;
      while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
        la--;
        lb--;
      }
      var offset = 0;
      while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {
        offset++;
      }
      la -= offset;
      lb -= offset;
      if (la === 0 || lb < 3) {
        return lb;
      }
      var x = 0;
      var y;
      var d0;
      var d1;
      var d2;
      var d3;
      var dd;
      var dy;
      var ay;
      var bx0;
      var bx1;
      var bx2;
      var bx3;
      var vector = [];
      for (y = 0; y < la; y++) {
        vector.push(y + 1);
        vector.push(a.charCodeAt(offset + y));
      }
      var len = vector.length - 1;
      for (; x < lb - 3; ) {
        bx0 = b.charCodeAt(offset + (d0 = x));
        bx1 = b.charCodeAt(offset + (d1 = x + 1));
        bx2 = b.charCodeAt(offset + (d2 = x + 2));
        bx3 = b.charCodeAt(offset + (d3 = x + 3));
        dd = x += 4;
        for (y = 0; y < len; y += 2) {
          dy = vector[y];
          ay = vector[y + 1];
          d0 = _min(dy, d0, d1, bx0, ay);
          d1 = _min(d0, d1, d2, bx1, ay);
          d2 = _min(d1, d2, d3, bx2, ay);
          dd = _min(d2, d3, dd, bx3, ay);
          vector[y] = dd;
          d3 = d2;
          d2 = d1;
          d1 = d0;
          d0 = dy;
        }
      }
      for (; x < lb; ) {
        bx0 = b.charCodeAt(offset + (d0 = x));
        dd = ++x;
        for (y = 0; y < len; y += 2) {
          dy = vector[y];
          vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);
          d0 = dy;
        }
      }
      return dd;
    };
  }();
});

// ../../node_modules/.pnpm/ansi-regex@5.0.0/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = ({onlyFirst = false} = {}) => {
    const pattern = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
  };
});

// ../../node_modules/.pnpm/strip-ansi@6.0.0/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS2((exports2, module2) => {
  "use strict";
  var ansiRegex = require_ansi_regex();
  module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
});

// ../../node_modules/.pnpm/is-regexp@2.1.0/node_modules/is-regexp/index.js
var require_is_regexp = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (input) => Object.prototype.toString.call(input) === "[object RegExp]";
});

// ../../node_modules/.pnpm/is-obj@2.0.0/node_modules/is-obj/index.js
var require_is_obj = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (value) => {
    const type = typeof value;
    return value !== null && (type === "object" || type === "function");
  };
});

// ../../node_modules/.pnpm/get-own-enumerable-property-symbols@3.0.2/node_modules/get-own-enumerable-property-symbols/lib/index.js
var require_lib2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.default = (object) => Object.getOwnPropertySymbols(object).filter((keySymbol) => Object.prototype.propertyIsEnumerable.call(object, keySymbol));
});

// ../../node_modules/.pnpm/stacktrace-parser@0.1.10/node_modules/stacktrace-parser/dist/stack-trace-parser.cjs.js
var require_stack_trace_parser_cjs = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var UNKNOWN_FUNCTION = "<unknown>";
  function parse2(stackString) {
    var lines = stackString.split("\n");
    return lines.reduce(function(stack, line) {
      var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
      if (parseResult) {
        stack.push(parseResult);
      }
      return stack;
    }, []);
  }
  var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  function parseChrome(line) {
    var parts = chromeRe.exec(line);
    if (!parts) {
      return null;
    }
    var isNative = parts[2] && parts[2].indexOf("native") === 0;
    var isEval = parts[2] && parts[2].indexOf("eval") === 0;
    var submatch = chromeEvalRe.exec(parts[2]);
    if (isEval && submatch != null) {
      parts[2] = submatch[1];
      parts[3] = submatch[2];
      parts[4] = submatch[3];
    }
    return {
      file: !isNative ? parts[2] : null,
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: isNative ? [parts[2]] : [],
      lineNumber: parts[3] ? +parts[3] : null,
      column: parts[4] ? +parts[4] : null
    };
  }
  var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function parseWinjs(line) {
    var parts = winjsRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }
  var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  function parseGecko(line) {
    var parts = geckoRe.exec(line);
    if (!parts) {
      return null;
    }
    var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
    var submatch = geckoEvalRe.exec(parts[3]);
    if (isEval && submatch != null) {
      parts[3] = submatch[1];
      parts[4] = submatch[2];
      parts[5] = null;
    }
    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: parts[2] ? parts[2].split(",") : [],
      lineNumber: parts[4] ? +parts[4] : null,
      column: parts[5] ? +parts[5] : null
    };
  }
  var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  function parseJSC(line) {
    var parts = javaScriptCoreRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[4],
      column: parts[5] ? +parts[5] : null
    };
  }
  var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function parseNode(line) {
    var parts = nodeRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }
  exports2.parse = parse2;
});

// ../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js
var require_min_indent = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (string) => {
    const match = string.match(/^[ \t]*(?=\S)/gm);
    if (!match) {
      return 0;
    }
    return match.reduce((r, a) => Math.min(r, a.length), Infinity);
  };
});

// ../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js
var require_strip_indent = __commonJS2((exports2, module2) => {
  "use strict";
  var minIndent = require_min_indent();
  module2.exports = (string) => {
    const indent3 = minIndent(string);
    if (indent3 === 0) {
      return string;
    }
    const regex = new RegExp(`^[ \\t]{${indent3}}`, "gm");
    return string.replace(regex, "");
  };
});

// ../engine-core/dist/log.js
var require_log2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.convertLog = exports2.isRustError = exports2.isRustErrorLog = exports2.isRustLog = exports2.getBacktraceFromRustError = exports2.getBacktraceFromLog = exports2.getMessage = void 0;
  function getMessage(log4) {
    if (typeof log4 === "string") {
      return log4;
    } else if (isRustError(log4)) {
      return getBacktraceFromRustError(log4);
    } else if (isRustLog(log4)) {
      return getBacktraceFromLog(log4);
    }
    return JSON.stringify(log4);
  }
  exports2.getMessage = getMessage;
  function getBacktraceFromLog(log4) {
    var _a, _b, _c, _d, _e, _f, _g;
    if ((_a = log4.fields) === null || _a === void 0 ? void 0 : _a.message) {
      let str = (_b = log4.fields) === null || _b === void 0 ? void 0 : _b.message;
      if ((_c = log4.fields) === null || _c === void 0 ? void 0 : _c.file) {
        str += ` in ${log4.fields.file}`;
        if ((_d = log4.fields) === null || _d === void 0 ? void 0 : _d.line) {
          str += `:${log4.fields.line}`;
        }
        if ((_e = log4.fields) === null || _e === void 0 ? void 0 : _e.column) {
          str += `:${log4.fields.column}`;
        }
      }
      if ((_f = log4.fields) === null || _f === void 0 ? void 0 : _f.reason) {
        str += `
${(_g = log4.fields) === null || _g === void 0 ? void 0 : _g.reason}`;
      }
      return str;
    }
    return "Unknown error";
  }
  exports2.getBacktraceFromLog = getBacktraceFromLog;
  function getBacktraceFromRustError(err) {
    let str = "";
    if (err.is_panic) {
      str += `PANIC`;
    }
    if (err.backtrace) {
      str += ` in ${err.backtrace}`;
    }
    if (err.message) {
      str += `
${err.message}`;
    }
    return str;
  }
  exports2.getBacktraceFromRustError = getBacktraceFromRustError;
  function isRustLog(e) {
    return e.timestamp && typeof e.level === "string" && typeof e.target === "string";
  }
  exports2.isRustLog = isRustLog;
  function isRustErrorLog(e) {
    var _a, _b;
    return isRustLog(e) && (e.level === "error" || ((_b = (_a = e.fields) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes("fatal error")));
  }
  exports2.isRustErrorLog = isRustErrorLog;
  function isRustError(e) {
    return typeof e.is_panic !== "undefined";
  }
  exports2.isRustError = isRustError;
  function convertLog(rustLog) {
    const isQuery = isQueryLog(rustLog.fields);
    const level = isQuery ? "query" : rustLog.level.toLowerCase();
    return {
      ...rustLog,
      level,
      timestamp: new Date(new Date().getFullYear() + " " + rustLog.timestamp)
    };
  }
  exports2.convertLog = convertLog;
  function isQueryLog(fields) {
    return Boolean(fields.query);
  }
});

// ../../node_modules/.pnpm/ansi-escapes@4.3.2/node_modules/ansi-escapes/index.js
var require_ansi_escapes = __commonJS2((exports2, module2) => {
  "use strict";
  var ansiEscapes = module2.exports;
  module2.exports.default = ansiEscapes;
  var ESC = "[";
  var OSC = "]";
  var BEL = "\x07";
  var SEP = ";";
  var isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
  ansiEscapes.cursorTo = (x, y) => {
    if (typeof x !== "number") {
      throw new TypeError("The `x` argument is required");
    }
    if (typeof y !== "number") {
      return ESC + (x + 1) + "G";
    }
    return ESC + (y + 1) + ";" + (x + 1) + "H";
  };
  ansiEscapes.cursorMove = (x, y) => {
    if (typeof x !== "number") {
      throw new TypeError("The `x` argument is required");
    }
    let ret = "";
    if (x < 0) {
      ret += ESC + -x + "D";
    } else if (x > 0) {
      ret += ESC + x + "C";
    }
    if (y < 0) {
      ret += ESC + -y + "A";
    } else if (y > 0) {
      ret += ESC + y + "B";
    }
    return ret;
  };
  ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
  ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
  ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
  ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
  ansiEscapes.cursorLeft = ESC + "G";
  ansiEscapes.cursorSavePosition = isTerminalApp ? "7" : ESC + "s";
  ansiEscapes.cursorRestorePosition = isTerminalApp ? "8" : ESC + "u";
  ansiEscapes.cursorGetPosition = ESC + "6n";
  ansiEscapes.cursorNextLine = ESC + "E";
  ansiEscapes.cursorPrevLine = ESC + "F";
  ansiEscapes.cursorHide = ESC + "?25l";
  ansiEscapes.cursorShow = ESC + "?25h";
  ansiEscapes.eraseLines = (count) => {
    let clear = "";
    for (let i = 0; i < count; i++) {
      clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
    }
    if (count) {
      clear += ansiEscapes.cursorLeft;
    }
    return clear;
  };
  ansiEscapes.eraseEndLine = ESC + "K";
  ansiEscapes.eraseStartLine = ESC + "1K";
  ansiEscapes.eraseLine = ESC + "2K";
  ansiEscapes.eraseDown = ESC + "J";
  ansiEscapes.eraseUp = ESC + "1J";
  ansiEscapes.eraseScreen = ESC + "2J";
  ansiEscapes.scrollUp = ESC + "S";
  ansiEscapes.scrollDown = ESC + "T";
  ansiEscapes.clearScreen = "c";
  ansiEscapes.clearTerminal = process.platform === "win32" ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
  ansiEscapes.beep = BEL;
  ansiEscapes.link = (text, url) => {
    return [
      OSC,
      "8",
      SEP,
      SEP,
      url,
      BEL,
      text,
      OSC,
      "8",
      SEP,
      SEP,
      BEL
    ].join("");
  };
  ansiEscapes.image = (buffer, options = {}) => {
    let ret = `${OSC}1337;File=inline=1`;
    if (options.width) {
      ret += `;width=${options.width}`;
    }
    if (options.height) {
      ret += `;height=${options.height}`;
    }
    if (options.preserveAspectRatio === false) {
      ret += ";preserveAspectRatio=0";
    }
    return ret + ":" + buffer.toString("base64") + BEL;
  };
  ansiEscapes.iTerm = {
    setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
    annotation: (message, options = {}) => {
      let ret = `${OSC}1337;`;
      const hasX = typeof options.x !== "undefined";
      const hasY = typeof options.y !== "undefined";
      if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== "undefined")) {
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      }
      message = message.replace(/\|/g, "");
      ret += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
      if (options.length > 0) {
        ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
      } else {
        ret += message;
      }
      return ret + BEL;
    }
  };
});

// ../../node_modules/.pnpm/supports-hyperlinks@2.2.0/node_modules/supports-hyperlinks/index.js
var require_supports_hyperlinks = __commonJS2((exports2, module2) => {
  "use strict";
  var supportsColor = require_supports_color2();
  var hasFlag = require_has_flag2();
  function parseVersion(versionString) {
    if (/^\d{3,4}$/.test(versionString)) {
      const m = /(\d{1,2})(\d{2})/.exec(versionString);
      return {
        major: 0,
        minor: parseInt(m[1], 10),
        patch: parseInt(m[2], 10)
      };
    }
    const versions = (versionString || "").split(".").map((n) => parseInt(n, 10));
    return {
      major: versions[0],
      minor: versions[1],
      patch: versions[2]
    };
  }
  function supportsHyperlink(stream) {
    const {env} = process;
    if ("FORCE_HYPERLINK" in env) {
      return !(env.FORCE_HYPERLINK.length > 0 && parseInt(env.FORCE_HYPERLINK, 10) === 0);
    }
    if (hasFlag("no-hyperlink") || hasFlag("no-hyperlinks") || hasFlag("hyperlink=false") || hasFlag("hyperlink=never")) {
      return false;
    }
    if (hasFlag("hyperlink=true") || hasFlag("hyperlink=always")) {
      return true;
    }
    if (!supportsColor.supportsColor(stream)) {
      return false;
    }
    if (stream && !stream.isTTY) {
      return false;
    }
    if (process.platform === "win32") {
      return false;
    }
    if ("NETLIFY" in env) {
      return true;
    }
    if ("CI" in env) {
      return false;
    }
    if ("TEAMCITY_VERSION" in env) {
      return false;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseVersion(env.TERM_PROGRAM_VERSION);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          if (version.major === 3) {
            return version.minor >= 1;
          }
          return version.major > 3;
      }
    }
    if ("VTE_VERSION" in env) {
      if (env.VTE_VERSION === "0.50.0") {
        return false;
      }
      const version = parseVersion(env.VTE_VERSION);
      return version.major > 0 || version.minor >= 50;
    }
    return false;
  }
  module2.exports = {
    supportsHyperlink,
    stdout: supportsHyperlink(process.stdout),
    stderr: supportsHyperlink(process.stderr)
  };
});

// ../../node_modules/.pnpm/terminal-link@2.1.1/node_modules/terminal-link/index.js
var require_terminal_link = __commonJS2((exports2, module2) => {
  "use strict";
  var ansiEscapes = require_ansi_escapes();
  var supportsHyperlinks = require_supports_hyperlinks();
  var terminalLink = (text, url, {target = "stdout", ...options} = {}) => {
    if (!supportsHyperlinks[target]) {
      if (options.fallback === false) {
        return text;
      }
      return typeof options.fallback === "function" ? options.fallback(text, url) : `${text} (\u200B${url}\u200B)`;
    }
    return ansiEscapes.link(text, url);
  };
  module2.exports = (text, url, options = {}) => terminalLink(text, url, options);
  module2.exports.stderr = (text, url, options = {}) => terminalLink(text, url, {target: "stderr", ...options});
  module2.exports.isSupported = supportsHyperlinks.stdout;
  module2.exports.stderr.isSupported = supportsHyperlinks.stderr;
});

// ../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js
var require_new_github_issue_url = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (options = {}) => {
    let repoUrl;
    if (options.repoUrl) {
      repoUrl = options.repoUrl;
    } else if (options.user && options.repo) {
      repoUrl = `https://github.com/${options.user}/${options.repo}`;
    } else {
      throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
    }
    const url = new URL(`${repoUrl}/issues/new`);
    const types = [
      "body",
      "title",
      "labels",
      "template",
      "milestone",
      "assignee",
      "projects"
    ];
    for (const type of types) {
      let value = options[type];
      if (value === void 0) {
        continue;
      }
      if (type === "labels" || type === "projects") {
        if (!Array.isArray(value)) {
          throw new TypeError(`The \`${type}\` option should be an array`);
        }
        value = value.join(",");
      }
      url.searchParams.set(type, value);
    }
    return url.toString();
  };
  module2.exports.default = module2.exports;
});

// ../engine-core/dist/util.js
var require_util5 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getRandomString = exports2.getGithubIssueUrl = exports2.link = exports2.fixBinaryTargets = exports2.plusX = void 0;
  var fs_12 = __importDefault2(require("fs"));
  var terminal_link_1 = __importDefault2(require_terminal_link());
  var new_github_issue_url_1 = __importDefault2(require_new_github_issue_url());
  var chalk_12 = __importDefault2(require_source2());
  var debug_12 = __importDefault2(require_dist7());
  var crypto_1 = __importDefault2(require("crypto"));
  var debug4 = debug_12.default("plusX");
  function plusX(file) {
    const s = fs_12.default.statSync(file);
    const newMode = s.mode | 64 | 8 | 1;
    if (s.mode === newMode) {
      debug4(`Execution permissions of ${file} are fine`);
      return;
    }
    const base8 = newMode.toString(8).slice(-3);
    debug4(`Have to call plusX on ${file}`);
    fs_12.default.chmodSync(file, base8);
  }
  exports2.plusX = plusX;
  function fixBinaryTargets(platforms, platform) {
    platforms = platforms || [];
    if (!platforms.includes("native")) {
      return ["native", ...platforms];
    }
    return [...platforms, platform];
  }
  exports2.fixBinaryTargets = fixBinaryTargets;
  function link(url) {
    return terminal_link_1.default(url, url, {
      fallback: (url2) => chalk_12.default.underline(url2)
    });
  }
  exports2.link = link;
  function getGithubIssueUrl({title, user = "prisma", repo = "prisma", template = "bug_report.md", body}) {
    return new_github_issue_url_1.default({
      user,
      repo,
      template,
      title,
      body
    });
  }
  exports2.getGithubIssueUrl = getGithubIssueUrl;
  function getRandomString() {
    return crypto_1.default.randomBytes(12).toString("hex");
  }
  exports2.getRandomString = getRandomString;
});

// ../engine-core/dist/maskQuery.js
var require_maskQuery = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.maskQuery = void 0;
  function maskQuery(query) {
    if (!query) {
      return "";
    }
    return query.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (substr) => {
      return `${substr[0]}5`;
    });
  }
  exports2.maskQuery = maskQuery;
});

// ../engine-core/dist/errors.js
var require_errors = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getErrorMessageWithLink = exports2.PrismaClientInitializationError = exports2.PrismaClientRustError = exports2.PrismaClientRustPanicError = exports2.PrismaClientUnknownRequestError = exports2.PrismaClientKnownRequestError = void 0;
  var log_12 = require_log2();
  var debug_12 = require_dist7();
  var util_12 = require_util5();
  var strip_ansi_1 = __importDefault2(require_strip_ansi());
  var maskQuery_1 = require_maskQuery();
  var PrismaClientKnownRequestError2 = class extends Error {
    constructor(message, code, clientVersion2, meta) {
      super(message);
      this.code = code;
      this.clientVersion = clientVersion2;
      this.meta = meta;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  exports2.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  var PrismaClientUnknownRequestError2 = class extends Error {
    constructor(message, clientVersion2) {
      super(message);
      this.clientVersion = clientVersion2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  exports2.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  var PrismaClientRustPanicError2 = class extends Error {
    constructor(message, clientVersion2) {
      super(message);
      this.clientVersion = clientVersion2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  exports2.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  var PrismaClientRustError = class extends Error {
    constructor({clientVersion: clientVersion2, log: log4, error}) {
      if (log4) {
        const backtrace = log_12.getBacktraceFromLog(log4);
        super(backtrace !== null && backtrace !== void 0 ? backtrace : "Unkown error");
      } else if (error) {
        const backtrace = log_12.getBacktraceFromRustError(error);
        super(backtrace);
      } else {
        super(`Unknown error`);
      }
      this.clientVersion = clientVersion2;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  exports2.PrismaClientRustError = PrismaClientRustError;
  var PrismaClientInitializationError2 = class extends Error {
    constructor(message, clientVersion2, errorCode) {
      super(message);
      this.clientVersion = clientVersion2;
      this.errorCode = errorCode;
      Error.captureStackTrace(PrismaClientInitializationError2);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  exports2.PrismaClientInitializationError = PrismaClientInitializationError2;
  function getErrorMessageWithLink({version, platform, title, description, engineVersion, database, query}) {
    var _a, _b;
    const gotLogs = debug_12.getLogs(6e3 - ((_a = query === null || query === void 0 ? void 0 : query.length) !== null && _a !== void 0 ? _a : 0));
    const logs = normalizeLogs(strip_ansi_1.default(gotLogs));
    const moreInfo = description ? `# Description
\`\`\`
${description}
\`\`\`` : "";
    const body = strip_ansi_1.default(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${(_b = process.version) === null || _b === void 0 ? void 0 : _b.padEnd(19)}| 
| OS              | ${platform === null || platform === void 0 ? void 0 : platform.padEnd(19)}|
| Prisma Client   | ${version === null || version === void 0 ? void 0 : version.padEnd(19)}|
| Query Engine    | ${engineVersion === null || engineVersion === void 0 ? void 0 : engineVersion.padEnd(19)}|
| Database        | ${database === null || database === void 0 ? void 0 : database.padEnd(19)}|

${moreInfo}

## Query
\`\`\`
${query ? maskQuery_1.maskQuery(query) : ""}
\`\`\`

## Logs
\`\`\`
${logs}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`
`);
    const url = util_12.getGithubIssueUrl({title, body});
    return `${title}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${util_12.link(url)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  }
  exports2.getErrorMessageWithLink = getErrorMessageWithLink;
  function normalizeLogs(logs) {
    return logs.split("\n").map((l) => {
      return l.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "");
    }).join("\n");
  }
});

// ../../node_modules/.pnpm/@prisma/engines@2.22.0-21.60cc71d884972ab4e897f0277c4b84383dddaf6c/node_modules/@prisma/engines/dist/index.js
var require_dist9 = __commonJS2((exports, module) => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module2) => () => {
    if (!module2) {
      module2 = {exports: {}};
      callback(module2.exports, module2);
    }
    return module2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, {get: all[name], enumerable: true});
  };
  var __exportStar = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule = (module2) => {
    if (module2 && module2.__esModule)
      return module2;
    return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
  };
  var require_has_flag = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  });
  var require_supports_color = __commonJS((exports2, module2) => {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var {env} = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min2 = forceColor || 0;
      if (env.TERM === "dumb") {
        return min2;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min2;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min2;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  });
  var require_ms = __commonJS((exports2, module2) => {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  });
  var require_common = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.setup = void 0;
    function setup(env) {
      const createDebug = (namespace, logger3) => {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        const debug32 = (...args) => {
          const self = debug32;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          if (logger3 && typeof logger3 === "function") {
            logger3.apply(self, args);
          }
          if (debug32.enabled) {
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }
        };
        debug32.namespace = namespace;
        debug32.useColors = createDebug.useColors();
        debug32.color = createDebug.selectColor(namespace);
        debug32.extend = extend;
        debug32.destroy = createDebug.destroy;
        Object.defineProperty(debug32, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug32);
        }
        return debug32;
      };
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    exports2.setup = setup;
  });
  var require_node = __commonJS((exports2, module2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log4;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const {namespace: name, useColors: useColors2} = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log4(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug32) {
      debug32.inspectOpts = {};
      const keys2 = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug32.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
      }
    }
    var common_1 = require_common();
    var mod2 = common_1.setup(exports2);
    module2.exports = mod2;
    exports2.default = mod2;
    var {formatters} = mod2;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  });
  var require_dist = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getLogs = exports2.Debug = void 0;
    var node_1 = __importDefault2(require_node());
    var cache = [];
    var MAX_LOGS = 100;
    function Debug2(namespace) {
      const debug32 = node_1.default(namespace, (...args) => {
        cache.push(args);
        if (cache.length > MAX_LOGS) {
          cache.shift();
        }
      });
      return debug32;
    }
    exports2.default = Debug2;
    exports2.Debug = Debug2;
    Debug2.enable = (namespace) => {
      node_1.default.enable(namespace);
    };
    Debug2.enabled = (namespace) => node_1.default.enabled(namespace);
    function getLogs(numChars = 7500) {
      const output = cache.map((c) => c.map((item) => {
        if (typeof item === "string") {
          return item;
        }
        return JSON.stringify(item);
      }).join("  ")).join("\n");
      if (output.length < numChars) {
        return output;
      }
      return output.slice(-numChars);
    }
    exports2.getLogs = getLogs;
  });
  var require_package = __commonJS((exports2, module2) => {
    module2.exports = {
      name: "@prisma/engines-version",
      version: "2.22.0-21.60cc71d884972ab4e897f0277c4b84383dddaf6c",
      main: "index.js",
      types: "index.d.ts",
      license: "Apache-2.0",
      author: "Tim Suchanek <suchanek@prisma.io>",
      prisma: {
        enginesVersion: "60cc71d884972ab4e897f0277c4b84383dddaf6c"
      },
      devDependencies: {
        "@types/node": "14.14.43",
        typescript: "4.2.4"
      },
      scripts: {
        build: "tsc -d",
        prepublishOnly: "tsc -d",
        publish: "echo $GITHUB_CONTEXT"
      },
      files: [
        "index.js",
        "index.d.ts"
      ]
    };
  });
  var require_engines_version = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.enginesVersion = void 0;
    exports2.enginesVersion = require_package().prisma.enginesVersion;
  });
  var require_getNapiName = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getNapiName = exports2.NAPI_QUERY_ENGINE_URL_BASE = void 0;
    exports2.NAPI_QUERY_ENGINE_URL_BASE = "libquery_engine_napi";
    function getNapiName(platform, type) {
      const isUrl = type === "url";
      if (platform.includes("windows")) {
        return isUrl ? `query_engine_napi.dll.node` : `query_engine_napi-${platform}.dll.node`;
      } else if (platform.includes("linux") || platform.includes("debian") || platform.includes("rhel")) {
        return isUrl ? `${exports2.NAPI_QUERY_ENGINE_URL_BASE}.so.node` : `${exports2.NAPI_QUERY_ENGINE_URL_BASE}-${platform}.so.node`;
      } else if (platform.includes("darwin")) {
        return isUrl ? `${exports2.NAPI_QUERY_ENGINE_URL_BASE}.dylib.node` : `${exports2.NAPI_QUERY_ENGINE_URL_BASE}-${platform}.dylib.node`;
      } else {
        throw new Error(`NAPI is currently not supported on your platform: ${platform}`);
      }
    }
    exports2.getNapiName = getNapiName;
  });
  var require_getPlatform = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getPlatform = exports2.getOpenSSLVersion = exports2.parseOpenSSLVersion = exports2.resolveDistro = exports2.parseDistro = exports2.getos = void 0;
    var child_process_12 = require("child_process");
    var fs_12 = __importDefault2(require("fs"));
    var os_1 = __importDefault2(require("os"));
    var util_12 = require("util");
    var readFile2 = util_12.promisify(fs_12.default.readFile);
    var exists2 = util_12.promisify(fs_12.default.exists);
    async function getos() {
      const platform = os_1.default.platform();
      const arch = process.arch;
      if (platform === "freebsd") {
        const version = await gracefulExec(`freebsd-version`);
        if (version && version.trim().length > 0) {
          const regex = /^(\d+)\.?/;
          const match = regex.exec(version);
          if (match) {
            return {
              platform: "freebsd",
              distro: `freebsd${match[1]}`,
              arch
            };
          }
        }
      }
      if (platform !== "linux") {
        return {
          platform,
          arch
        };
      }
      return {
        platform: "linux",
        libssl: await getOpenSSLVersion(),
        distro: await resolveDistro(),
        arch
      };
    }
    exports2.getos = getos;
    function parseDistro(input) {
      const idRegex = /^ID="?([^"\n]*)"?$/im;
      const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
      const idMatch = idRegex.exec(input);
      const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
      const idLikeMatch = idLikeRegex.exec(input);
      const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
      if (id === "raspbian") {
        return "arm";
      }
      if (id === "nixos") {
        return "nixos";
      }
      if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
        return "rhel";
      }
      if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
        return "debian";
      }
      return;
    }
    exports2.parseDistro = parseDistro;
    async function resolveDistro() {
      const osReleaseFile = "/etc/os-release";
      const alpineReleaseFile = "/etc/alpine-release";
      if (await exists2(alpineReleaseFile)) {
        return "musl";
      } else if (await exists2(osReleaseFile)) {
        return parseDistro(await readFile2(osReleaseFile, "utf-8"));
      } else {
        return;
      }
    }
    exports2.resolveDistro = resolveDistro;
    function parseOpenSSLVersion(input) {
      const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
      if (match) {
        return match[1] + ".x";
      }
      return;
    }
    exports2.parseOpenSSLVersion = parseOpenSSLVersion;
    async function getOpenSSLVersion() {
      const [version, ls] = await Promise.all([
        gracefulExec(`openssl version -v`),
        gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
      ]);
      if (version) {
        const v = parseOpenSSLVersion(version);
        if (v) {
          return v;
        }
      }
      if (ls) {
        const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
        if (match) {
          return match[1] + ".x";
        }
      }
      return void 0;
    }
    exports2.getOpenSSLVersion = getOpenSSLVersion;
    async function gracefulExec(cmd) {
      return new Promise((resolve) => {
        try {
          child_process_12.exec(cmd, (err, stdout) => {
            resolve(String(stdout));
          });
        } catch (e) {
          resolve(void 0);
          return void 0;
        }
      });
    }
    async function getPlatform() {
      const {platform, libssl, distro, arch} = await getos();
      if (platform === "darwin") {
        return "darwin";
      }
      if (platform === "win32") {
        return "windows";
      }
      if (platform === "freebsd") {
        return distro;
      }
      if (platform === "openbsd") {
        return "openbsd";
      }
      if (platform === "netbsd") {
        return "netbsd";
      }
      if (platform === "linux" && arch === "arm64") {
        return `linux-arm-openssl-${libssl}`;
      }
      if (platform === "linux" && distro === "nixos") {
        return "linux-nixos";
      }
      if (platform === "linux" && distro === "musl") {
        return "linux-musl";
      }
      if (platform === "linux" && distro && libssl) {
        return distro + "-openssl-" + libssl;
      }
      if (libssl) {
        return "debian-openssl-" + libssl;
      }
      if (distro) {
        return distro + "-openssl-1.1.x";
      }
      return "debian-openssl-1.1.x";
    }
    exports2.getPlatform = getPlatform;
  });
  var require_platforms = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.platforms = void 0;
    exports2.platforms = [
      "darwin",
      "debian-openssl-1.0.x",
      "debian-openssl-1.1.x",
      "rhel-openssl-1.0.x",
      "rhel-openssl-1.1.x",
      "linux-arm-openssl-1.1.x",
      "linux-arm-openssl-1.0.x",
      "linux-musl",
      "linux-nixos",
      "windows",
      "freebsd11",
      "freebsd12",
      "openbsd",
      "netbsd",
      "arm"
    ];
  });
  var require_dist2 = __commonJS((exports2) => {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar22 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.platforms = exports2.getPlatform = exports2.getos = void 0;
    __exportStar22(require_getNapiName(), exports2);
    var getPlatform_1 = require_getPlatform();
    Object.defineProperty(exports2, "getos", {enumerable: true, get: function() {
      return getPlatform_1.getos;
    }});
    Object.defineProperty(exports2, "getPlatform", {enumerable: true, get: function() {
      return getPlatform_1.getPlatform;
    }});
    var platforms_1 = require_platforms();
    Object.defineProperty(exports2, "platforms", {enumerable: true, get: function() {
      return platforms_1.platforms;
    }});
  });
  var require_color_name = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
  });
  var require_conversions = __commonJS((exports2, module2) => {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: {channels: 3, labels: "rgb"},
      hsl: {channels: 3, labels: "hsl"},
      hsv: {channels: 3, labels: "hsv"},
      hwb: {channels: 3, labels: "hwb"},
      cmyk: {channels: 4, labels: "cmyk"},
      xyz: {channels: 3, labels: "xyz"},
      lab: {channels: 3, labels: "lab"},
      lch: {channels: 3, labels: "lch"},
      hex: {channels: 1, labels: ["hex"]},
      keyword: {channels: 1, labels: ["keyword"]},
      ansi16: {channels: 1, labels: ["ansi16"]},
      ansi256: {channels: 1, labels: ["ansi256"]},
      hcg: {channels: 3, labels: ["h", "c", "g"]},
      apple: {channels: 3, labels: ["r16", "g16", "b16"]},
      gray: {channels: 1, labels: ["gray"]}
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const {channels, labels} = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", {value: channels});
      Object.defineProperty(convert[model], "labels", {value: labels});
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min2 = Math.min(r, g, b);
      const max2 = Math.max(r, g, b);
      const delta = max2 - min2;
      let h;
      let s;
      if (max2 === min2) {
        h = 0;
      } else if (r === max2) {
        h = (g - b) / delta;
      } else if (g === max2) {
        h = 2 + (b - r) / delta;
      } else if (b === max2) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min2 + max2) / 2;
      if (max2 === min2) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max2 + min2);
      } else {
        s = delta / (2 - max2 - min2);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max2 = Math.max(Math.max(r, g), b);
      const min2 = Math.min(Math.min(r, g), b);
      const chroma = max2 - min2;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min2 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max2 === r) {
        hue = (g - b) / chroma % 6;
      } else if (max2 === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  });
  var require_route = __commonJS((exports2, module2) => {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path2 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path2.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path2;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  });
  var require_color_convert = __commonJS((exports2, module2) => {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
      Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  });
  var require_ansi_styles = __commonJS((exports2, module2) => {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity2, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity2, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  });
  var require_util = __commonJS((exports2, module2) => {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  });
  var require_templates = __commonJS((exports2, module2) => {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk6, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk6;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk6, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk6, styles)(string));
          styles.push({inverse, styles: parseStyle(style)});
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk6, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  });
  var require_source = __commonJS((exports2, module2) => {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var {stdout: stdoutColor, stderr: stderrColor} = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var {isArray} = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk22 = {};
      applyOptions(chalk22, options);
      chalk22.template = (...arguments_) => chalkTag(chalk22.template, ...arguments_);
      Object.setPrototypeOf(chalk22, Chalk.prototype);
      Object.setPrototypeOf(chalk22.template, chalk22);
      chalk22.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk22.template.Instance = ChalkClass;
      return chalk22.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, {value: builder});
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", {value: builder});
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const {level} = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const {openAll, closeAll} = styler;
      if (string.indexOf("") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk22, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk22, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk6 = Chalk();
    chalk6.supportsColor = stdoutColor;
    chalk6.stderr = Chalk({level: stderrColor ? stderrColor.level : 0});
    chalk6.stderr.supportsColor = stderrColor;
    module2.exports = chalk6;
  });
  var require_windows = __commonJS((exports2, module2) => {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function checkPathExt(path2, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path2.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path2, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path2, options);
    }
    function isexe(path2, options, cb) {
      fs2.stat(path2, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path2, options));
      });
    }
    function sync(path2, options) {
      return checkStat(fs2.statSync(path2), path2, options);
    }
  });
  var require_mode = __commonJS((exports2, module2) => {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function isexe(path2, options, cb) {
      fs2.stat(path2, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path2, options) {
      return checkStat(fs2.statSync(path2), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod2 = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
      return ret;
    }
  });
  var require_isexe = __commonJS((exports2, module2) => {
    var fs2 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path2, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path2, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path2, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path2, options) {
      try {
        return core.sync(path2, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  });
  var require_which = __commonJS((exports2, module2) => {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path2 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, {pathExt: pathExtExe});
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which;
    which.sync = whichSync;
  });
  var require_path_key = __commonJS((exports2, module2) => {
    "use strict";
    var pathKey = (options = {}) => {
      const environment = options.env || process.env;
      const platform = options.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  });
  var require_resolveCommand = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var which = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env[getPathKey({env})],
          pathExt: withoutPathExt ? path2.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path2.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  });
  var require_escape = __commonJS((exports2, module2) => {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  });
  var require_shebang_regex = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = /^#!(.*)/;
  });
  var require_shebang_command = __commonJS((exports2, module2) => {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match = string.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path2, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary = path2.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  });
  var require_readShebang = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs2.openSync(command, "r");
        fs2.readSync(fd, buffer, 0, size, 0);
        fs2.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  });
  var require_parse = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path2.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse2(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse2;
  });
  var require_enoent = __commonJS((exports2, module2) => {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  });
  var require_cross_spawn = __commonJS((exports2, module2) => {
    "use strict";
    var cp = require("child_process");
    var parse2 = require_parse();
    var enoent = require_enoent();
    function spawn(command, args, options) {
      const parsed = parse2(command, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse2(command, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse2;
    module2.exports._enoent = enoent;
  });
  var require_strip_final_newline = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (input) => {
      const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
      const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
      if (input[input.length - 1] === LF) {
        input = input.slice(0, input.length - 1);
      }
      if (input[input.length - 1] === CR) {
        input = input.slice(0, input.length - 1);
      }
      return input;
    };
  });
  var require_npm_run_path = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var pathKey = require_path_key();
    var npmRunPath = (options) => {
      options = {
        cwd: process.cwd(),
        path: process.env[pathKey()],
        execPath: process.execPath,
        ...options
      };
      let previous;
      let cwdPath = path2.resolve(options.cwd);
      const result = [];
      while (previous !== cwdPath) {
        result.push(path2.join(cwdPath, "node_modules/.bin"));
        previous = cwdPath;
        cwdPath = path2.resolve(cwdPath, "..");
      }
      const execPathDir = path2.resolve(options.cwd, options.execPath, "..");
      result.push(execPathDir);
      return result.concat(options.path).join(path2.delimiter);
    };
    module2.exports = npmRunPath;
    module2.exports.default = npmRunPath;
    module2.exports.env = (options) => {
      options = {
        env: process.env,
        ...options
      };
      const env = {...options.env};
      const path3 = pathKey({env});
      options.path = env[path3];
      env[path3] = module2.exports(options);
      return env;
    };
  });
  var require_mimic_fn = __commonJS((exports2, module2) => {
    "use strict";
    var mimicFn = (to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  });
  var require_onetime = __commonJS((exports2, module2) => {
    "use strict";
    var mimicFn = require_mimic_fn();
    var calledFunctions = new WeakMap();
    var onetime = (function_, options = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime2 = function(...arguments_) {
        calledFunctions.set(onetime2, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime2, function_);
      calledFunctions.set(onetime2, callCount);
      return onetime2;
    };
    module2.exports = onetime;
    module2.exports.default = onetime;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
  });
  var require_core = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.SIGNALS = void 0;
    var SIGNALS = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
    exports2.SIGNALS = SIGNALS;
  });
  var require_realtime = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
    var getRealtimeSignals = function() {
      const length = SIGRTMAX - SIGRTMIN + 1;
      return Array.from({length}, getRealtimeSignal);
    };
    exports2.getRealtimeSignals = getRealtimeSignals;
    var getRealtimeSignal = function(value, index) {
      return {
        name: `SIGRT${index + 1}`,
        number: SIGRTMIN + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
      };
    };
    var SIGRTMIN = 34;
    var SIGRTMAX = 64;
    exports2.SIGRTMAX = SIGRTMAX;
  });
  var require_signals = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getSignals = void 0;
    var _os = require("os");
    var _core = require_core();
    var _realtime = require_realtime();
    var getSignals = function() {
      const realtimeSignals = (0, _realtime.getRealtimeSignals)();
      const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
      return signals;
    };
    exports2.getSignals = getSignals;
    var normalizeSignal = function({
      name,
      number: defaultNumber,
      description,
      action,
      forced = false,
      standard
    }) {
      const {
        signals: {[name]: constantSignal}
      } = _os.constants;
      const supported = constantSignal !== void 0;
      const number = supported ? constantSignal : defaultNumber;
      return {name, number, description, supported, action, forced, standard};
    };
  });
  var require_main = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.signalsByNumber = exports2.signalsByName = void 0;
    var _os = require("os");
    var _signals = require_signals();
    var _realtime = require_realtime();
    var getSignalsByName = function() {
      const signals = (0, _signals.getSignals)();
      return signals.reduce(getSignalByName, {});
    };
    var getSignalByName = function(signalByNameMemo, {name, number, description, supported, action, forced, standard}) {
      return {
        ...signalByNameMemo,
        [name]: {name, number, description, supported, action, forced, standard}
      };
    };
    var signalsByName = getSignalsByName();
    exports2.signalsByName = signalsByName;
    var getSignalsByNumber = function() {
      const signals = (0, _signals.getSignals)();
      const length = _realtime.SIGRTMAX + 1;
      const signalsA = Array.from({length}, (value, number) => getSignalByNumber(number, signals));
      return Object.assign({}, ...signalsA);
    };
    var getSignalByNumber = function(number, signals) {
      const signal = findSignalByNumber(number, signals);
      if (signal === void 0) {
        return {};
      }
      const {name, description, supported, action, forced, standard} = signal;
      return {
        [number]: {
          name,
          number,
          description,
          supported,
          action,
          forced,
          standard
        }
      };
    };
    var findSignalByNumber = function(number, signals) {
      const signal = signals.find(({name}) => _os.constants.signals[name] === number);
      if (signal !== void 0) {
        return signal;
      }
      return signals.find((signalA) => signalA.number === number);
    };
    var signalsByNumber = getSignalsByNumber();
    exports2.signalsByNumber = signalsByNumber;
  });
  var require_error = __commonJS((exports2, module2) => {
    "use strict";
    var {signalsByName} = require_main();
    var getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {
      if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
      }
      if (isCanceled) {
        return "was canceled";
      }
      if (errorCode !== void 0) {
        return `failed with ${errorCode}`;
      }
      if (signal !== void 0) {
        return `was killed with ${signal} (${signalDescription})`;
      }
      if (exitCode !== void 0) {
        return `failed with exit code ${exitCode}`;
      }
      return "failed";
    };
    var makeError = ({
      stdout,
      stderr,
      all,
      error,
      signal,
      exitCode,
      command,
      timedOut,
      isCanceled,
      killed,
      parsed: {options: {timeout}}
    }) => {
      exitCode = exitCode === null ? void 0 : exitCode;
      signal = signal === null ? void 0 : signal;
      const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
      const errorCode = error && error.code;
      const prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});
      const execaMessage = `Command ${prefix}: ${command}`;
      const isError3 = Object.prototype.toString.call(error) === "[object Error]";
      const shortMessage = isError3 ? `${execaMessage}
${error.message}` : execaMessage;
      const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
      if (isError3) {
        error.originalMessage = error.message;
        error.message = message;
      } else {
        error = new Error(message);
      }
      error.shortMessage = shortMessage;
      error.command = command;
      error.exitCode = exitCode;
      error.signal = signal;
      error.signalDescription = signalDescription;
      error.stdout = stdout;
      error.stderr = stderr;
      if (all !== void 0) {
        error.all = all;
      }
      if ("bufferedData" in error) {
        delete error.bufferedData;
      }
      error.failed = true;
      error.timedOut = Boolean(timedOut);
      error.isCanceled = isCanceled;
      error.killed = killed && !timedOut;
      return error;
    };
    module2.exports = makeError;
  });
  var require_stdio = __commonJS((exports2, module2) => {
    "use strict";
    var aliases = ["stdin", "stdout", "stderr"];
    var hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
    var normalizeStdio = (options) => {
      if (!options) {
        return;
      }
      const {stdio} = options;
      if (stdio === void 0) {
        return aliases.map((alias) => options[alias]);
      }
      if (hasAlias(options)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
      }
      if (typeof stdio === "string") {
        return stdio;
      }
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const length = Math.max(stdio.length, aliases.length);
      return Array.from({length}, (value, index) => stdio[index]);
    };
    module2.exports = normalizeStdio;
    module2.exports.node = (options) => {
      const stdio = normalizeStdio(options);
      if (stdio === "ipc") {
        return "ipc";
      }
      if (stdio === void 0 || typeof stdio === "string") {
        return [stdio, stdio, stdio, "ipc"];
      }
      if (stdio.includes("ipc")) {
        return stdio;
      }
      return [...stdio, "ipc"];
    };
  });
  var require_signals2 = __commonJS((exports2, module2) => {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (process.platform === "linux") {
      module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
  });
  var require_signal_exit = __commonJS((exports2, module2) => {
    var assert = require("assert");
    var signals = require_signals2();
    var isWin = /^win/i.test(process.platform);
    var EE = require("events");
    if (typeof EE !== "function") {
      EE = EE.EventEmitter;
    }
    var emitter;
    if (process.__signal_exit_emitter__) {
      emitter = process.__signal_exit_emitter__;
    } else {
      emitter = process.__signal_exit_emitter__ = new EE();
      emitter.count = 0;
      emitter.emitted = {};
    }
    if (!emitter.infinite) {
      emitter.setMaxListeners(Infinity);
      emitter.infinite = true;
    }
    module2.exports = function(cb, opts) {
      assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
      if (loaded === false) {
        load();
      }
      var ev = "exit";
      if (opts && opts.alwaysLast) {
        ev = "afterexit";
      }
      var remove = function() {
        emitter.removeListener(ev, cb);
        if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
          unload();
        }
      };
      emitter.on(ev, cb);
      return remove;
    };
    module2.exports.unload = unload;
    function unload() {
      if (!loaded) {
        return;
      }
      loaded = false;
      signals.forEach(function(sig) {
        try {
          process.removeListener(sig, sigListeners[sig]);
        } catch (er) {
        }
      });
      process.emit = originalProcessEmit;
      process.reallyExit = originalProcessReallyExit;
      emitter.count -= 1;
    }
    function emit(event, code, signal) {
      if (emitter.emitted[event]) {
        return;
      }
      emitter.emitted[event] = true;
      emitter.emit(event, code, signal);
    }
    var sigListeners = {};
    signals.forEach(function(sig) {
      sigListeners[sig] = function listener() {
        var listeners = process.listeners(sig);
        if (listeners.length === emitter.count) {
          unload();
          emit("exit", null, sig);
          emit("afterexit", null, sig);
          if (isWin && sig === "SIGHUP") {
            sig = "SIGINT";
          }
          process.kill(process.pid, sig);
        }
      };
    });
    module2.exports.signals = function() {
      return signals;
    };
    module2.exports.load = load;
    var loaded = false;
    function load() {
      if (loaded) {
        return;
      }
      loaded = true;
      emitter.count += 1;
      signals = signals.filter(function(sig) {
        try {
          process.on(sig, sigListeners[sig]);
          return true;
        } catch (er) {
          return false;
        }
      });
      process.emit = processEmit;
      process.reallyExit = processReallyExit;
    }
    var originalProcessReallyExit = process.reallyExit;
    function processReallyExit(code) {
      process.exitCode = code || 0;
      emit("exit", process.exitCode, null);
      emit("afterexit", process.exitCode, null);
      originalProcessReallyExit.call(process, process.exitCode);
    }
    var originalProcessEmit = process.emit;
    function processEmit(ev, arg) {
      if (ev === "exit") {
        if (arg !== void 0) {
          process.exitCode = arg;
        }
        var ret = originalProcessEmit.apply(this, arguments);
        emit("exit", process.exitCode, null);
        emit("afterexit", process.exitCode, null);
        return ret;
      } else {
        return originalProcessEmit.apply(this, arguments);
      }
    }
  });
  var require_kill = __commonJS((exports2, module2) => {
    "use strict";
    var os = require("os");
    var onExit = require_signal_exit();
    var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
    var spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
      const killResult = kill(signal);
      setKillTimeout(kill, signal, options, killResult);
      return killResult;
    };
    var setKillTimeout = (kill, signal, options, killResult) => {
      if (!shouldForceKill(signal, options, killResult)) {
        return;
      }
      const timeout = getForceKillAfterTimeout(options);
      const t = setTimeout(() => {
        kill("SIGKILL");
      }, timeout);
      if (t.unref) {
        t.unref();
      }
    };
    var shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {
      return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
    };
    var isSigterm = (signal) => {
      return signal === os.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
    };
    var getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {
      if (forceKillAfterTimeout === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT;
      }
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
      }
      return forceKillAfterTimeout;
    };
    var spawnedCancel = (spawned, context) => {
      const killResult = spawned.kill();
      if (killResult) {
        context.isCanceled = true;
      }
    };
    var timeoutKill = (spawned, signal, reject) => {
      spawned.kill(signal);
      reject(Object.assign(new Error("Timed out"), {timedOut: true, signal}));
    };
    var setupTimeout = (spawned, {timeout, killSignal = "SIGTERM"}, spawnedPromise) => {
      if (timeout === 0 || timeout === void 0) {
        return spawnedPromise;
      }
      if (!Number.isFinite(timeout) || timeout < 0) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
      }
      let timeoutId;
      const timeoutPromise = new Promise((resolve, reject) => {
        timeoutId = setTimeout(() => {
          timeoutKill(spawned, killSignal, reject);
        }, timeout);
      });
      const safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    };
    var setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {
      if (!cleanup || detached) {
        return timedPromise;
      }
      const removeExitHandler = onExit(() => {
        spawned.kill();
      });
      return timedPromise.finally(() => {
        removeExitHandler();
      });
    };
    module2.exports = {
      spawnedKill,
      spawnedCancel,
      setupTimeout,
      setExitHandler
    };
  });
  var require_is_stream = __commonJS((exports2, module2) => {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
    module2.exports = isStream;
  });
  var require_buffer_stream = __commonJS((exports2, module2) => {
    "use strict";
    var {PassThrough: PassThroughStream} = require("stream");
    module2.exports = (options) => {
      options = {...options};
      const {array} = options;
      let {encoding} = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({objectMode});
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  });
  var require_get_stream = __commonJS((exports2, module2) => {
    "use strict";
    var {constants: BufferConstants} = require("buffer");
    var stream = require("stream");
    var {promisify} = require("util");
    var bufferStream = require_buffer_stream();
    var streamPipelinePromisified = promisify(stream.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        throw new Error("Expected a stream");
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const {maxBuffer} = options;
      const stream2 = bufferStream(options);
      await new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
          if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream2.getBufferedValue();
          }
          reject(error);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream2);
            resolve();
          } catch (error) {
            rejectPromise(error);
          }
        })();
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream2.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream2, options) => getStream(stream2, {...options, encoding: "buffer"});
    module2.exports.array = (stream2, options) => getStream(stream2, {...options, array: true});
    module2.exports.MaxBufferError = MaxBufferError;
  });
  var require_merge_stream = __commonJS((exports2, module2) => {
    "use strict";
    var {PassThrough} = require("stream");
    module2.exports = function() {
      var sources = [];
      var output = new PassThrough({objectMode: true});
      output.setMaxListeners(0);
      output.add = add2;
      output.isEmpty = isEmpty;
      output.on("unpipe", remove);
      Array.prototype.slice.call(arguments).forEach(add2);
      return output;
      function add2(source) {
        if (Array.isArray(source)) {
          source.forEach(add2);
          return this;
        }
        sources.push(source);
        source.once("end", remove.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, {end: false});
        return this;
      }
      function isEmpty() {
        return sources.length == 0;
      }
      function remove(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        });
        if (!sources.length && output.readable) {
          output.end();
        }
      }
    };
  });
  var require_stream = __commonJS((exports2, module2) => {
    "use strict";
    var isStream = require_is_stream();
    var getStream = require_get_stream();
    var mergeStream = require_merge_stream();
    var handleInput = (spawned, input) => {
      if (input === void 0 || spawned.stdin === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    };
    var makeAllStream = (spawned, {all}) => {
      if (!all || !spawned.stdout && !spawned.stderr) {
        return;
      }
      const mixed = mergeStream();
      if (spawned.stdout) {
        mixed.add(spawned.stdout);
      }
      if (spawned.stderr) {
        mixed.add(spawned.stderr);
      }
      return mixed;
    };
    var getBufferedData = async (stream, streamPromise) => {
      if (!stream) {
        return;
      }
      stream.destroy();
      try {
        return await streamPromise;
      } catch (error) {
        return error.bufferedData;
      }
    };
    var getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {
      if (!stream || !buffer) {
        return;
      }
      if (encoding) {
        return getStream(stream, {encoding, maxBuffer});
      }
      return getStream.buffer(stream, {maxBuffer});
    };
    var getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {
      const stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});
      const stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});
      const allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error) {
        return Promise.all([
          {error, signal: error.signal, timedOut: error.timedOut},
          getBufferedData(stdout, stdoutPromise),
          getBufferedData(stderr, stderrPromise),
          getBufferedData(all, allPromise)
        ]);
      }
    };
    var validateInputSync = ({input}) => {
      if (isStream(input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
    };
    module2.exports = {
      handleInput,
      makeAllStream,
      getSpawnedResult,
      validateInputSync
    };
  });
  var require_promise = __commonJS((exports2, module2) => {
    "use strict";
    var nativePromisePrototype = (async () => {
    })().constructor.prototype;
    var descriptors = ["then", "catch", "finally"].map((property) => [
      property,
      Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
    var mergePromise = (spawned, promise) => {
      for (const [property, descriptor] of descriptors) {
        const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, {...descriptor, value});
      }
      return spawned;
    };
    var getSpawnedPromise = (spawned) => {
      return new Promise((resolve, reject) => {
        spawned.on("exit", (exitCode, signal) => {
          resolve({exitCode, signal});
        });
        spawned.on("error", (error) => {
          reject(error);
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (error) => {
            reject(error);
          });
        }
      });
    };
    module2.exports = {
      mergePromise,
      getSpawnedPromise
    };
  });
  var require_command = __commonJS((exports2, module2) => {
    "use strict";
    var SPACES_REGEXP = / +/g;
    var joinCommand = (file, args = []) => {
      if (!Array.isArray(args)) {
        return file;
      }
      return [file, ...args].join(" ");
    };
    var parseCommand = (command) => {
      const tokens = [];
      for (const token of command.trim().split(SPACES_REGEXP)) {
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) {
          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        } else {
          tokens.push(token);
        }
      }
      return tokens;
    };
    module2.exports = {
      joinCommand,
      parseCommand
    };
  });
  var require_execa = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var childProcess = require("child_process");
    var crossSpawn = require_cross_spawn();
    var stripFinalNewline = require_strip_final_newline();
    var npmRunPath = require_npm_run_path();
    var onetime = require_onetime();
    var makeError = require_error();
    var normalizeStdio = require_stdio();
    var {spawnedKill, spawnedCancel, setupTimeout, setExitHandler} = require_kill();
    var {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = require_stream();
    var {mergePromise, getSpawnedPromise} = require_promise();
    var {joinCommand, parseCommand} = require_command();
    var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
    var getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
      const env = extendEnv ? {...process.env, ...envOption} : envOption;
      if (preferLocal) {
        return npmRunPath.env({env, cwd: localDir, execPath});
      }
      return env;
    };
    var handleArguments = (file, args, options = {}) => {
      const parsed = crossSpawn._parse(file, args, options);
      file = parsed.command;
      args = parsed.args;
      options = parsed.options;
      options = {
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options.cwd || process.cwd(),
        execPath: process.execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        ...options
      };
      options.env = getEnv(options);
      options.stdio = normalizeStdio(options);
      if (process.platform === "win32" && path2.basename(file, ".exe") === "cmd") {
        args.unshift("/q");
      }
      return {file, args, options, parsed};
    };
    var handleOutput = (options, value, error) => {
      if (typeof value !== "string" && !Buffer.isBuffer(value)) {
        return error === void 0 ? void 0 : "";
      }
      if (options.stripFinalNewline) {
        return stripFinalNewline(value);
      }
      return value;
    };
    var execa = (file, args, options) => {
      const parsed = handleArguments(file, args, options);
      const command = joinCommand(file, args);
      let spawned;
      try {
        spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        const dummySpawned = new childProcess.ChildProcess();
        const errorPromise = Promise.reject(makeError({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        }));
        return mergePromise(dummySpawned, errorPromise);
      }
      const spawnedPromise = getSpawnedPromise(spawned);
      const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
      const processDone = setExitHandler(spawned, parsed.options, timedPromise);
      const context = {isCanceled: false};
      spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
      spawned.cancel = spawnedCancel.bind(null, spawned, context);
      const handlePromise = async () => {
        const [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
        const stdout = handleOutput(parsed.options, stdoutResult);
        const stderr = handleOutput(parsed.options, stderrResult);
        const all = handleOutput(parsed.options, allResult);
        if (error || exitCode !== 0 || signal !== null) {
          const returnedError = makeError({
            error,
            exitCode,
            signal,
            stdout,
            stderr,
            all,
            command,
            parsed,
            timedOut,
            isCanceled: context.isCanceled,
            killed: spawned.killed
          });
          if (!parsed.options.reject) {
            return returnedError;
          }
          throw returnedError;
        }
        return {
          command,
          exitCode: 0,
          stdout,
          stderr,
          all,
          failed: false,
          timedOut: false,
          isCanceled: false,
          killed: false
        };
      };
      const handlePromiseOnce = onetime(handlePromise);
      handleInput(spawned, parsed.options.input);
      spawned.all = makeAllStream(spawned, parsed.options);
      return mergePromise(spawned, handlePromiseOnce);
    };
    module2.exports = execa;
    module2.exports.sync = (file, args, options) => {
      const parsed = handleArguments(file, args, options);
      const command = joinCommand(file, args);
      validateInputSync(parsed.options);
      let result;
      try {
        result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        throw makeError({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        });
      }
      const stdout = handleOutput(parsed.options, result.stdout, result.error);
      const stderr = handleOutput(parsed.options, result.stderr, result.error);
      if (result.error || result.status !== 0 || result.signal !== null) {
        const error = makeError({
          stdout,
          stderr,
          error: result.error,
          signal: result.signal,
          exitCode: result.status,
          command,
          parsed,
          timedOut: result.error && result.error.code === "ETIMEDOUT",
          isCanceled: false,
          killed: result.signal !== null
        });
        if (!parsed.options.reject) {
          return error;
        }
        throw error;
      }
      return {
        command,
        exitCode: 0,
        stdout,
        stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    module2.exports.command = (command, options) => {
      const [file, ...args] = parseCommand(command);
      return execa(file, args, options);
    };
    module2.exports.commandSync = (command, options) => {
      const [file, ...args] = parseCommand(command);
      return execa.sync(file, args, options);
    };
    module2.exports.node = (scriptPath, args, options = {}) => {
      if (args && !Array.isArray(args) && typeof args === "object") {
        options = args;
        args = [];
      }
      const stdio = normalizeStdio.node(options);
      const defaultExecArgv = process.execArgv.filter((arg) => !arg.startsWith("--inspect"));
      const {
        nodePath = process.execPath,
        nodeOptions = defaultExecArgv
      } = options;
      return execa(nodePath, [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args) ? args : []
      ], {
        ...options,
        stdin: void 0,
        stdout: void 0,
        stderr: void 0,
        stdio,
        shell: false
      });
    };
  });
  var require_semver = __commonJS((exports2, module2) => {
    exports2 = module2.exports = SemVer;
    var debug32;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug32 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug32 = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (var i = 0; i < R; i++) {
      debug32(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    exports2.parse = parse2;
    function parse2(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse2(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse2(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug32("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER2) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug32("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug32("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug32("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse2(version1);
        var v2 = parse2(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(b, a, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug32("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug32("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug32("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug32("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug32("comparator trim", range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug32("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug32("caret", comp);
      comp = replaceTildes(comp, options);
      debug32("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug32("xrange", comp);
      comp = replaceStars(comp, options);
      debug32("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug32("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug32("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug32("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug32("caret", comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug32("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug32("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug32("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug32("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug32("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug32("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug32("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug32("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug32(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max2 = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max2 || maxSV.compare(v) === -1) {
            max2 = v;
            maxSV = new SemVer(max2, options);
          }
        }
      });
      return max2;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min2 = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min2 || minSV.compare(v) === 1) {
            min2 = v;
            minSV = new SemVer(min2, options);
          }
        }
      });
      return min2;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse2(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  });
  var require_make_dir = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var path2 = require("path");
    var {promisify} = require("util");
    var semver = require_semver();
    var useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path2.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var processOptions = (options) => {
      const defaults = {
        mode: 511,
        fs: fs2
      };
      return {
        ...defaults,
        ...options
      };
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    var makeDir = async (input, options) => {
      checkPath(input);
      options = processOptions(options);
      const mkdir = promisify(options.fs.mkdir);
      const stat = promisify(options.fs.stat);
      if (useNativeRecursiveOption && options.fs.mkdir === fs2.mkdir) {
        const pth = path2.resolve(input);
        await mkdir(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = async (pth) => {
        try {
          await mkdir(pth, options.mode);
          return pth;
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path2.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path2.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await stat(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error;
          }
          return pth;
        }
      };
      return make(path2.resolve(input));
    };
    module2.exports = makeDir;
    module2.exports.sync = (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption && options.fs.mkdirSync === fs2.mkdirSync) {
        const pth = path2.resolve(input);
        fs2.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = (pth) => {
        try {
          options.fs.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path2.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path2.dirname(pth));
            return make(pth);
          }
          try {
            if (!options.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error;
          }
        }
        return pth;
      };
      return make(path2.resolve(input));
    };
  });
  var require_indent_string = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (string, count = 1, options) => {
      options = {
        indent: " ",
        includeEmptyLines: false,
        ...options
      };
      if (typeof string !== "string") {
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
      }
      if (typeof count !== "number") {
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
      }
      if (typeof options.indent !== "string") {
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
      }
      if (count === 0) {
        return string;
      }
      const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex, options.indent.repeat(count));
    };
  });
  var require_clean_stack = __commonJS((exports2, module2) => {
    "use strict";
    var os = require("os");
    var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
    var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
    var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
    module2.exports = (stack, options) => {
      options = Object.assign({pretty: false}, options);
      return stack.replace(/\\/g, "/").split("\n").filter((line) => {
        const pathMatches = line.match(extractPathRegex);
        if (pathMatches === null || !pathMatches[1]) {
          return true;
        }
        const match = pathMatches[1];
        if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
          return false;
        }
        return !pathRegex.test(match);
      }).filter((line) => line.trim() !== "").map((line) => {
        if (options.pretty) {
          return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
        }
        return line;
      }).join("\n");
    };
  });
  var require_aggregate_error = __commonJS((exports2, module2) => {
    "use strict";
    var indentString = require_indent_string();
    var cleanStack = require_clean_stack();
    var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        errors = [...errors].map((error) => {
          if (error instanceof Error) {
            return error;
          }
          if (error !== null && typeof error === "object") {
            return Object.assign(new Error(error.message), error);
          }
          return new Error(error);
        });
        let message = errors.map((error) => {
          return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
        }).join("\n");
        message = "\n" + indentString(message, 4);
        super(message);
        this.name = "AggregateError";
        Object.defineProperty(this, "_errors", {value: errors});
      }
      *[Symbol.iterator]() {
        for (const error of this._errors) {
          yield error;
        }
      }
    };
    module2.exports = AggregateError;
  });
  var require_p_map = __commonJS((exports2, module2) => {
    "use strict";
    var AggregateError = require_aggregate_error();
    module2.exports = async (iterable, mapper, {
      concurrency = Infinity,
      stopOnError = true
    } = {}) => {
      return new Promise((resolve, reject) => {
        if (typeof mapper !== "function") {
          throw new TypeError("Mapper function is required");
        }
        if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
        }
        const result = [];
        const errors = [];
        const iterator = iterable[Symbol.iterator]();
        let isRejected = false;
        let isIterableDone = false;
        let resolvingCount = 0;
        let currentIndex = 0;
        const next = () => {
          if (isRejected) {
            return;
          }
          const nextItem = iterator.next();
          const index = currentIndex;
          currentIndex++;
          if (nextItem.done) {
            isIterableDone = true;
            if (resolvingCount === 0) {
              if (!stopOnError && errors.length !== 0) {
                reject(new AggregateError(errors));
              } else {
                resolve(result);
              }
            }
            return;
          }
          resolvingCount++;
          (async () => {
            try {
              const element = await nextItem.value;
              result[index] = await mapper(element, index);
              resolvingCount--;
              next();
            } catch (error) {
              if (stopOnError) {
                isRejected = true;
                reject(error);
              } else {
                errors.push(error);
                resolvingCount--;
                next();
              }
            }
          })();
        };
        for (let i = 0; i < concurrency; i++) {
          next();
          if (isIterableDone) {
            break;
          }
        }
      });
    };
  });
  var require_p_filter = __commonJS((exports2, module2) => {
    "use strict";
    var pMap = require_p_map();
    var pFilter = async (iterable, filterer, options) => {
      const values = await pMap(iterable, (element, index) => Promise.all([filterer(element, index), element]), options);
      return values.filter((value) => Boolean(value[0])).map((value) => value[1]);
    };
    module2.exports = pFilter;
    module2.exports.default = pFilter;
  });
  var require_temp_dir = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var os = require("os");
    var tempDirectorySymbol = Symbol.for("__RESOLVED_TEMP_DIRECTORY__");
    if (!global[tempDirectorySymbol]) {
      Object.defineProperty(global, tempDirectorySymbol, {
        value: fs2.realpathSync(os.tmpdir())
      });
    }
    module2.exports = global[tempDirectorySymbol];
  });
  var require_chmod = __commonJS((exports2) => {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fs2 = __importStar(require("fs"));
    function default_1(file) {
      const s = fs2.statSync(file);
      const newMode = s.mode | 64 | 8 | 1;
      if (s.mode === newMode)
        return;
      const base8 = newMode.toString(8).slice(-3);
      fs2.chmodSync(file, base8);
    }
    exports2.default = default_1;
  });
  var require_commondir = __commonJS((exports2, module2) => {
    var path2 = require("path");
    module2.exports = function(basedir, relfiles) {
      if (relfiles) {
        var files = relfiles.map(function(r) {
          return path2.resolve(basedir, r);
        });
      } else {
        var files = basedir;
      }
      var res = files.slice(1).reduce(function(ps, file) {
        if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
          throw new Error("relative path without a basedir");
        }
        var xs = file.split(/\/+|\\+/);
        for (var i = 0; ps[i] === xs[i] && i < Math.min(ps.length, xs.length); i++)
          ;
        return ps.slice(0, i);
      }, files[0].split(/\/+|\\+/));
      return res.length > 1 ? res.join("/") : "/";
    };
  });
  var require_yocto_queue = __commonJS((exports2, module2) => {
    var Node = class {
      constructor(value) {
        this.value = value;
        this.next = void 0;
      }
    };
    var Queue = class {
      constructor() {
        this.clear();
      }
      enqueue(value) {
        const node = new Node(value);
        if (this._head) {
          this._tail.next = node;
          this._tail = node;
        } else {
          this._head = node;
          this._tail = node;
        }
        this._size++;
      }
      dequeue() {
        const current = this._head;
        if (!current) {
          return;
        }
        this._head = this._head.next;
        this._size--;
        return current.value;
      }
      clear() {
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      get size() {
        return this._size;
      }
      *[Symbol.iterator]() {
        let current = this._head;
        while (current) {
          yield current.value;
          current = current.next;
        }
      }
    };
    module2.exports = Queue;
  });
  var require_p_limit = __commonJS((exports2, module2) => {
    "use strict";
    var Queue = require_yocto_queue();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      }
      const queue = new Queue();
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.size > 0) {
          queue.dequeue()();
        }
      };
      const run = async (fn, resolve, ...args) => {
        activeCount++;
        const result = (async () => fn(...args))();
        resolve(result);
        try {
          await result;
        } catch (e) {
        }
        next();
      };
      const enqueue = (fn, resolve, ...args) => {
        queue.enqueue(run.bind(null, fn, resolve, ...args));
        (async () => {
          await Promise.resolve();
          if (activeCount < concurrency && queue.size > 0) {
            queue.dequeue()();
          }
        })();
      };
      const generator = (fn, ...args) => new Promise((resolve) => {
        enqueue(fn, resolve, ...args);
      });
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.size
        },
        clearQueue: {
          value: () => {
            queue.clear();
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
  });
  var require_p_locate = __commonJS((exports2, module2) => {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = async (element, tester) => tester(await element);
    var finder = async (element) => {
      const values = await Promise.all(element);
      if (values[1] === true) {
        throw new EndError(values[0]);
      }
      return false;
    };
    var pLocate = async (iterable, tester, options) => {
      options = {
        concurrency: Infinity,
        preserveOrder: true,
        ...options
      };
      const limit = pLimit(options.concurrency);
      const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
      const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
      try {
        await Promise.all(items.map((element) => checkLimit(finder, element)));
      } catch (error) {
        if (error instanceof EndError) {
          return error.value;
        }
        throw error;
      }
    };
    module2.exports = pLocate;
  });
  var require_locate_path = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var fs2 = require("fs");
    var {promisify} = require("util");
    var pLocate = require_p_locate();
    var fsStat = promisify(fs2.stat);
    var fsLStat = promisify(fs2.lstat);
    var typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType({type}) {
      if (type in typeMappings) {
        return;
      }
      throw new Error(`Invalid type specified: ${type}`);
    }
    var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
    module2.exports = async (paths, options) => {
      options = {
        cwd: process.cwd(),
        type: "file",
        allowSymlinks: true,
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fsStat : fsLStat;
      return pLocate(paths, async (path_) => {
        try {
          const stat = await statFn(path2.resolve(options.cwd, path_));
          return matchType(options.type, stat);
        } catch (e) {
          return false;
        }
      }, options);
    };
    module2.exports.sync = (paths, options) => {
      options = {
        cwd: process.cwd(),
        allowSymlinks: true,
        type: "file",
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fs2.statSync : fs2.lstatSync;
      for (const path_ of paths) {
        try {
          const stat = statFn(path2.resolve(options.cwd, path_));
          if (matchType(options.type, stat)) {
            return path_;
          }
        } catch (e) {
        }
      }
    };
  });
  var require_path_exists = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var {promisify} = require("util");
    var pAccess = promisify(fs2.access);
    module2.exports = async (path2) => {
      try {
        await pAccess(path2);
        return true;
      } catch (_) {
        return false;
      }
    };
    module2.exports.sync = (path2) => {
      try {
        fs2.accessSync(path2);
        return true;
      } catch (_) {
        return false;
      }
    };
  });
  var require_find_up = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var locatePath = require_locate_path();
    var pathExists = require_path_exists();
    var stop = Symbol("findUp.stop");
    module2.exports = async (name, options = {}) => {
      let directory = path2.resolve(options.cwd || "");
      const {root} = path2.parse(directory);
      const paths = [].concat(name);
      const runMatcher = async (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath(paths, locateOptions);
        }
        const foundPath = await name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = await runMatcher({...options, cwd: directory});
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path2.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path2.dirname(directory);
      }
    };
    module2.exports.sync = (name, options = {}) => {
      let directory = path2.resolve(options.cwd || "");
      const {root} = path2.parse(directory);
      const paths = [].concat(name);
      const runMatcher = (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath.sync(paths, locateOptions);
        }
        const foundPath = name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath.sync([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = runMatcher({...options, cwd: directory});
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path2.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path2.dirname(directory);
      }
    };
    module2.exports.exists = pathExists;
    module2.exports.sync.exists = pathExists.sync;
    module2.exports.stop = stop;
  });
  var require_pkg_dir = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var findUp = require_find_up();
    var pkgDir = async (cwd) => {
      const filePath = await findUp("package.json", {cwd});
      return filePath && path2.dirname(filePath);
    };
    module2.exports = pkgDir;
    module2.exports.sync = (cwd) => {
      const filePath = findUp.sync("package.json", {cwd});
      return filePath && path2.dirname(filePath);
    };
  });
  var require_find_cache_dir = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var fs2 = require("fs");
    var commonDir = require_commondir();
    var pkgDir = require_pkg_dir();
    var makeDir = require_make_dir();
    var {env, cwd} = process;
    var isWritable = (path3) => {
      try {
        fs2.accessSync(path3, fs2.constants.W_OK);
        return true;
      } catch (_) {
        return false;
      }
    };
    function useDirectory(directory, options) {
      if (options.create) {
        makeDir.sync(directory);
      }
      if (options.thunk) {
        return (...arguments_) => path2.join(directory, ...arguments_);
      }
      return directory;
    }
    function getNodeModuleDirectory(directory) {
      const nodeModules = path2.join(directory, "node_modules");
      if (!isWritable(nodeModules) && (fs2.existsSync(nodeModules) || !isWritable(path2.join(directory)))) {
        return;
      }
      return nodeModules;
    }
    module2.exports = (options = {}) => {
      if (env.CACHE_DIR && !["true", "false", "1", "0"].includes(env.CACHE_DIR)) {
        return useDirectory(path2.join(env.CACHE_DIR, "find-cache-dir"), options);
      }
      let {cwd: directory = cwd()} = options;
      if (options.files) {
        directory = commonDir(directory, options.files);
      }
      directory = pkgDir.sync(directory);
      if (!directory) {
        return;
      }
      const nodeModules = getNodeModuleDirectory(directory);
      if (!nodeModules) {
        return void 0;
      }
      return useDirectory(path2.join(directory, "node_modules", ".cache", options.name), options);
    };
  });
  var require_util2 = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getDownloadUrl = exports2.getCacheDir = exports2.getRootCacheDir = void 0;
    var debug_12 = __importDefault2(require_dist());
    var get_platform_12 = require_dist2();
    var find_cache_dir_1 = __importDefault2(require_find_cache_dir());
    var fs_12 = __importDefault2(require("fs"));
    var make_dir_12 = __importDefault2(require_make_dir());
    var os_1 = __importDefault2(require("os"));
    var path_12 = __importDefault2(require("path"));
    var download_1 = require_download();
    var debug32 = debug_12.default("prisma:cache-dir");
    async function getRootCacheDir() {
      if (os_1.default.platform() === "win32") {
        const cacheDir = find_cache_dir_1.default({name: "prisma", create: true});
        if (cacheDir) {
          return cacheDir;
        }
        if (process.env.APPDATA) {
          return path_12.default.join(process.env.APPDATA, "Prisma");
        }
      }
      if (process.env.AWS_LAMBDA_FUNCTION_VERSION) {
        try {
          await make_dir_12.default(`/tmp/prisma-download`);
          return `/tmp/prisma-download`;
        } catch (e) {
          return null;
        }
      }
      return path_12.default.join(os_1.default.homedir(), ".cache/prisma");
    }
    exports2.getRootCacheDir = getRootCacheDir;
    async function getCacheDir(channel2, version, platform) {
      const rootCacheDir = await getRootCacheDir();
      if (!rootCacheDir) {
        return null;
      }
      const cacheDir = path_12.default.join(rootCacheDir, channel2, version, platform);
      try {
        if (!fs_12.default.existsSync(cacheDir)) {
          await make_dir_12.default(cacheDir);
        }
      } catch (e) {
        debug32("The following error is being caught and just there for debugging:");
        debug32(e);
        return null;
      }
      return cacheDir;
    }
    exports2.getCacheDir = getCacheDir;
    function getDownloadUrl(channel2, version, platform, binaryName, extension = ".gz") {
      const baseUrl = process.env.PRISMA_BINARIES_MIRROR || "https://binaries.prisma.sh";
      const finalExtension = platform === "windows" && download_1.EngineTypes.libqueryEngineNapi !== binaryName ? `.exe${extension}` : extension;
      if (binaryName === download_1.EngineTypes.libqueryEngineNapi) {
        binaryName = get_platform_12.getNapiName(platform, "url");
      }
      return `${baseUrl}/${channel2}/${version}/${platform}/${binaryName}${finalExtension}`;
    }
    exports2.getDownloadUrl = getDownloadUrl;
  });
  var require_old = __commonJS((exports2) => {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs2 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs2.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs2.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs2.statSync(base);
            linkTarget = fs2.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs2.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs2.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs2.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs2.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  });
  var require_fs = __commonJS((exports2, module2) => {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs2 = require("fs");
    var origRealpath = fs2.realpath;
    var origRealpathSync = fs2.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs2.realpath = realpath;
      fs2.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs2.realpath = origRealpath;
      fs2.realpathSync = origRealpathSync;
    }
  });
  var require_concat_map = __commonJS((exports2, module2) => {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  });
  var require_balanced_match = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  });
  var require_brace_expansion = __commonJS((exports2, module2) => {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  });
  var require_minimatch = __commonJS((exports2, module2) => {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path2 = {sep: "/"};
    try {
      path2 = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
      "?": {open: "(?:", close: ")?"},
      "+": {open: "(?:", close: ")+"},
      "*": {open: "(?:", close: ")*"},
      "@": {open: "(?:", close: ")"}
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path2.sep !== "/") {
        pattern = pattern.split(path2.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path2.sep !== "/") {
        f = f.split(path2.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", {this: this, file, pattern});
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  });
  var require_inherits_browser = __commonJS((exports2, module2) => {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  });
  var require_inherits = __commonJS((exports2, module2) => {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  });
  var require_path_is_absolute = __commonJS((exports2, module2) => {
    "use strict";
    function posix(path2) {
      return path2.charAt(0) === "/";
    }
    function win32(path2) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path2);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  });
  var require_common2 = __commonJS((exports2) => {
    exports2.alphasort = alphasort;
    exports2.alphasorti = alphasorti;
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var path2 = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasorti(a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    }
    function alphasort(a, b) {
      return a.localeCompare(b);
    }
    function setupIgnores(self, options) {
      self.ignore = options.ignore || [];
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore];
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, {dot: true});
      }
      return {
        matcher: new Minimatch(pattern, {dot: true}),
        gmatcher
      };
    }
    function setopts(self, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && pattern.indexOf("/") === -1) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self.silent = !!options.silent;
      self.pattern = pattern;
      self.strict = options.strict !== false;
      self.realpath = !!options.realpath;
      self.realpathCache = options.realpathCache || Object.create(null);
      self.follow = !!options.follow;
      self.dot = !!options.dot;
      self.mark = !!options.mark;
      self.nodir = !!options.nodir;
      if (self.nodir)
        self.mark = true;
      self.sync = !!options.sync;
      self.nounique = !!options.nounique;
      self.nonull = !!options.nonull;
      self.nosort = !!options.nosort;
      self.nocase = !!options.nocase;
      self.stat = !!options.stat;
      self.noprocess = !!options.noprocess;
      self.absolute = !!options.absolute;
      self.maxLength = options.maxLength || Infinity;
      self.cache = options.cache || Object.create(null);
      self.statCache = options.statCache || Object.create(null);
      self.symlinks = options.symlinks || Object.create(null);
      setupIgnores(self, options);
      self.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self.cwd = cwd;
      else {
        self.cwd = path2.resolve(options.cwd);
        self.changedCwd = self.cwd !== cwd;
      }
      self.root = options.root || path2.resolve(self.cwd, "/");
      self.root = path2.resolve(self.root);
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/");
      self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
      if (process.platform === "win32")
        self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
      self.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self.minimatch = new Minimatch(pattern, options);
      self.options = self.minimatch.options;
    }
    function finish(self) {
      var nou = self.nounique;
      var all = nou ? [] : Object.create(null);
      for (var i = 0, l = self.matches.length; i < l; i++) {
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            var literal = self.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self.nosort)
        all = all.sort(self.nocase ? alphasorti : alphasort);
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self.cache[e] || self.cache[makeAbs(self, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self, m2);
        });
      self.found = all;
    }
    function mark(self, p) {
      var abs2 = makeAbs(self, p);
      var c = self.cache[abs2];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self, m);
          self.statCache[mabs] = self.statCache[abs2];
          self.cache[mabs] = self.cache[abs2];
        }
      }
      return m;
    }
    function makeAbs(self, f) {
      var abs2 = f;
      if (f.charAt(0) === "/") {
        abs2 = path2.join(self.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs2 = f;
      } else if (self.changedCwd) {
        abs2 = path2.resolve(self.cwd, f);
      } else {
        abs2 = path2.resolve(f);
      }
      if (process.platform === "win32")
        abs2 = abs2.replace(/\\/g, "/");
      return abs2;
    }
    function isIgnored(self, path3) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));
      });
    }
    function childrenIgnored(self, path3) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path3));
      });
    }
  });
  var require_sync = __commonJS((exports2, module2) => {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var fs2 = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path2 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common2();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self = this;
        this.matches.forEach(function(matchset, index) {
          var set = self.matches[index] = Object.create(null);
          for (var p in matchset) {
            try {
              p = self._makeAbs(p);
              var real = rp.realpathSync(p, self.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs2 = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs2, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs2, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs2, remain, index, inGlobStar) {
      var entries = this._readdir(abs2, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path2.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs2 = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs2;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs2];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs2) {
      if (this.follow)
        return this._readdir(abs2, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = fs2.lstatSync(abs2);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs2] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs2] = "FILE";
      else
        entries = this._readdir(abs2, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs2, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs2))
        return this._readdirInGlobStar(abs2);
      if (ownProp(this.cache, abs2)) {
        var c = this.cache[abs2];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs2, fs2.readdirSync(abs2));
      } catch (er) {
        this._readdirError(abs2, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs2, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs2 === "/")
            e = abs2 + e;
          else
            e = abs2 + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs2] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs2 = this._makeAbs(f);
          this.cache[abs2] = "FILE";
          if (abs2 === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs2, remain, index, inGlobStar) {
      var entries = this._readdir(abs2, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs2];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists2 = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists2)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path2.join(this.root, prefix);
        } else {
          prefix = path2.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs2 = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs2)) {
        var c = this.cache[abs2];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists2;
      var stat = this.statCache[abs2];
      if (!stat) {
        var lstat;
        try {
          lstat = fs2.lstatSync(abs2);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs2] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = fs2.statSync(abs2);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs2] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs2] = this.cache[abs2] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  });
  var require_wrappy = __commonJS((exports2, module2) => {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  });
  var require_once = __commonJS((exports2, module2) => {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  });
  var require_inflight = __commonJS((exports2, module2) => {
    var wrappy = require_wrappy();
    var reqs = Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  });
  var require_glob = __commonJS((exports2, module2) => {
    module2.exports = glob;
    var fs2 = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path2 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common2();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add2) {
      if (add2 === null || typeof add2 !== "object") {
        return origin;
      }
      var keys2 = Object.keys(add2);
      var i = keys2.length;
      while (i--) {
        origin[keys2[i]] = add2[keys2[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self._processing;
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self._finish();
            });
          } else {
            self._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = Object.create(null);
      found.forEach(function(p, i) {
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self.emit("error", er);
          if (--n === 0) {
            self.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs2 = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs2, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs2, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs2, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs2, inGlobStar, function(er, entries) {
        return self._processReaddir2(prefix, read, abs2, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs2, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path2.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs2 = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs2;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs2];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs2];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs2, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs2, false, cb);
      var lstatkey = "lstat\0" + abs2;
      var self = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs2.lstat(abs2, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs2] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self.cache[abs2] = "FILE";
          cb();
        } else
          self._readdir(abs2, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs2, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs2 + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs2))
        return this._readdirInGlobStar(abs2, cb);
      if (ownProp(this.cache, abs2)) {
        var c = this.cache[abs2];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self = this;
      fs2.readdir(abs2, readdirCb(this, abs2, cb));
    };
    function readdirCb(self, abs2, cb) {
      return function(er, entries) {
        if (er)
          self._readdirError(abs2, er, cb);
        else
          self._readdirEntries(abs2, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs2, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs2 === "/")
            e = abs2 + e;
          else
            e = abs2 + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs2] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs2 = this._makeAbs(f);
          this.cache[abs2] = "FILE";
          if (abs2 === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs2, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs2, inGlobStar, function(er, entries) {
        self._processGlobStar2(prefix, read, abs2, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs2, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs2];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self = this;
      this._stat(prefix, function(er, exists2) {
        self._processSimple2(prefix, index, er, exists2, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists2, cb) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists2)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path2.join(this.root, prefix);
        } else {
          prefix = path2.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs2 = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs2)) {
        var c = this.cache[abs2];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists2;
      var stat = this.statCache[abs2];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self = this;
      var statcb = inflight("stat\0" + abs2, lstatcb_);
      if (statcb)
        fs2.lstat(abs2, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs2.stat(abs2, function(er2, stat2) {
            if (er2)
              self._stat2(f, abs2, null, lstat, cb);
            else
              self._stat2(f, abs2, er2, stat2, cb);
          });
        } else {
          self._stat2(f, abs2, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs2, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs2] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs2] = stat;
      if (abs2.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs2] = this.cache[abs2] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  });
  var require_rimraf = __commonJS((exports2, module2) => {
    var assert = require("assert");
    var path2 = require("path");
    var fs2 = require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs2[m];
        m = m + "Sync";
        options[m] = options[m] || fs2[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    };
    var rimraf = (p, options, cb) => {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(() => rimraf_(p2, options, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options, CB);
        });
      };
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, (er, stat) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options, er, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options, er) => {
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    };
    var rmdir = (p, options, originalEr, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path2.join(p, f), options, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options) => {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      let results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options, null);
          else
            options.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options, er);
        }
      }
    };
    var rmdirSync = (p, options, originalEr) => {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    };
    var rmkidsSync = (p, options) => {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path2.join(p, f), options));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  });
  var require_cleanupCache = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.cleanupCache = void 0;
    var fs_12 = __importDefault2(require("fs"));
    var path_12 = __importDefault2(require("path"));
    var util_12 = require_util2();
    var rimraf_1 = __importDefault2(require_rimraf());
    var util_22 = require("util");
    var p_map_1 = __importDefault2(require_p_map());
    var debug_12 = __importDefault2(require_dist());
    var debug32 = debug_12.default("cleanupCache");
    var del = util_22.promisify(rimraf_1.default);
    var readdir = util_22.promisify(fs_12.default.readdir);
    var stat = util_22.promisify(fs_12.default.stat);
    async function cleanupCache(n = 5) {
      try {
        const rootCacheDir = await util_12.getRootCacheDir();
        if (!rootCacheDir) {
          debug32("no rootCacheDir found");
          return;
        }
        const channel2 = "master";
        const cacheDir = path_12.default.join(rootCacheDir, channel2);
        const dirs = await readdir(cacheDir);
        const dirsWithMeta = await Promise.all(dirs.map(async (dirName) => {
          const dir = path_12.default.join(cacheDir, dirName);
          const statResult = await stat(dir);
          return {
            dir,
            created: statResult.birthtime
          };
        }));
        dirsWithMeta.sort((a, b) => a.created < b.created ? 1 : -1);
        const dirsToRemove = dirsWithMeta.slice(n);
        await p_map_1.default(dirsToRemove, (dir) => del(dir.dir), {concurrency: 20});
      } catch (e) {
      }
    }
    exports2.cleanupCache = cleanupCache;
  });
  var require_copy = __commonJS((exports2) => {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.copy = void 0;
    var fs2 = __importStar(require("fs"));
    function copy(src, target) {
      return new Promise((resolve, reject) => {
        fs2.copyFile(src, target, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    exports2.copy = copy;
  });
  var require_retry_operation = __commonJS((exports2, module2) => {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = {forever: options};
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self = this;
      var timer = setTimeout(function() {
        self._attempts++;
        if (self._operationTimeoutCb) {
          self._timeout = setTimeout(function() {
            self._operationTimeoutCb(self._attempts);
          }, self._operationTimeout);
          if (self._options.unref) {
            self._timeout.unref();
          }
        }
        self._fn(self._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self._operationTimeoutCb();
        }, self._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  });
  var require_retry = __commonJS((exports2) => {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random2 = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random2 * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  });
  var require_retry2 = __commonJS((exports2, module2) => {
    module2.exports = require_retry();
  });
  var require_p_retry = __commonJS((exports2, module2) => {
    "use strict";
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      "NetworkError when attempting to fetch resource",
      "The Internet connection appears to be offline"
    ];
    var AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({message} = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    var pRetry = (input, options) => new Promise((resolve, reject) => {
      options = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options
      };
      const operation = retry.operation(options);
      operation.attempt(async (attemptNumber) => {
        try {
          resolve(await input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              await options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      });
    });
    module2.exports = pRetry;
    module2.exports.default = pRetry;
    module2.exports.AbortError = AbortError;
  });
  var require_lib = __commonJS((exports2) => {
    __markAsModule(exports2);
    __export(exports2, {
      FetchError: () => FetchError,
      Headers: () => Headers,
      Request: () => Request,
      Response: () => Response,
      default: () => lib_default
    });
    var import_stream = __toModule(require("stream"));
    var import_http = __toModule(require("http"));
    var import_url = __toModule(require("url"));
    var import_https = __toModule(require("https"));
    var import_zlib = __toModule(require("zlib"));
    var Readable = import_stream.default.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob = class {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], {type: arguments[2]});
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: {enumerable: true},
      type: {enumerable: true},
      slice: {enumerable: true}
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = import_stream.default.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof import_stream.default)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof import_stream.default) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(new Blob([], {
            type: ct.toLowerCase()
          }), {
            [BUFFER]: buf
          });
        });
      },
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      buffer() {
        return consumeBody.call(this);
      },
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: {enumerable: true},
      bodyUsed: {enumerable: true},
      arrayBuffer: {enumerable: true},
      blob: {enumerable: true},
      json: {enumerable: true},
      text: {enumerable: true}
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof import_stream.default)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone2(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof import_stream.default) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class {
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = Object.create(null);
        if (init instanceof Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      raw() {
        return this[MAP];
      }
      keys() {
        return createHeadersIterator(this, "key");
      }
      values() {
        return createHeadersIterator(this, "value");
      }
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: {enumerable: true},
      forEach: {enumerable: true},
      set: {enumerable: true},
      append: {enumerable: true},
      has: {enumerable: true},
      delete: {enumerable: true},
      keys: {enumerable: true},
      values: {enumerable: true},
      entries: {enumerable: true}
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys2 = Object.keys(headers[MAP]).sort();
      return keys2.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({__proto__: null}, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = import_http.default.STATUS_CODES;
    var Response = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      clone() {
        return new Response(clone2(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: {enumerable: true},
      status: {enumerable: true},
      ok: {enumerable: true},
      redirected: {enumerable: true},
      statusText: {enumerable: true},
      headers: {enumerable: true},
      clone: {enumerable: true}
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var parse_url = import_url.default.parse;
    var format_url = import_url.default.format;
    var streamDestructionSupported = "destroy" in import_stream.default.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parse_url(input.href);
          } else {
            parsedURL = parse_url(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parse_url(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone2(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      clone() {
        return new Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: {enumerable: true},
      url: {enumerable: true},
      headers: {enumerable: true},
      redirect: {enumerable: true},
      clone: {enumerable: true},
      signal: {enumerable: true}
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof import_stream.default.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var PassThrough$1 = import_stream.default.PassThrough;
    var resolve_url = import_url.default.resolve;
    function fetch(url, opts) {
      if (!fetch.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch.Promise;
      return new fetch.Promise(function(resolve, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof import_stream.default.Readable) {
            request.body.destroy(error);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            const locationURL = location === null ? null : resolve_url(request.url, location);
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: import_zlib.default.Z_SYNC_FLUSH,
            finishFlush: import_zlib.default.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw2 = res.pipe(new PassThrough$1());
            raw2.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(import_zlib.default.createInflate());
              } else {
                body = body.pipe(import_zlib.default.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve(response);
            });
            return;
          }
          if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
            body = body.pipe(import_zlib.default.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    fetch.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch.Promise = global.Promise;
    var lib_default = fetch;
  });
  var require_common3 = __commonJS((exports2, module2) => {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug32(...args) {
          if (!debug32.enabled) {
            return;
          }
          const self = debug32;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug32.namespace = namespace;
        debug32.useColors = createDebug.useColors();
        debug32.color = createDebug.selectColor(namespace);
        debug32.extend = extend;
        debug32.destroy = createDebug.destroy;
        Object.defineProperty(debug32, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug32);
        }
        return debug32;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  });
  var require_browser = __commonJS((exports2, module2) => {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports2);
    var {formatters} = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  });
  var require_node2 = __commonJS((exports2, module2) => {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log4;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const {namespace: name, useColors: useColors2} = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log4(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug32) {
      debug32.inspectOpts = {};
      const keys2 = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug32.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
      }
    }
    module2.exports = require_common3()(exports2);
    var {formatters} = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  });
  var require_src = __commonJS((exports2, module2) => {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  });
  var require_promisify = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  });
  var require_src2 = __commonJS((exports2, module2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    var events_12 = require("events");
    var debug_12 = __importDefault2(require_src());
    var promisify_1 = __importDefault2(require_promisify());
    var debug32 = debug_12.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const {stack} = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_12.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug32("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug32("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug32("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug32("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug32("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  });
  var require_parse_proxy_response = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var debug_12 = __importDefault2(require_src());
    var debug32 = debug_12.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug32("onclose had error %o", err);
        }
        function onend() {
          debug32("onend");
        }
        function onerror(err) {
          cleanup();
          debug32("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug32("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug32("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  });
  var require_agent = __commonJS((exports2) => {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var net_12 = __importDefault2(require("net"));
    var tls_1 = __importDefault2(require("tls"));
    var url_12 = __importDefault2(require("url"));
    var assert_1 = __importDefault2(require("assert"));
    var debug_12 = __importDefault2(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault2(require_parse_proxy_response());
    var debug32 = debug_12.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_12.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug32("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const {proxy, secureProxy} = this;
          let socket;
          if (secureProxy) {
            debug32("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug32("Creating `net.Socket`: %o", proxy);
            socket = net_12.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let {host, port, secureEndpoint} = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const {statusCode, buffered} = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              const servername = opts.servername || opts.host;
              if (!servername) {
                throw new Error('Could not determine "servername"');
              }
              debug32("Upgrading socket connection to TLS");
              return tls_1.default.connect(Object.assign(Object.assign({}, omit2(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_12.default.Socket();
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug32("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit2(obj, ...keys2) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys2.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  });
  var require_dist3 = __commonJS((exports2, module2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    var agent_1 = __importDefault2(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  });
  var require_dist4 = __commonJS((exports2, module2) => {
    "use strict";
    function noop() {
    }
    function once(emitter, name) {
      const o = once.spread(emitter, name);
      const r = o.then((args) => args[0]);
      r.cancel = o.cancel;
      return r;
    }
    (function(once2) {
      function spread(emitter, name) {
        let c = null;
        const p = new Promise((resolve, reject) => {
          function cancel() {
            emitter.removeListener(name, onEvent);
            emitter.removeListener("error", onError);
            p.cancel = noop;
          }
          function onEvent(...args) {
            cancel();
            resolve(args);
          }
          function onError(err) {
            cancel();
            reject(err);
          }
          c = cancel;
          emitter.on(name, onEvent);
          emitter.on("error", onError);
        });
        if (!c) {
          throw new TypeError("Could not get `cancel()` function");
        }
        p.cancel = c;
        return p;
      }
      once2.spread = spread;
    })(once || (once = {}));
    module2.exports = once;
  });
  var require_agent2 = __commonJS((exports2) => {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    var net_12 = __importDefault2(require("net"));
    var tls_1 = __importDefault2(require("tls"));
    var url_12 = __importDefault2(require("url"));
    var debug_12 = __importDefault2(require_src());
    var once_1 = __importDefault2(require_dist4());
    var agent_base_1 = require_src2();
    var debug32 = debug_12.default("http-proxy-agent");
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    var HttpProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_12.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug32("Creating new HttpProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const {proxy, secureProxy} = this;
          const parsed = url_12.default.parse(req.path);
          if (!parsed.protocol) {
            parsed.protocol = "http:";
          }
          if (!parsed.hostname) {
            parsed.hostname = opts.hostname || opts.host || null;
          }
          if (parsed.port == null && typeof opts.port) {
            parsed.port = String(opts.port);
          }
          if (parsed.port === "80") {
            delete parsed.port;
          }
          req.path = url_12.default.format(parsed);
          if (proxy.auth) {
            req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
          }
          let socket;
          if (secureProxy) {
            debug32("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug32("Creating `net.Socket`: %o", proxy);
            socket = net_12.default.connect(proxy);
          }
          if (req._header) {
            let first;
            let endOfHeaders;
            debug32("Regenerating stored HTTP header string for request");
            req._header = null;
            req._implicitHeader();
            if (req.output && req.output.length > 0) {
              debug32("Patching connection write() output buffer with updated header");
              first = req.output[0];
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.output[0] = req._header + first.substring(endOfHeaders);
              debug32("Output buffer: %o", req.output);
            } else if (req.outputData && req.outputData.length > 0) {
              debug32("Patching connection write() output buffer with updated header");
              first = req.outputData[0].data;
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.outputData[0].data = req._header + first.substring(endOfHeaders);
              debug32("Output buffer: %o", req.outputData[0].data);
            }
          }
          yield once_1.default(socket, "connect");
          return socket;
        });
      }
    };
    exports2.default = HttpProxyAgent;
  });
  var require_dist5 = __commonJS((exports2, module2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    var agent_1 = __importDefault2(require_agent2());
    function createHttpProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpProxyAgent2) {
      createHttpProxyAgent2.HttpProxyAgent = agent_1.default;
      createHttpProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpProxyAgent || (createHttpProxyAgent = {}));
    module2.exports = createHttpProxyAgent;
  });
  var require_getProxyAgent = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getProxyAgent = void 0;
    var https_proxy_agent_1 = __importDefault2(require_dist3());
    var http_proxy_agent_1 = __importDefault2(require_dist5());
    var url_12 = __importDefault2(require("url"));
    function formatHostname(hostname) {
      return hostname.replace(/^\.*/, ".").toLowerCase();
    }
    function parseNoProxyZone(zone) {
      zone = zone.trim().toLowerCase();
      const zoneParts = zone.split(":", 2);
      const zoneHost = formatHostname(zoneParts[0]);
      const zonePort = zoneParts[1];
      const hasPort = zone.includes(":");
      return {hostname: zoneHost, port: zonePort, hasPort};
    }
    function uriInNoProxy(uri, noProxy) {
      const port = uri.port || (uri.protocol === "https:" ? "443" : "80");
      const hostname = formatHostname(uri.hostname);
      const noProxyList = noProxy.split(",");
      return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
        const isMatchedAt = hostname.indexOf(noProxyZone.hostname);
        const hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
        if (noProxyZone.hasPort) {
          return port === noProxyZone.port && hostnameMatched;
        }
        return hostnameMatched;
      });
    }
    function getProxyFromURI(uri) {
      const noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
      if (noProxy === "*") {
        return null;
      }
      if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
        return null;
      }
      if (uri.protocol === "http:") {
        return process.env.HTTP_PROXY || process.env.http_proxy || null;
      }
      if (uri.protocol === "https:") {
        return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
      }
      return null;
    }
    function getProxyAgent(url) {
      const uri = url_12.default.parse(url);
      const proxy = getProxyFromURI(uri);
      if (!proxy) {
        return void 0;
      }
      if (uri.protocol === "http:") {
        return http_proxy_agent_1.default(proxy);
      }
      if (uri.protocol === "https:") {
        return https_proxy_agent_1.default(proxy);
      }
      return void 0;
    }
    exports2.getProxyAgent = getProxyAgent;
  });
  var require_crypto_random_string = __commonJS((exports2, module2) => {
    "use strict";
    var crypto2 = require("crypto");
    module2.exports = (length) => {
      if (!Number.isFinite(length)) {
        throw new TypeError("Expected a finite number");
      }
      return crypto2.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
    };
  });
  var require_unique_string = __commonJS((exports2, module2) => {
    "use strict";
    var cryptoRandomString = require_crypto_random_string();
    module2.exports = () => cryptoRandomString(32);
  });
  var require_array_union = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (...arguments_) => {
      return [...new Set([].concat(...arguments_))];
    };
  });
  var require_merge2 = __commonJS((exports2, module2) => {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, {end: false});
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  });
  var require_array = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten2(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten2;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  });
  var require_errno = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  });
  var require_fs2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  });
  var require_path = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;
    var path2 = require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path2.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function escape(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escape = escape;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
  });
  var require_is_extglob = __commonJS((exports2, module2) => {
    /*!
     * is-extglob <https://github.com/jonschlinkert/is-extglob>
     *
     * Copyright (c) 2014-2016, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  });
  var require_is_glob = __commonJS((exports2, module2) => {
    /*!
     * is-glob <https://github.com/jonschlinkert/is-glob>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */
    var isExtglob = require_is_extglob();
    var chars = {"{": "}", "(": ")", "[": "]"};
    var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var regex = strictRegex;
      var match;
      if (options && options.strict === false) {
        regex = relaxedRegex;
      }
      while (match = regex.exec(str)) {
        if (match[2])
          return true;
        var idx = match.index + match[0].length;
        var open = match[1];
        var close = open ? chars[open] : null;
        if (open && close) {
          var n = str.indexOf(close, idx);
          if (n !== -1) {
            idx = n + 1;
          }
        }
        str = str.slice(idx);
      }
      return false;
    };
  });
  var require_glob_parent = __commonJS((exports2, module2) => {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({flipBackslashes: true}, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  });
  var require_utils = __commonJS((exports2) => {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min2, max2, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min2) || !exports2.isInteger(max2))
        return false;
      return (Number(max2) - Number(min2)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  });
  var require_stringify = __commonJS((exports2, module2) => {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      let stringify2 = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify2(child);
          }
        }
        return output;
      };
      return stringify2(ast);
    };
  });
  var require_is_number = __commonJS((exports2, module2) => {
    /*!
     * is-number <https://github.com/jonschlinkert/is-number>
     *
     * Copyright (c) 2014-present, Jon Schlinkert.
     * Released under the MIT License.
     */
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  });
  var require_to_regex_range = __commonJS((exports2, module2) => {
    /*!
     * to-regex-range <https://github.com/micromatch/to-regex-range>
     *
     * Copyright (c) 2015-present, Jon Schlinkert.
     * Released under the MIT License.
     */
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min2, max2, options) => {
      if (isNumber(min2) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max2 === void 0 || min2 === max2) {
        return String(min2);
      }
      if (isNumber(max2) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = {relaxZeros: true, ...options};
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min2 + ":" + max2 + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min2, max2);
      let b = Math.max(min2, max2);
      if (Math.abs(a - b) === 1) {
        let result = min2 + "|" + max2;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min2) || hasPadding(max2);
      let state = {min: min2, max: max2, a, b};
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min2, max2) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min2, nines);
      let stops = new Set([max2]);
      while (min2 <= stop && stop <= max2) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min2, nines);
      }
      stop = countZeros(max2 + 1, zeros) - 1;
      while (min2 < stop && stop <= max2) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max2 + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return {pattern: start, count: [], digits: 0};
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return {pattern, count: [count], digits};
    }
    function splitToPatterns(min2, max2, tok, options) {
      let ranges = splitToRanges(min2, max2);
      let tokens = [];
      let start = min2;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max22 = ranges[i];
        let obj = rangeToPattern(String(start), String(max22), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max22 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max22, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max22 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let {string} = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min2, len) {
      return Number(String(min2).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  });
  var require_fill_range = __commonJS((exports2, module2) => {
    /*!
     * fill-range <https://github.com/jonschlinkert/fill-range>
     *
     * Copyright (c) 2014-present, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify2 = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, {wrap: false, ...options});
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify2(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = {negatives: [], positives: []};
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, {wrap: false, ...options});
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min2 = Math.min(a, b);
      let max2 = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min2, max2, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, {wrap: false, options});
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, {transform: step});
      }
      if (isObject2(step)) {
        return fill(start, end, 0, step);
      }
      let opts = {...options};
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject2(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  });
  var require_compile = __commonJS((exports2, module2) => {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, {...options, wrap: false, toRegex: true});
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  });
  var require_expand = __commonJS((exports2, module2) => {
    "use strict";
    var fill = require_fill_range();
    var stringify2 = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify2(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify2(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  });
  var require_constants = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  });
  var require_parse2 = __commonJS((exports2, module2) => {
    "use strict";
    var stringify2 = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse2 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max2) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max2})`);
      }
      let ast = {type: "root", input, nodes: []};
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({type: "bos"});
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({type: "text", value: (options.keepEscaping ? value : "") + advance()});
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({type: "text", value: "\\" + value});
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({type: "text", value});
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({type: "paren", nodes: []});
          stack.push(block);
          push({type: "text", value});
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({type: "text", value});
            continue;
          }
          block = stack.pop();
          push({type: "text", value});
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({type: "text", value});
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({type: "open", value});
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({type: "text", value});
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({type, value});
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, {type: "text", value: stringify2(block)}];
          }
          push({type: "comma", value});
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({type: "text", value});
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({type: "dot", value});
          continue;
        }
        push({type: "text", value});
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({type: "eos"});
      return ast;
    };
    module2.exports = parse2;
  });
  var require_braces = __commonJS((exports2, module2) => {
    "use strict";
    var stringify2 = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse2 = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse2(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify2(braces.parse(input, options), options);
      }
      return stringify2(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  });
  var require_constants2 = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path2.sep,
      extglobChars(chars) {
        return {
          "!": {type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})`},
          "?": {type: "qmark", open: "(?:", close: ")?"},
          "+": {type: "plus", open: "(?:", close: ")+"},
          "*": {type: "star", open: "(?:", close: ")*"},
          "@": {type: "at", open: "(?:", close: ")"}
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  });
  var require_utils2 = __commonJS((exports2) => {
    "use strict";
    var path2 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path2.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  });
  var require_scan = __commonJS((exports2, module2) => {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = {value: "", depth: 0, isGlob: false};
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = {value: "", depth: 0, isGlob: false};
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
          }
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  });
  var require_parse3 = __commonJS((exports2, module2) => {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse2 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = {...options};
      const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max2) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
      }
      const bos = {type: "bos", value: "", output: opts.prepend || ""};
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index];
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren" && !EXTGLOB_CHARS[tok.value]) {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = {...EXTGLOB_CHARS[value2], conditions: 1, inner: ""};
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({type, value: value2, output: state.output ? "" : ONE_CHAR});
        push({type: "paren", extglob: true, value: advance(), output});
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.prev.type === "bos" && eos()) {
            state.negatedExtglob = true;
          }
        }
        push({type: "paren", extglob: true, value, output});
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({type: "text", value});
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance() || "";
          } else {
            value += advance() || "";
          }
          if (state.brackets === 0) {
            push({type: "text", value});
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({value});
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({value});
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({type: "text", value});
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({type: "paren", value});
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({type: "paren", value, output: state.parens ? ")" : "\\)"});
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({type: "bracket", value});
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({type: "text", value, output: `\\${value}`});
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({type: "text", value, output: `\\${value}`});
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({value});
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({type: "text", value, output: value});
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({type: "brace", value, output});
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({type: "text", value});
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({type: "comma", value, output});
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({type: "slash", value, output: SLASH_LITERAL});
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({type: "text", value, output: DOT_LITERAL});
            continue;
          }
          push({type: "dot", value, output: DOT_LITERAL});
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({type: "text", value, output});
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({type: "qmark", value, output: QMARK_NO_DOT});
            continue;
          }
          push({type: "qmark", value, output: QMARK});
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({type: "plus", value, output: PLUS_LITERAL});
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({type: "plus", value});
            continue;
          }
          push({type: "plus", value: PLUS_LITERAL});
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({type: "at", extglob: true, value, output: ""});
            continue;
          }
          push({type: "text", value});
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({type: "text", value});
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({type: "star", value, output: ""});
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({type: "star", value, output: ""});
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({type: "slash", value: "/", output: ""});
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({type: "slash", value: "/", output: ""});
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = {type: "star", value, output: star};
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?`});
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse2.fastpaths = (input, options) => {
      const opts = {...options};
      const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max2) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = {negated: false, prefix: ""};
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse2;
  });
  var require_picomatch = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var scan = require_scan();
    var parse2 = require_parse3();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject2(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = {...options, ignore: null, onMatch: null, onResult: null};
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const {isMatch, match, output} = picomatch.test(input, regex, options, {glob, posix});
        const result = {glob, state, regex, posix, input, output, match, isMatch};
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, {glob, posix} = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return {isMatch: false, output: ""};
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return {isMatch: Boolean(match), match, output};
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path2.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse2(pattern, {...options, fastpaths: false});
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return parsed.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${parsed.output})${append}`;
      if (parsed && parsed.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = parsed;
      }
      return regex;
    };
    picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      const opts = options || {};
      let parsed = {negated: false, fastpaths: true};
      let prefix = "";
      let output;
      if (input.startsWith("./")) {
        input = input.slice(2);
        prefix = parsed.prefix = "./";
      }
      if (opts.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        output = parse2.fastpaths(input, options);
      }
      if (output === void 0) {
        parsed = parse2(input, options);
        parsed.prefix = prefix + (parsed.prefix || "");
      } else {
        parsed.output = output;
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  });
  var require_picomatch2 = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = require_picomatch();
  });
  var require_micromatch = __commonJS((exports2, module2) => {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => typeof val === "string" && (val === "" || val === "./");
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit2 = new Set();
      let keep = new Set();
      let items = new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), {...options, onResult}, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit2.add(matched.output);
          } else {
            omit2.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit2.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = micromatch(list, patterns, {...options, onResult});
      for (let item of items) {
        if (!matches.includes(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, {...options, contains: true});
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys2 = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys2)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), {...options, capture: true});
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, {...options, expand: true});
    };
    module2.exports = micromatch;
  });
  var require_pattern = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path2 = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var picomatch = require_picomatch2();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
    var BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern;
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getBaseDirectory(pattern) {
      return globParent(pattern, {flipBackslashes: false});
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path2.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let {parts} = picomatch.scan(pattern, Object.assign(Object.assign({}, options), {parts: true}));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
  });
  var require_stream2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  });
  var require_string = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.isEmpty = exports2.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  });
  var require_utils3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs2 = require_fs2();
    exports2.fs = fs2;
    var path2 = require_path();
    exports2.path = path2;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream2();
    exports2.stream = stream;
    var string = require_string();
    exports2.string = string;
  });
  var require_tasks = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils3();
    function generate(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const positivePatternsGroup = groupPatternsByBaseDirectory(positive);
      if ("." in positivePatternsGroup) {
        const task = convertPatternGroupToTask(".", positive, negative, dynamic);
        return [task];
      }
      return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  });
  var require_async = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.read = void 0;
    function read(path2, settings, callback) {
      settings.fs.lstat(path2, (lstatError, lstat) => {
        if (lstatError !== null) {
          return callFailureCallback(callback, lstatError);
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          return callSuccessCallback(callback, lstat);
        }
        settings.fs.stat(path2, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              return callFailureCallback(callback, statError);
            }
            return callSuccessCallback(callback, lstat);
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  });
  var require_sync2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.read = void 0;
    function read(path2, settings) {
      const lstat = settings.fs.lstatSync(path2);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path2);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports2.read = read;
  });
  var require_fs3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      stat: fs2.stat,
      lstatSync: fs2.lstatSync,
      statSync: fs2.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  });
  var require_settings = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fs2 = require_fs3();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs2.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  });
  var require_out = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async();
    var sync = require_sync2();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path2, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        return async.read(path2, getSettings(), optionsOrSettingsOrCallback);
      }
      async.read(path2, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync(path2, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path2, settings);
    }
    exports2.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  });
  var require_queue_microtask = __commonJS((exports2, module2) => {
    /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  });
  var require_run_parallel = __commonJS((exports2, module2) => {
    /*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys2;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys2 = Object.keys(tasks);
        results = {};
        pending = keys2.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys2) {
        keys2.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  });
  var require_constants3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    var MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  });
  var require_fs4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  });
  var require_utils4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.fs = void 0;
    var fs2 = require_fs4();
    exports2.fs = fs2;
  });
  var require_common4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  });
  var require_async2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common4();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings, callback);
      }
      return readdir(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, {withFileTypes: true}, (readdirError, dirents) => {
        if (readdirError !== null) {
          return callFailureCallback(callback, readdirError);
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          return callSuccessCallback(callback, entries);
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            return callFailureCallback(callback, rplError);
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          return done(null, entry);
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              return done(statError);
            }
            return done(null, entry);
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          return done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          return callFailureCallback(callback, readdirError);
        }
        const filepaths = names.map((name) => common.joinPathSegments(directory, name, settings.pathSegmentSeparator));
        const tasks = filepaths.map((filepath) => {
          return (done) => fsStat.stat(filepath, settings.fsStatSettings, done);
        });
        rpl(tasks, (rplError, results) => {
          if (rplError !== null) {
            return callFailureCallback(callback, rplError);
          }
          const entries = [];
          names.forEach((name, index) => {
            const stats = results[index];
            const entry = {
              name,
              path: filepaths[index],
              dirent: utils.fs.createDirentFromStats(name, stats)
            };
            if (settings.stats) {
              entry.stats = stats;
            }
            entries.push(entry);
          });
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  });
  var require_sync3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common4();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, {withFileTypes: true});
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir;
  });
  var require_fs5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      stat: fs2.stat,
      lstatSync: fs2.lstatSync,
      statSync: fs2.statSync,
      readdir: fs2.readdir,
      readdirSync: fs2.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  });
  var require_settings2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path2 = require("path");
    var fsStat = require_out();
    var fs2 = require_fs5();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs2.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path2.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  });
  var require_out2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2();
    var sync = require_sync3();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path2, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        return async.read(path2, getSettings(), optionsOrSettingsOrCallback);
      }
      async.read(path2, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path2, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path2, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  });
  var require_reusify = __commonJS((exports2, module2) => {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  });
  var require_queue = __commonJS((exports2, module2) => {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self;
      function running() {
        return _running;
      }
      function pause() {
        self.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self.paused)
          return;
        self.paused = false;
        for (var i = 0; i < self.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self.concurrency || self.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self.concurrency || self.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self.drain();
        self.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self = this;
      this.worked = function worked(err, result) {
        var callback = self.callback;
        var errorHandler = self.errorHandler;
        var val = self.value;
        self.value = null;
        self.callback = noop;
        if (self.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self.context, err, result);
        self.release(self);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      return queue;
      function push(value) {
        return new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
      }
      function unshift(value) {
        return new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  });
  var require_common5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  });
  var require_reader = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var common = require_common5();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  });
  var require_async3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var events_12 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common5();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_12.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = {directory, base};
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            return done(error, void 0);
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  });
  var require_async4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = new Set();
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.add(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, [...this._storage]);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  });
  var require_stream3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  });
  var require_sync4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fsScandir = require_out2();
    var common = require_common5();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = new Set();
        this._queue = new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return [...this._storage];
      }
      _pushToQueue(directory, base) {
        this._queue.add({directory, base});
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.add(entry);
      }
    };
    exports2.default = SyncReader;
  });
  var require_sync5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var sync_1 = require_sync4();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  });
  var require_settings3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path2 = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Infinity);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path2.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  });
  var require_out3 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream3();
    var sync_1 = require_sync5();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        return new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  });
  var require_reader2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path2 = require("path");
    var fsStat = require_out();
    var utils = require_utils3();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path2.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  });
  var require_stream4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({objectMode: true});
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  });
  var require_matcher = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  });
  var require_partial = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  });
  var require_deep = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  });
  var require_entry = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe);
      }
    };
    exports2.default = EntryFilter;
  });
  var require_error2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  });
  var require_entry2 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var utils = require_utils3();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), {path: filepath});
      }
    };
    exports2.default = EntryTransformer;
  });
  var require_provider = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var path2 = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error2();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path2.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  });
  var require_async5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require_stream4();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
          const stream = this.api(root, task, options);
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(options.transform(entry)));
          stream.once("end", () => resolve(entries));
        });
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  });
  var require_stream5 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var stream_1 = require("stream");
    var stream_2 = require_stream4();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({objectMode: true, read: () => {
        }});
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  });
  var require_sync6 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  });
  var require_sync7 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    var sync_1 = require_sync6();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  });
  var require_settings4 = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      lstatSync: fs2.lstatSync,
      stat: fs2.stat,
      statSync: fs2.statSync,
      readdir: fs2.readdir,
      readdirSync: fs2.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  });
  var require_out4 = __commonJS((exports2, module2) => {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async5();
    var stream_1 = require_stream5();
    var sync_1 = require_sync7();
    var settings_1 = require_settings4();
    var utils = require_utils3();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  });
  var require_path_type = __commonJS((exports2) => {
    "use strict";
    var {promisify} = require("util");
    var fs2 = require("fs");
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify(fs2[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs2[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    exports2.isFile = isType.bind(null, "stat", "isFile");
    exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  });
  var require_dir_glob = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    var pathType = require_path_type();
    var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
    var getPath = (filepath, cwd) => {
      const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path2.isAbsolute(pth) ? pth : path2.join(cwd, pth);
    };
    var addExtensions = (file, extensions) => {
      if (path2.extname(file)) {
        return `**/${file}`;
      }
      return `**/${file}.${getExtensions(extensions)}`;
    };
    var getGlob = (directory, options) => {
      if (options.files && !Array.isArray(options.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
      }
      if (options.extensions && !Array.isArray(options.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
      }
      if (options.files && options.extensions) {
        return options.files.map((x) => path2.posix.join(directory, addExtensions(x, options.extensions)));
      }
      if (options.files) {
        return options.files.map((x) => path2.posix.join(directory, `**/${x}`));
      }
      if (options.extensions) {
        return [path2.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
      }
      return [path2.posix.join(directory, "**")];
    };
    module2.exports = async (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = await Promise.all([].concat(input).map(async (x) => {
        const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
        return isDirectory ? getGlob(x, options) : x;
      }));
      return [].concat.apply([], globs);
    };
    module2.exports.sync = (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
      return [].concat.apply([], globs);
    };
  });
  var require_ignore = __commonJS((exports2, module2) => {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
    var define = (object, key, value) => Object.defineProperty(object, key, {value});
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
    var cleanRangeBackSlash = (slashes) => {
      const {length} = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      [
        /\\\s/g,
        () => SPACE
      ],
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      [
        /^\//,
        () => "^"
      ],
      [
        /\//g,
        () => "\\/"
      ],
      [
        /^\^*\\\*\\\*\\\//,
        () => "^(?:.*\\/)?"
      ],
      [
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      [
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      [
        /(^|[^\\]+)\\\*(?=.+)/g,
        (_, p1) => `${p1}[^\\/]*`
      ],
      [
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        /\\\\/g,
        () => ESCAPE
      ],
      [
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      [
        /(?:[^*])$/,
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = Object.create(null);
    var makeRegex = (pattern, negative, ignorecase) => {
      const r = regexCache[pattern];
      if (r) {
        return r;
      }
      const source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
      return regexCache[pattern] = ignorecase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignorecase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, negative, ignorecase);
      return new IgnoreRule(origin, pattern, negative, regex);
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path2, originalPath, doThrow) => {
      if (!isString(path2)) {
        return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
      }
      if (!path2) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path2)) {
        const r = "`path.relative()`d";
        return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
      }
      return true;
    };
    var isNotRelative = (path2) => REGEX_TEST_INVALID_PATH.test(path2);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true
      } = {}) {
        this._rules = [];
        this._ignorecase = ignorecase;
        define(this, KEY_IGNORE, true);
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = Object.create(null);
        this._testCache = Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignorecase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      add(pattern) {
        this._added = false;
        makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      addPattern(pattern) {
        return this.add(pattern);
      }
      _testOne(path2, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const {negative} = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path2);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      _test(originalPath, cache, checkUnignored, slices) {
        const path2 = originalPath && checkPath.convert(originalPath);
        checkPath(path2, originalPath, throwError);
        return this._t(path2, cache, checkUnignored, slices);
      }
      _t(path2, cache, checkUnignored, slices) {
        if (path2 in cache) {
          return cache[path2];
        }
        if (!slices) {
          slices = path2.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path2] = this._testOne(path2, checkUnignored);
        }
        const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
        return cache[path2] = parent.ignored ? parent : this._testOne(path2, checkUnignored);
      }
      ignores(path2) {
        return this._test(path2, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path2) => !this.ignores(path2);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      test(path2) {
        return this._test(path2, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var returnFalse = () => false;
    var isPathValid = (path2) => checkPath(path2 && checkPath.convert(path2), path2, returnFalse);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path2) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path2) || isNotRelative(path2);
    }
  });
  var require_slash = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = (path2) => {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path2);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(path2);
      if (isExtendedLengthPath || hasNonAscii) {
        return path2;
      }
      return path2.replace(/\\/g, "/");
    };
  });
  var require_gitignore = __commonJS((exports2, module2) => {
    "use strict";
    var {promisify} = require("util");
    var fs2 = require("fs");
    var path2 = require("path");
    var fastGlob = require_out4();
    var gitIgnore = require_ignore();
    var slash = require_slash();
    var DEFAULT_IGNORE = [
      "**/node_modules/**",
      "**/flow-typed/**",
      "**/coverage/**",
      "**/.git"
    ];
    var readFileP = promisify(fs2.readFile);
    var mapGitIgnorePatternTo = (base) => (ignore) => {
      if (ignore.startsWith("!")) {
        return "!" + path2.posix.join(base, ignore.slice(1));
      }
      return path2.posix.join(base, ignore);
    };
    var parseGitIgnore = (content, options) => {
      const base = slash(path2.relative(options.cwd, path2.dirname(options.fileName)));
      return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
    };
    var reduceIgnore = (files) => {
      const ignores = gitIgnore();
      for (const file of files) {
        ignores.add(parseGitIgnore(file.content, {
          cwd: file.cwd,
          fileName: file.filePath
        }));
      }
      return ignores;
    };
    var ensureAbsolutePathForCwd = (cwd, p) => {
      cwd = slash(cwd);
      if (path2.isAbsolute(p)) {
        if (p.startsWith(cwd)) {
          return p;
        }
        throw new Error(`Path ${p} is not in cwd ${cwd}`);
      }
      return path2.join(cwd, p);
    };
    var getIsIgnoredPredecate = (ignores, cwd) => {
      return (p) => ignores.ignores(slash(path2.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));
    };
    var getFile = async (file, cwd) => {
      const filePath = path2.join(cwd, file);
      const content = await readFileP(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var getFileSync = (file, cwd) => {
      const filePath = path2.join(cwd, file);
      const content = fs2.readFileSync(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var normalizeOptions = ({
      ignore = [],
      cwd = slash(process.cwd())
    } = {}) => {
      return {ignore, cwd};
    };
    module2.exports = async (options) => {
      options = normalizeOptions(options);
      const paths = await fastGlob("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = await Promise.all(paths.map((file) => getFile(file, options.cwd)));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
    module2.exports.sync = (options) => {
      options = normalizeOptions(options);
      const paths = fastGlob.sync("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = paths.map((file) => getFileSync(file, options.cwd));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
  });
  var require_stream_utils = __commonJS((exports2, module2) => {
    "use strict";
    var {Transform} = require("stream");
    var ObjectTransform = class extends Transform {
      constructor() {
        super({
          objectMode: true
        });
      }
    };
    var FilterStream = class extends ObjectTransform {
      constructor(filter) {
        super();
        this._filter = filter;
      }
      _transform(data, encoding, callback) {
        if (this._filter(data)) {
          this.push(data);
        }
        callback();
      }
    };
    var UniqueStream = class extends ObjectTransform {
      constructor() {
        super();
        this._pushed = new Set();
      }
      _transform(data, encoding, callback) {
        if (!this._pushed.has(data)) {
          this.push(data);
          this._pushed.add(data);
        }
        callback();
      }
    };
    module2.exports = {
      FilterStream,
      UniqueStream
    };
  });
  var require_globby = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var arrayUnion = require_array_union();
    var merge2 = require_merge2();
    var fastGlob = require_out4();
    var dirGlob = require_dir_glob();
    var gitignore = require_gitignore();
    var {FilterStream, UniqueStream} = require_stream_utils();
    var DEFAULT_FILTER = () => false;
    var isNegative = (pattern) => pattern[0] === "!";
    var assertPatternsInput = (patterns) => {
      if (!patterns.every((pattern) => typeof pattern === "string")) {
        throw new TypeError("Patterns must be a string or an array of strings");
      }
    };
    var checkCwdOption = (options = {}) => {
      if (!options.cwd) {
        return;
      }
      let stat;
      try {
        stat = fs2.statSync(options.cwd);
      } catch (e) {
        return;
      }
      if (!stat.isDirectory()) {
        throw new Error("The `cwd` option must be a path to a directory");
      }
    };
    var getPathString = (p) => p.stats instanceof fs2.Stats ? p.path : p;
    var generateGlobTasks = (patterns, taskOptions) => {
      patterns = arrayUnion([].concat(patterns));
      assertPatternsInput(patterns);
      checkCwdOption(taskOptions);
      const globTasks = [];
      taskOptions = {
        ignore: [],
        expandDirectories: true,
        ...taskOptions
      };
      for (const [index, pattern] of patterns.entries()) {
        if (isNegative(pattern)) {
          continue;
        }
        const ignore = patterns.slice(index).filter((pattern2) => isNegative(pattern2)).map((pattern2) => pattern2.slice(1));
        const options = {
          ...taskOptions,
          ignore: taskOptions.ignore.concat(ignore)
        };
        globTasks.push({pattern, options});
      }
      return globTasks;
    };
    var globDirs = (task, fn) => {
      let options = {};
      if (task.options.cwd) {
        options.cwd = task.options.cwd;
      }
      if (Array.isArray(task.options.expandDirectories)) {
        options = {
          ...options,
          files: task.options.expandDirectories
        };
      } else if (typeof task.options.expandDirectories === "object") {
        options = {
          ...options,
          ...task.options.expandDirectories
        };
      }
      return fn(task.pattern, options);
    };
    var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];
    var getFilterSync = (options) => {
      return options && options.gitignore ? gitignore.sync({cwd: options.cwd, ignore: options.ignore}) : DEFAULT_FILTER;
    };
    var globToTask = (task) => (glob) => {
      const {options} = task;
      if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
        options.ignore = dirGlob.sync(options.ignore);
      }
      return {
        pattern: glob,
        options
      };
    };
    module2.exports = async (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const getFilter = async () => {
        return options && options.gitignore ? gitignore({cwd: options.cwd, ignore: options.ignore}) : DEFAULT_FILTER;
      };
      const getTasks = async () => {
        const tasks2 = await Promise.all(globTasks.map(async (task) => {
          const globs = await getPattern(task, dirGlob);
          return Promise.all(globs.map(globToTask(task)));
        }));
        return arrayUnion(...tasks2);
      };
      const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
      const paths = await Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));
      return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
    };
    module2.exports.sync = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
      }
      const filter = getFilterSync(options);
      let matches = [];
      for (const task of tasks) {
        matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
      }
      return matches.filter((path_) => !filter(path_));
    };
    module2.exports.stream = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
      }
      const filter = getFilterSync(options);
      const filterStream = new FilterStream((p) => !filter(p));
      const uniqueStream = new UniqueStream();
      return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
    };
    module2.exports.generateGlobTasks = generateGlobTasks;
    module2.exports.hasMagic = (patterns, options) => [].concat(patterns).some((pattern) => fastGlob.isDynamicPattern(pattern, options));
    module2.exports.gitignore = gitignore;
  });
  var require_polyfills = __commonJS((exports2, module2) => {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (!fs2.lchmod) {
        fs2.lchmod = function(path2, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (!fs2.lchown) {
        fs2.lchown = function(path2, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs2.rename = function(fs$rename) {
          return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs2.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          };
        }(fs2.rename);
      }
      fs2.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs2.read);
      fs2.readSync = function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
      function patchLchmod(fs22) {
        fs22.lchmod = function(path2, mode, callback) {
          fs22.open(path2, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs22.fchmod(fd, mode, function(err2) {
              fs22.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs22.lchmodSync = function(path2, mode) {
          var fd = fs22.openSync(path2, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs22.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs22.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs22.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs22) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs22.lutimes = function(path2, at, mt, cb) {
            fs22.open(path2, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs22.futimes(fd, at, mt, function(er2) {
                fs22.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs22.lutimesSync = function(path2, at, mt) {
            var fd = fs22.openSync(path2, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs22.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs22.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs22.closeSync(fd);
              }
            }
            return ret;
          };
        } else {
          fs22.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs22.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs2, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  });
  var require_legacy_streams = __commonJS((exports2, module2) => {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path2, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path2, options);
        Stream.call(this);
        var self = this;
        this.path = path2;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys2 = Object.keys(options);
        for (var index = 0, length = keys2.length; index < length; index++) {
          var key = keys2[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path2, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path2, options);
        Stream.call(this);
        this.path = path2;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys2 = Object.keys(options);
        for (var index = 0, length = keys2.length; index < length; index++) {
          var key = keys2[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  });
  var require_clone = __commonJS((exports2, module2) => {
    "use strict";
    module2.exports = clone2;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone2(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = {__proto__: getPrototypeOf(obj)};
      else
        var copy = Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  });
  var require_graceful_fs = __commonJS((exports2, module2) => {
    var fs2 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone2 = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug32 = noop;
    if (util.debuglog)
      debug32 = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug32 = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs2[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs2, queue);
      fs2.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs2, fd, function(err) {
            if (!err) {
              retry();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs2.close);
      fs2.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs2, arguments);
          retry();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs2.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug32(fs2[gracefulQueue]);
          require("assert").equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs2[gracefulQueue]);
    }
    module2.exports = patch(clone2(fs2));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module2.exports = patch(fs2);
      fs2.__patched = true;
    }
    function patch(fs22) {
      polyfills(fs22);
      fs22.gracefulify = patch;
      fs22.createReadStream = createReadStream;
      fs22.createWriteStream = createWriteStream;
      var fs$readFile = fs22.readFile;
      fs22.readFile = readFile2;
      function readFile2(path2, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path2, options, cb);
        function go$readFile(path3, options2, cb2) {
          return fs$readFile(path3, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path3, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$writeFile = fs22.writeFile;
      fs22.writeFile = writeFile2;
      function writeFile2(path2, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path2, data, options, cb);
        function go$writeFile(path3, data2, options2, cb2) {
          return fs$writeFile(path3, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path3, data2, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$appendFile = fs22.appendFile;
      if (fs$appendFile)
        fs22.appendFile = appendFile;
      function appendFile(path2, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path2, data, options, cb);
        function go$appendFile(path3, data2, options2, cb2) {
          return fs$appendFile(path3, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path3, data2, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$copyFile = fs22.copyFile;
      if (fs$copyFile)
        fs22.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return fs$copyFile(src, dest, flags, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([fs$copyFile, [src, dest, flags, cb]]);
          else {
            if (typeof cb === "function")
              cb.apply(this, arguments);
            retry();
          }
        });
      }
      var fs$readdir = fs22.readdir;
      fs22.readdir = readdir;
      function readdir(path2, options, cb) {
        var args = [path2];
        if (typeof options !== "function") {
          args.push(options);
        } else {
          cb = options;
        }
        args.push(go$readdir$cb);
        return go$readdir(args);
        function go$readdir$cb(err, files) {
          if (files && files.sort)
            files.sort();
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readdir, [args]]);
          else {
            if (typeof cb === "function")
              cb.apply(this, arguments);
            retry();
          }
        }
      }
      function go$readdir(args) {
        return fs$readdir.apply(fs22, args);
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs22);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs22.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs22.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs22, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs22, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs22, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs22, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path2, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path2, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path2, options) {
        return new fs22.ReadStream(path2, options);
      }
      function createWriteStream(path2, options) {
        return new fs22.WriteStream(path2, options);
      }
      var fs$open = fs22.open;
      fs22.open = open;
      function open(path2, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path2, flags, mode, cb);
        function go$open(path3, flags2, mode2, cb2) {
          return fs$open(path3, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path3, flags2, mode2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      return fs22;
    }
    function enqueue(elem) {
      debug32("ENQUEUE", elem[0].name, elem[1]);
      fs2[gracefulQueue].push(elem);
    }
    function retry() {
      var elem = fs2[gracefulQueue].shift();
      if (elem) {
        debug32("RETRY", elem[0].name, elem[1]);
        elem[0].apply(null, elem[1]);
      }
    }
  });
  var require_is_path_cwd = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    module2.exports = (path_) => {
      let cwd = process.cwd();
      path_ = path2.resolve(path_);
      if (process.platform === "win32") {
        cwd = cwd.toLowerCase();
        path_ = path_.toLowerCase();
      }
      return path_ === cwd;
    };
  });
  var require_is_path_inside = __commonJS((exports2, module2) => {
    "use strict";
    var path2 = require("path");
    module2.exports = (childPath, parentPath) => {
      const relation = path2.relative(parentPath, childPath);
      return Boolean(relation && relation !== ".." && !relation.startsWith(`..${path2.sep}`) && relation !== path2.resolve(childPath));
    };
  });
  var require_del = __commonJS((exports2, module2) => {
    "use strict";
    var {promisify} = require("util");
    var path2 = require("path");
    var globby = require_globby();
    var isGlob = require_is_glob();
    var slash = require_slash();
    var gracefulFs = require_graceful_fs();
    var isPathCwd = require_is_path_cwd();
    var isPathInside = require_is_path_inside();
    var rimraf = require_rimraf();
    var pMap = require_p_map();
    var rimrafP = promisify(rimraf);
    var rimrafOptions = {
      glob: false,
      unlink: gracefulFs.unlink,
      unlinkSync: gracefulFs.unlinkSync,
      chmod: gracefulFs.chmod,
      chmodSync: gracefulFs.chmodSync,
      stat: gracefulFs.stat,
      statSync: gracefulFs.statSync,
      lstat: gracefulFs.lstat,
      lstatSync: gracefulFs.lstatSync,
      rmdir: gracefulFs.rmdir,
      rmdirSync: gracefulFs.rmdirSync,
      readdir: gracefulFs.readdir,
      readdirSync: gracefulFs.readdirSync
    };
    function safeCheck(file, cwd) {
      if (isPathCwd(file)) {
        throw new Error("Cannot delete the current working directory. Can be overridden with the `force` option.");
      }
      if (!isPathInside(file, cwd)) {
        throw new Error("Cannot delete files/directories outside the current working directory. Can be overridden with the `force` option.");
      }
    }
    function normalizePatterns(patterns) {
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      patterns = patterns.map((pattern) => {
        if (process.platform === "win32" && isGlob(pattern) === false) {
          return slash(pattern);
        }
        return pattern;
      });
      return patterns;
    }
    module2.exports = async (patterns, {force, dryRun, cwd = process.cwd(), ...options} = {}) => {
      options = {
        expandDirectories: false,
        onlyFiles: false,
        followSymbolicLinks: false,
        cwd,
        ...options
      };
      patterns = normalizePatterns(patterns);
      const files = (await globby(patterns, options)).sort((a, b) => b.localeCompare(a));
      const mapper = async (file) => {
        file = path2.resolve(cwd, file);
        if (!force) {
          safeCheck(file, cwd);
        }
        if (!dryRun) {
          await rimrafP(file, rimrafOptions);
        }
        return file;
      };
      const removedFiles = await pMap(files, mapper, options);
      removedFiles.sort((a, b) => a.localeCompare(b));
      return removedFiles;
    };
    module2.exports.sync = (patterns, {force, dryRun, cwd = process.cwd(), ...options} = {}) => {
      options = {
        expandDirectories: false,
        onlyFiles: false,
        followSymbolicLinks: false,
        cwd,
        ...options
      };
      patterns = normalizePatterns(patterns);
      const files = globby.sync(patterns, options).sort((a, b) => b.localeCompare(a));
      const removedFiles = files.map((file) => {
        file = path2.resolve(cwd, file);
        if (!force) {
          safeCheck(file, cwd);
        }
        if (!dryRun) {
          rimraf.sync(file, rimrafOptions);
        }
        return file;
      });
      removedFiles.sort((a, b) => a.localeCompare(b));
      return removedFiles;
    };
  });
  var require_tempy = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var path2 = require("path");
    var uniqueString = require_unique_string();
    var tempDir = require_temp_dir();
    var isStream = require_is_stream();
    var del = require_del();
    var stream = require("stream");
    var {promisify} = require("util");
    var pipeline = promisify(stream.pipeline);
    var {writeFile: writeFile2} = fs2.promises;
    var getPath = (prefix = "") => path2.join(tempDir, prefix + uniqueString());
    var writeStream = async (filePath, data) => pipeline(data, fs2.createWriteStream(filePath));
    var createTask = (tempyFunction, {extraArguments = 0} = {}) => async (...arguments_) => {
      const [callback, options] = arguments_.slice(extraArguments);
      const result = await tempyFunction(...arguments_.slice(0, extraArguments), options);
      const returnValue = await callback(result);
      await del(result, {force: true});
      return returnValue;
    };
    module2.exports.file = (options) => {
      options = {
        ...options
      };
      if (options.name) {
        if (options.extension !== void 0 && options.extension !== null) {
          throw new Error("The `name` and `extension` options are mutually exclusive");
        }
        return path2.join(module2.exports.directory(), options.name);
      }
      return getPath() + (options.extension === void 0 || options.extension === null ? "" : "." + options.extension.replace(/^\./, ""));
    };
    module2.exports.file.task = createTask(module2.exports.file);
    module2.exports.directory = ({prefix = ""} = {}) => {
      const directory = getPath(prefix);
      fs2.mkdirSync(directory);
      return directory;
    };
    module2.exports.directory.task = createTask(module2.exports.directory);
    module2.exports.write = async (data, options) => {
      const filename = module2.exports.file(options);
      const write = isStream(data) ? writeStream : writeFile2;
      await write(filename, data);
      return filename;
    };
    module2.exports.write.task = createTask(module2.exports.write, {extraArguments: 1});
    module2.exports.writeSync = (data, options) => {
      const filename = module2.exports.file(options);
      fs2.writeFileSync(filename, data);
      return filename;
    };
    Object.defineProperty(module2.exports, "root", {
      get() {
        return tempDir;
      }
    });
  });
  var require_hasha = __commonJS((exports2, module2) => {
    "use strict";
    var fs2 = require("fs");
    var path2 = require("path");
    var crypto2 = require("crypto");
    var isStream = require_is_stream();
    var {Worker} = (() => {
      try {
        return require("worker_threads");
      } catch (_) {
        return {};
      }
    })();
    var worker;
    var taskIdCounter = 0;
    var tasks = new Map();
    var recreateWorkerError = (sourceError) => {
      const error = new Error(sourceError.message);
      for (const [key, value] of Object.entries(sourceError)) {
        if (key !== "message") {
          error[key] = value;
        }
      }
      return error;
    };
    var createWorker = () => {
      worker = new Worker(path2.join(__dirname, "thread.js"));
      worker.on("message", (message) => {
        const task = tasks.get(message.id);
        tasks.delete(message.id);
        if (tasks.size === 0) {
          worker.unref();
        }
        if (message.error === void 0) {
          task.resolve(message.value);
        } else {
          task.reject(recreateWorkerError(message.error));
        }
      });
      worker.on("error", (error) => {
        throw error;
      });
    };
    var taskWorker = (method, args, transferList) => new Promise((resolve, reject) => {
      const id = taskIdCounter++;
      tasks.set(id, {resolve, reject});
      if (worker === void 0) {
        createWorker();
      }
      worker.ref();
      worker.postMessage({id, method, args}, transferList);
    });
    var hasha = (input, options = {}) => {
      let outputEncoding = options.encoding || "hex";
      if (outputEncoding === "buffer") {
        outputEncoding = void 0;
      }
      const hash = crypto2.createHash(options.algorithm || "sha512");
      const update = (buffer) => {
        const inputEncoding = typeof buffer === "string" ? "utf8" : void 0;
        hash.update(buffer, inputEncoding);
      };
      if (Array.isArray(input)) {
        input.forEach(update);
      } else {
        update(input);
      }
      return hash.digest(outputEncoding);
    };
    hasha.stream = (options = {}) => {
      let outputEncoding = options.encoding || "hex";
      if (outputEncoding === "buffer") {
        outputEncoding = void 0;
      }
      const stream = crypto2.createHash(options.algorithm || "sha512");
      stream.setEncoding(outputEncoding);
      return stream;
    };
    hasha.fromStream = async (stream, options = {}) => {
      if (!isStream(stream)) {
        throw new TypeError("Expected a stream");
      }
      return new Promise((resolve, reject) => {
        stream.on("error", reject).pipe(hasha.stream(options)).on("error", reject).on("finish", function() {
          resolve(this.read());
        });
      });
    };
    if (Worker === void 0) {
      hasha.fromFile = async (filePath, options) => hasha.fromStream(fs2.createReadStream(filePath), options);
      hasha.async = async (input, options) => hasha(input, options);
    } else {
      hasha.fromFile = async (filePath, {algorithm = "sha512", encoding = "hex"} = {}) => {
        const hash = await taskWorker("hashFile", [algorithm, filePath]);
        if (encoding === "buffer") {
          return Buffer.from(hash);
        }
        return Buffer.from(hash).toString(encoding);
      };
      hasha.async = async (input, {algorithm = "sha512", encoding = "hex"} = {}) => {
        if (encoding === "buffer") {
          encoding = void 0;
        }
        const hash = await taskWorker("hash", [algorithm, input]);
        if (encoding === void 0) {
          return Buffer.from(hash);
        }
        return Buffer.from(hash).toString(encoding);
      };
    }
    hasha.fromFileSync = (filePath, options) => hasha(fs2.readFileSync(filePath), options);
    module2.exports = hasha;
  });
  var require_downloadZip = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.downloadZip = void 0;
    var zlib_1 = __importDefault2(require("zlib"));
    var p_retry_12 = __importDefault2(require_p_retry());
    var node_fetch_1 = __importDefault2(require_lib());
    var fs_12 = __importDefault2(require("fs"));
    var getProxyAgent_1 = require_getProxyAgent();
    var tempy_1 = __importDefault2(require_tempy());
    var path_12 = __importDefault2(require("path"));
    var debug_12 = __importDefault2(require_dist());
    var hasha_1 = __importDefault2(require_hasha());
    var util_12 = require("util");
    var rimraf_1 = __importDefault2(require_rimraf());
    var debug32 = debug_12.default("prisma:downloadZip");
    var del = util_12.promisify(rimraf_1.default);
    async function fetchSha256(url) {
      const [zippedSha256, sha256] = [
        (await node_fetch_1.default(`${url}.sha256`, {
          agent: getProxyAgent_1.getProxyAgent(url)
        }).then((res) => res.text())).split(/\s+/)[0],
        (await node_fetch_1.default(`${url.slice(0, url.length - 3)}.sha256`, {
          agent: getProxyAgent_1.getProxyAgent(url.slice(0, url.length - 3))
        }).then((res) => res.text())).split(/\s+/)[0]
      ];
      return {sha256, zippedSha256};
    }
    async function downloadZip(url, target, progressCb) {
      const tmpDir = tempy_1.default.directory();
      const partial = path_12.default.join(tmpDir, "partial");
      const {sha256, zippedSha256} = await fetchSha256(url);
      const result = await p_retry_12.default(async () => {
        try {
          const resp = await node_fetch_1.default(url, {
            compress: false,
            agent: getProxyAgent_1.getProxyAgent(url)
          });
          if (resp.status !== 200) {
            throw new Error(resp.statusText + " " + url);
          }
          const lastModified = resp.headers.get("last-modified");
          const size = parseFloat(resp.headers.get("content-length"));
          const ws = fs_12.default.createWriteStream(partial);
          return await new Promise(async (resolve, reject) => {
            let bytesRead = 0;
            resp.body.on("error", reject).on("data", (chunk) => {
              bytesRead += chunk.length;
              if (size && progressCb) {
                progressCb(bytesRead / size);
              }
            });
            const gunzip = zlib_1.default.createGunzip();
            gunzip.on("error", reject);
            const zipStream = resp.body.pipe(gunzip);
            const zippedHashPromise = hasha_1.default.fromStream(resp.body, {
              algorithm: "sha256"
            });
            const hashPromise = hasha_1.default.fromStream(zipStream, {
              algorithm: "sha256"
            });
            zipStream.pipe(ws);
            ws.on("error", reject).on("close", () => {
              resolve({lastModified, sha256, zippedSha256});
            });
            const hash = await hashPromise;
            const zippedHash = await zippedHashPromise;
            if (zippedHash !== zippedSha256) {
              throw new Error(`sha256 of ${url} (zipped) should be ${zippedSha256} but is ${zippedHash}`);
            }
            if (hash !== sha256) {
              throw new Error(`sha256 of ${url} (uzipped) should be ${sha256} but is ${hash}`);
            }
          });
        } finally {
        }
      }, {
        retries: 2,
        onFailedAttempt: (err) => debug32(err)
      });
      fs_12.default.copyFileSync(partial, target);
      try {
        await del(partial);
        await del(tmpDir);
      } catch (e) {
        debug32(e);
      }
      return result;
    }
    exports2.downloadZip = downloadZip;
  });
  var require_flatMap = __commonJS((exports2) => {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.flatMap = void 0;
    function flatten2(array) {
      return Array.prototype.concat.apply([], array);
    }
    function flatMap2(array, callbackFn, thisArg) {
      return flatten2(array.map(callbackFn, thisArg));
    }
    exports2.flatMap = flatMap2;
  });
  var require_getHash = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getHash = void 0;
    var crypto_1 = __importDefault2(require("crypto"));
    var fs_12 = __importDefault2(require("fs"));
    function getHash(filePath) {
      const hash = crypto_1.default.createHash("sha256");
      const input = fs_12.default.createReadStream(filePath);
      return new Promise((resolve) => {
        input.on("readable", () => {
          const data = input.read();
          if (data) {
            hash.update(data);
          } else {
            resolve(hash.digest("hex"));
          }
        });
      });
    }
    exports2.getHash = getHash;
  });
  var require_getLatestTag = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.urlExists = exports2.getAllUrls = exports2.getLatestTag = void 0;
    var get_platform_12 = require_dist2();
    var chalk_12 = __importDefault2(require_source());
    var execa_12 = __importDefault2(require_execa());
    var node_fetch_1 = __importDefault2(require_lib());
    var p_map_1 = __importDefault2(require_p_map());
    var getProxyAgent_1 = require_getProxyAgent();
    var util_12 = require_util2();
    async function getLatestTag() {
      let branch = await getBranch();
      if (branch !== "master" && !isPatchBranch(branch) && !branch.startsWith("integration/")) {
        branch = "master";
      }
      branch = branch.replace(/^integration\//, "");
      let commits = await getCommits(branch);
      if ((!commits || !Array.isArray(commits)) && branch !== "master" && !isPatchBranch(branch)) {
        console.log(`Overwriting branch "${branch}" with "master" as it's not a branch we have binaries for`);
        branch = "master";
        commits = await getCommits(branch);
      }
      if (!Array.isArray(commits)) {
        console.error(commits);
        throw new Error(`Could not fetch commits from github: ${JSON.stringify(commits, null, 2)}`);
      }
      return getFirstFinishedCommit(branch, commits);
    }
    exports2.getLatestTag = getLatestTag;
    function getAllUrls(branch, commit) {
      const urls = [];
      const excludedPlatforms = [
        "freebsd",
        "arm",
        "linux-nixos",
        "openbsd",
        "netbsd",
        "freebsd11",
        "freebsd12"
      ];
      const relevantPlatforms = get_platform_12.platforms.filter((p) => !excludedPlatforms.includes(p));
      for (const platform of relevantPlatforms) {
        for (const engine of [
          "query-engine",
          "introspection-engine",
          "migration-engine",
          "prisma-fmt"
        ]) {
          for (const extension of [
            ".gz",
            ".gz.sha256",
            ".gz.sig",
            ".sig",
            ".sha256"
          ]) {
            const downloadUrl = util_12.getDownloadUrl(branch, commit, platform, engine, extension);
            urls.push(downloadUrl);
          }
        }
      }
      return urls;
    }
    exports2.getAllUrls = getAllUrls;
    async function getFirstFinishedCommit(branch, commits) {
      for (const commit of commits) {
        const urls = getAllUrls(branch, commit);
        const exist = await p_map_1.default(urls, urlExists, {concurrency: 10});
        const hasMissing = exist.some((e) => !e);
        if (!hasMissing) {
          return commit;
        } else {
          const missing = urls.filter((_, i) => !exist[i]);
          if (missing.length !== urls.length) {
            console.log(`${chalk_12.default.blueBright("info")} The engine commit ${commit} is not yet done. We're skipping it as we're in dev. Missing urls: ${missing.length}`);
          }
        }
      }
    }
    async function urlExists(url) {
      try {
        const res = await node_fetch_1.default(url, {
          method: "HEAD",
          agent: getProxyAgent_1.getProxyAgent(url)
        });
        const headers = fromEntries(res.headers.entries());
        if (res.status > 200) {
        }
        if (parseInt(headers["content-length"]) > 0) {
          return res.status < 300;
        }
      } catch (e) {
      }
      return false;
    }
    exports2.urlExists = urlExists;
    function fromEntries(entries) {
      const result = {};
      for (const [key, value] of entries) {
        result[key] = value;
      }
      return result;
    }
    async function getBranch() {
      if (process.env.NODE_ENV !== "test") {
        if (process.env.PATCH_BRANCH) {
          return process.env.PATCH_BRANCH;
        }
        if (process.env.BUILDKITE_BRANCH) {
          return process.env.BUILDKITE_BRANCH;
        }
        if (process.env.GITHUB_CONTEXT) {
          const context = JSON.parse(process.env.GITHUB_CONTEXT);
          return context.head_ref;
        }
      }
      try {
        const result = await execa_12.default.command("git rev-parse --abbrev-ref HEAD", {
          shell: true,
          stdio: "pipe"
        });
        return result.stdout;
      } catch (e) {
        console.error(e);
      }
      return;
    }
    function isPatchBranch(version) {
      return /^2\.(\d+)\.x/.test(version);
    }
    async function getCommits(branch) {
      const url = `https://github-cache.prisma.workers.dev/repos/prisma/prisma-engines/commits?sha=${branch}`;
      const result = await node_fetch_1.default(url, {
        agent: getProxyAgent_1.getProxyAgent(url),
        headers: {
          Authorization: process.env.GITHUB_TOKEN ? `token ${process.env.GITHUB_TOKEN}` : void 0
        }
      }).then((res) => res.json());
      if (!Array.isArray(result)) {
        return result;
      }
      const commits = result.map((r) => r.sha);
      return commits;
    }
  });
  var require_node_progress = __commonJS((exports2, module2) => {
    /*!
     * node-progress
     * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
     * MIT Licensed
     */
    exports2 = module2.exports = ProgressBar;
    function ProgressBar(fmt, options) {
      this.stream = options.stream || process.stderr;
      if (typeof options == "number") {
        var total = options;
        options = {};
        options.total = total;
      } else {
        options = options || {};
        if (typeof fmt != "string")
          throw new Error("format required");
        if (typeof options.total != "number")
          throw new Error("total required");
      }
      this.fmt = fmt;
      this.curr = options.curr || 0;
      this.total = options.total;
      this.width = options.width || this.total;
      this.clear = options.clear;
      this.chars = {
        complete: options.complete || "=",
        incomplete: options.incomplete || "-",
        head: options.head || (options.complete || "=")
      };
      this.renderThrottle = options.renderThrottle !== 0 ? options.renderThrottle || 16 : 0;
      this.lastRender = -Infinity;
      this.callback = options.callback || function() {
      };
      this.tokens = {};
      this.lastDraw = "";
    }
    ProgressBar.prototype.tick = function(len, tokens) {
      if (len !== 0)
        len = len || 1;
      if (typeof len == "object")
        tokens = len, len = 1;
      if (tokens)
        this.tokens = tokens;
      if (this.curr == 0)
        this.start = new Date();
      this.curr += len;
      this.render();
      if (this.curr >= this.total) {
        this.render(void 0, true);
        this.complete = true;
        this.terminate();
        this.callback(this);
        return;
      }
    };
    ProgressBar.prototype.render = function(tokens, force) {
      force = force !== void 0 ? force : false;
      if (tokens)
        this.tokens = tokens;
      if (!this.stream.isTTY)
        return;
      var now = Date.now();
      var delta = now - this.lastRender;
      if (!force && delta < this.renderThrottle) {
        return;
      } else {
        this.lastRender = now;
      }
      var ratio = this.curr / this.total;
      ratio = Math.min(Math.max(ratio, 0), 1);
      var percent = Math.floor(ratio * 100);
      var incomplete, complete, completeLength;
      var elapsed = new Date() - this.start;
      var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
      var rate = this.curr / (elapsed / 1e3);
      var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
      var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
      if (availableSpace && process.platform === "win32") {
        availableSpace = availableSpace - 1;
      }
      var width = Math.min(this.width, availableSpace);
      completeLength = Math.round(width * ratio);
      complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
      incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
      if (completeLength > 0)
        complete = complete.slice(0, -1) + this.chars.head;
      str = str.replace(":bar", complete + incomplete);
      if (this.tokens)
        for (var key in this.tokens)
          str = str.replace(":" + key, this.tokens[key]);
      if (this.lastDraw !== str) {
        this.stream.cursorTo(0);
        this.stream.write(str);
        this.stream.clearLine(1);
        this.lastDraw = str;
      }
    };
    ProgressBar.prototype.update = function(ratio, tokens) {
      var goal = Math.floor(ratio * this.total);
      var delta = goal - this.curr;
      this.tick(delta, tokens);
    };
    ProgressBar.prototype.interrupt = function(message) {
      this.stream.clearLine();
      this.stream.cursorTo(0);
      this.stream.write(message);
      this.stream.write("\n");
      this.stream.write(this.lastDraw);
    };
    ProgressBar.prototype.terminate = function() {
      if (this.clear) {
        if (this.stream.clearLine) {
          this.stream.clearLine();
          this.stream.cursorTo(0);
        }
      } else {
        this.stream.write("\n");
      }
    };
  });
  var require_progress = __commonJS((exports2, module2) => {
    module2.exports = require_node_progress();
  });
  var require_log = __commonJS((exports2) => {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getBar = void 0;
    var progress_1 = __importDefault2(require_progress());
    function getBar(text) {
      return new progress_1.default(`> ${text} [:bar] :percent`, {
        stream: process.stdout,
        width: 20,
        complete: "=",
        incomplete: " ",
        total: 100,
        head: "",
        clear: true
      });
    }
    exports2.getBar = getBar;
  });
  var require_download = __commonJS((exports, module) => {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : {default: mod2};
    };
    Object.defineProperty(exports, "__esModule", {value: true});
    exports.plusX = exports.maybeCopyToTmp = exports.getBinaryEnvVarPath = exports.getBinaryName = exports.checkVersionCommand = exports.getVersion = exports.download = exports.EngineTypes = void 0;
    var debug_1 = __importDefault(require_dist());
    var get_platform_1 = require_dist2();
    var chalk_1 = __importDefault(require_source());
    var execa_1 = __importDefault(require_execa());
    var fs_1 = __importDefault(require("fs"));
    var make_dir_1 = __importDefault(require_make_dir());
    var p_filter_1 = __importDefault(require_p_filter());
    var path_1 = __importDefault(require("path"));
    var temp_dir_1 = __importDefault(require_temp_dir());
    var util_1 = require("util");
    var chmod_1 = __importDefault(require_chmod());
    var cleanupCache_1 = require_cleanupCache();
    var copy_1 = require_copy();
    var downloadZip_1 = require_downloadZip();
    var flatMap_1 = require_flatMap();
    var getHash_1 = require_getHash();
    var getLatestTag_1 = require_getLatestTag();
    var log_1 = require_log();
    var util_2 = require_util2();
    var debug = debug_1.default("prisma:download");
    var writeFile = util_1.promisify(fs_1.default.writeFile);
    var exists = util_1.promisify(fs_1.default.exists);
    var readFile = util_1.promisify(fs_1.default.readFile);
    var channel = "master";
    var EngineTypes;
    (function(EngineTypes3) {
      EngineTypes3["queryEngine"] = "query-engine";
      EngineTypes3["libqueryEngineNapi"] = "libquery-engine-napi";
      EngineTypes3["migrationEngine"] = "migration-engine";
      EngineTypes3["introspectionEngine"] = "introspection-engine";
      EngineTypes3["prismaFmt"] = "prisma-fmt";
    })(EngineTypes = exports.EngineTypes || (exports.EngineTypes = {}));
    var BINARY_TO_ENV_VAR = {
      [EngineTypes.migrationEngine]: "PRISMA_MIGRATION_ENGINE_BINARY",
      [EngineTypes.queryEngine]: "PRISMA_QUERY_ENGINE_BINARY",
      [EngineTypes.libqueryEngineNapi]: "PRISMA_QUERY_ENGINE_LIBRARY",
      [EngineTypes.introspectionEngine]: "PRISMA_INTROSPECTION_ENGINE_BINARY",
      [EngineTypes.prismaFmt]: "PRISMA_FMT_BINARY"
    };
    async function download(options) {
      var _a, _b;
      const platform = await get_platform_1.getPlatform();
      const os = await get_platform_1.getos();
      if (os.distro && ["nixos"].includes(os.distro)) {
        console.error(`${chalk_1.default.yellow("Warning")} Precompiled binaries are not available for ${os.distro}.`);
      } else if (["freebsd11", "freebsd12", "openbsd", "netbsd"].includes(platform)) {
        console.error(`${chalk_1.default.yellow("Warning")} Precompiled binaries are not available for ${platform}. Read more about building your own binaries at https://pris.ly/d/build-binaries`);
      }
      if (!options.binaries || Object.values(options.binaries).length === 0) {
        return {};
      }
      const opts = {
        ...options,
        binaryTargets: (_a = options.binaryTargets) !== null && _a !== void 0 ? _a : [platform],
        version: (_b = options.version) !== null && _b !== void 0 ? _b : "latest",
        binaries: mapKeys(options.binaries, (key) => engineTypeToBinaryType(key, platform))
      };
      const binaryJobs = flatMap_1.flatMap(Object.entries(opts.binaries), ([binaryName, targetFolder]) => opts.binaryTargets.map((binaryTarget) => {
        const fileName = getBinaryName(binaryName, binaryTarget);
        const targetFilePath = binaryName === EngineTypes.libqueryEngineNapi ? path_1.default.join(targetFolder, get_platform_1.getNapiName(binaryTarget, "fs")) : path_1.default.join(targetFolder, fileName);
        return {
          binaryName,
          targetFolder,
          binaryTarget,
          fileName,
          targetFilePath,
          envVarPath: getBinaryEnvVarPath(binaryName)
        };
      }));
      if (process.env.BINARY_DOWNLOAD_VERSION) {
        opts.version = process.env.BINARY_DOWNLOAD_VERSION;
      }
      if (opts.version === "latest") {
        opts.version = await getLatestTag_1.getLatestTag();
      }
      if (opts.printVersion) {
        console.log(`version: ${opts.version}`);
      }
      const binariesToDownload = await p_filter_1.default(binaryJobs, async (job) => {
        const needsToBeDownloaded = await binaryNeedsToBeDownloaded(job, platform, opts.version, opts.failSilent);
        const isSupported = get_platform_1.platforms.includes(job.binaryTarget);
        const shouldDownload = isSupported && !job.envVarPath && (opts.ignoreCache || needsToBeDownloaded);
        if (needsToBeDownloaded && !isSupported) {
          throw new Error(`Unknown binaryTarget ${job.binaryTarget} and no custom binaries were provided`);
        }
        return shouldDownload;
      });
      if (binariesToDownload.length > 0) {
        const cleanupPromise = cleanupCache_1.cleanupCache();
        let finishBar;
        let setProgress;
        if (opts.showProgress) {
          const collectiveBar = getCollectiveBar(opts);
          finishBar = collectiveBar.finishBar;
          setProgress = collectiveBar.setProgress;
        }
        await Promise.all(binariesToDownload.map((job) => downloadBinary({
          ...job,
          version: opts.version,
          failSilent: opts.failSilent,
          progressCb: setProgress ? setProgress(job.targetFilePath) : void 0
        })));
        await cleanupPromise;
        if (finishBar) {
          finishBar();
        }
      }
      const binaryPaths = binaryJobsToBinaryPaths(binaryJobs);
      const dir = eval("__dirname");
      if (dir.startsWith("/snapshot/")) {
        for (const engineType in binaryPaths) {
          const binaryTargets = binaryPaths[engineType];
          for (const binaryTarget in binaryTargets) {
            const binaryPath = binaryTargets[binaryTarget];
            binaryTargets[binaryTarget] = await maybeCopyToTmp(binaryPath);
          }
        }
      }
      return binaryPaths;
    }
    exports.download = download;
    function getCollectiveBar(options) {
      var _a, _b;
      const bar = log_1.getBar(`Downloading Prisma engines for ${(_a = options.binaryTargets) === null || _a === void 0 ? void 0 : _a.map((p) => chalk_1.default.bold(p)).join(" and ")}`);
      const progressMap = {};
      const numDownloads = Object.values(options.binaries).length * Object.values((_b = options === null || options === void 0 ? void 0 : options.binaryTargets) !== null && _b !== void 0 ? _b : []).length;
      const setProgress = (sourcePath) => (progress) => {
        progressMap[sourcePath] = progress;
        const progressValues = Object.values(progressMap);
        const totalProgress = progressValues.reduce((acc, curr) => {
          return acc + curr;
        }, 0) / numDownloads;
        if (options.progressCb) {
          options.progressCb(totalProgress);
        }
        if (bar) {
          bar.update(totalProgress);
        }
      };
      return {
        setProgress,
        finishBar: () => {
          bar.update(1);
          bar.terminate();
        }
      };
    }
    function binaryJobsToBinaryPaths(jobs) {
      return jobs.reduce((acc, job) => {
        if (!acc[job.binaryName]) {
          acc[job.binaryName] = {};
        }
        acc[job.binaryName][job.binaryTarget] = job.envVarPath || job.targetFilePath;
        return acc;
      }, {});
    }
    async function binaryNeedsToBeDownloaded(job, nativePlatform, version, failSilent) {
      var _a;
      const binaryPath = (_a = job.envVarPath) !== null && _a !== void 0 ? _a : job.targetFilePath;
      const targetExists = await exists(binaryPath);
      const cachedFile = await getCachedBinaryPath({
        ...job,
        version,
        failSilent
      });
      if (cachedFile) {
        const sha256FilePath = cachedFile + ".sha256";
        if (await exists(sha256FilePath)) {
          const sha256File = await readFile(sha256FilePath, "utf-8");
          const sha256Cache = await getHash_1.getHash(cachedFile);
          if (sha256File === sha256Cache) {
            if (!targetExists) {
              debug(`copying ${cachedFile} to ${job.targetFilePath}`);
              await copy_1.copy(cachedFile, job.targetFilePath);
            }
            const targetSha256 = await getHash_1.getHash(job.targetFilePath);
            if (sha256File !== targetSha256) {
              debug(`overwriting ${job.targetFilePath} with ${cachedFile} as hashes do not match`);
              await copy_1.copy(cachedFile, job.targetFilePath);
            }
            return false;
          } else {
            return true;
          }
        } else {
          return true;
        }
      }
      if (!targetExists) {
        debug(`file ${binaryPath} does not exist and must be downloaded`);
        return true;
      }
      if (job.binaryTarget === nativePlatform && job.binaryName !== EngineTypes.libqueryEngineNapi) {
        const works = await checkVersionCommand(binaryPath);
        return !works;
      }
      return false;
    }
    async function getVersion(enginePath) {
      const result = await execa_1.default(enginePath, ["--version"]);
      return result.stdout;
    }
    exports.getVersion = getVersion;
    async function checkVersionCommand(enginePath) {
      try {
        const version = await getVersion(enginePath);
        return version.length > 0;
      } catch (e) {
        return false;
      }
    }
    exports.checkVersionCommand = checkVersionCommand;
    function getBinaryName(binaryName, platform) {
      if (binaryName === EngineTypes.libqueryEngineNapi) {
        return `${get_platform_1.getNapiName(platform, "url")}`;
      }
      const extension = platform === "windows" ? ".exe" : "";
      return `${binaryName}-${platform}${extension}`;
    }
    exports.getBinaryName = getBinaryName;
    async function getCachedBinaryPath({version, binaryTarget, binaryName}) {
      const cacheDir = await util_2.getCacheDir(channel, version, binaryTarget);
      if (!cacheDir) {
        return null;
      }
      const cachedTargetPath = path_1.default.join(cacheDir, binaryName);
      if (!fs_1.default.existsSync(cachedTargetPath)) {
        return null;
      }
      if (version !== "latest") {
        return cachedTargetPath;
      }
      if (await exists(cachedTargetPath)) {
        return cachedTargetPath;
      }
      return null;
    }
    function getBinaryEnvVarPath(binaryName) {
      const envVar = BINARY_TO_ENV_VAR[binaryName];
      if (envVar && process.env[envVar]) {
        const envVarPath = path_1.default.resolve(process.cwd(), process.env[envVar]);
        if (!fs_1.default.existsSync(envVarPath)) {
          throw new Error(`Env var ${chalk_1.default.bold(envVar)} is provided but provided path ${chalk_1.default.underline(process.env[envVar])} can't be resolved.`);
        }
        debug(`Using env var ${chalk_1.default.bold(envVar)} for binary ${chalk_1.default.bold(binaryName)}, which points to ${chalk_1.default.underline(process.env[envVar])}`);
        return envVarPath;
      }
      return null;
    }
    exports.getBinaryEnvVarPath = getBinaryEnvVarPath;
    async function downloadBinary(options) {
      const {version, progressCb, targetFilePath, binaryTarget, binaryName} = options;
      const downloadUrl = util_2.getDownloadUrl("all_commits", version, binaryTarget, binaryName);
      const targetDir = path_1.default.dirname(targetFilePath);
      try {
        fs_1.default.accessSync(targetDir, fs_1.default.constants.W_OK);
        await make_dir_1.default(targetDir);
      } catch (e) {
        if (options.failSilent || e.code !== "EACCES") {
          return;
        } else {
          throw new Error(`Can't write to ${targetDir} please make sure you install "prisma" with the right permissions.`);
        }
      }
      debug(`Downloading ${downloadUrl} to ${targetFilePath}`);
      if (progressCb) {
        progressCb(0);
      }
      const {sha256, zippedSha256} = await downloadZip_1.downloadZip(downloadUrl, targetFilePath, progressCb);
      if (progressCb) {
        progressCb(1);
      }
      if (process.platform !== "win32") {
        chmod_1.default(targetFilePath);
      }
      await saveFileToCache(options, version, sha256, zippedSha256);
    }
    async function saveFileToCache(job, version, sha256, zippedSha256) {
      const cacheDir = await util_2.getCacheDir(channel, version, job.binaryTarget);
      if (!cacheDir) {
        return;
      }
      const cachedTargetPath = path_1.default.join(cacheDir, job.binaryName);
      const cachedSha256Path = path_1.default.join(cacheDir, job.binaryName + ".sha256");
      const cachedSha256ZippedPath = path_1.default.join(cacheDir, job.binaryName + ".gz.sha256");
      try {
        await copy_1.copy(job.targetFilePath, cachedTargetPath);
        await writeFile(cachedSha256Path, sha256);
        await writeFile(cachedSha256ZippedPath, zippedSha256);
      } catch (e) {
        debug(e);
      }
    }
    function engineTypeToBinaryType(engineType, binaryTarget) {
      if (EngineTypes[engineType]) {
        return EngineTypes[engineType];
      }
      if (engineType === "native") {
        return binaryTarget;
      }
      return engineType;
    }
    function mapKeys(obj, mapper) {
      return Object.entries(obj).reduce((acc, [key, value]) => {
        acc[mapper(key)] = value;
        return acc;
      }, {});
    }
    async function maybeCopyToTmp(file) {
      const dir = eval("__dirname");
      if (dir.startsWith("/snapshot/")) {
        const targetDir = path_1.default.join(temp_dir_1.default, "prisma-binaries");
        await make_dir_1.default(targetDir);
        const target = path_1.default.join(targetDir, path_1.default.basename(file));
        const data = await readFile(file);
        await writeFile(target, data);
        plusX(target);
        return target;
      }
      return file;
    }
    exports.maybeCopyToTmp = maybeCopyToTmp;
    function plusX(file) {
      const s = fs_1.default.statSync(file);
      const newMode = s.mode | 64 | 8 | 1;
      if (s.mode === newMode) {
        return;
      }
      const base8 = newMode.toString(8).slice(-3);
      fs_1.default.chmodSync(file, base8);
    }
    exports.plusX = plusX;
  });
  var require_dist6 = __commonJS((exports2) => {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar22 = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", {value: true});
    exports2.getProxyAgent = exports2.urlExists = exports2.getLatestTag = exports2.getAllUrls = void 0;
    __exportStar22(require_download(), exports2);
    var getLatestTag_12 = require_getLatestTag();
    Object.defineProperty(exports2, "getAllUrls", {enumerable: true, get: function() {
      return getLatestTag_12.getAllUrls;
    }});
    Object.defineProperty(exports2, "getLatestTag", {enumerable: true, get: function() {
      return getLatestTag_12.getLatestTag;
    }});
    Object.defineProperty(exports2, "urlExists", {enumerable: true, get: function() {
      return getLatestTag_12.urlExists;
    }});
    var getProxyAgent_1 = require_getProxyAgent();
    Object.defineProperty(exports2, "getProxyAgent", {enumerable: true, get: function() {
      return getProxyAgent_1.getProxyAgent;
    }});
  });
  __markAsModule(exports);
  __export(exports, {
    enginesVersion: () => import_engines_version2.enginesVersion,
    ensureBinariesExist: () => ensureBinariesExist,
    getEnginesPath: () => getEnginesPath
  });
  var import_debug = __toModule(require_dist());
  var import_engines_version = __toModule(require_engines_version());
  var import_fetch_engine = __toModule(require_dist6());
  var import_path = __toModule(require("path"));
  var import_engines_version2 = __toModule(require_engines_version());
  var debug2 = import_debug.default("prisma:engines");
  function getEnginesPath() {
    return import_path.default.join(__dirname, "../");
  }
  async function ensureBinariesExist() {
    const binaryDir = import_path.default.join(__dirname, "../");
    let binaryTargets = void 0;
    if (process.env.PRISMA_CLI_BINARY_TARGETS) {
      binaryTargets = process.env.PRISMA_CLI_BINARY_TARGETS.split(",");
    }
    debug2(`using NAPI: ${process.env.PRISMA_FORCE_NAPI === "true"}`);
    const binaries = {
      [process.env.PRISMA_FORCE_NAPI === "true" ? import_fetch_engine.EngineTypes.libqueryEngineNapi : import_fetch_engine.EngineTypes.queryEngine]: binaryDir,
      [import_fetch_engine.EngineTypes.migrationEngine]: binaryDir,
      [import_fetch_engine.EngineTypes.introspectionEngine]: binaryDir,
      [import_fetch_engine.EngineTypes.prismaFmt]: binaryDir
    };
    debug2(`binaries to download ${Object.keys(binaries).join(", ")}`);
    await import_fetch_engine.download({
      binaries,
      showProgress: true,
      version: import_engines_version.enginesVersion,
      failSilent: false,
      binaryTargets
    });
  }
  import_path.default.join(__dirname, "../query-engine-darwin");
  import_path.default.join(__dirname, "../introspection-engine-darwin");
  import_path.default.join(__dirname, "../prisma-fmt-darwin");
  import_path.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  import_path.default.join(__dirname, "../introspection-engine-debian-openssl-1.0.x");
  import_path.default.join(__dirname, "../prisma-fmt-debian-openssl-1.0.x");
  import_path.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  import_path.default.join(__dirname, "../introspection-engine-debian-openssl-1.1.x");
  import_path.default.join(__dirname, "../prisma-fmt-debian-openssl-1.1.x");
  import_path.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  import_path.default.join(__dirname, "../introspection-engine-rhel-openssl-1.0.x");
  import_path.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.0.x");
  import_path.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  import_path.default.join(__dirname, "../introspection-engine-rhel-openssl-1.1.x");
  import_path.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.1.x");
  import_path.default.join(__dirname, "../libquery_engine_napi-darwin.dylib.node");
  import_path.default.join(__dirname, "../libquery_engine_napi-debian-openssl-1.0.x.so.node");
  import_path.default.join(__dirname, "../libquery_engine_napi-debian-openssl-1.1.x.so.node");
  import_path.default.join(__dirname, "../libquery_engine_napi-linux-arm-openssl-1.0.x.so.node");
  import_path.default.join(__dirname, "../libquery_engine_napi-linux-arm-openssl-1.1.x.so.node");
  import_path.default.join(__dirname, "../libquery_engine_napi-linux-musl.so.node");
  import_path.default.join(__dirname, "../libquery_engine_napi-rhel-openssl-1.0.x.so.node");
  import_path.default.join(__dirname, "../libquery_engine_napi-rhel-openssl-1.1.x.so.node");
  import_path.default.join(__dirname, "../query_engine_napi-windows.dll.node");
});

// ../get-platform/dist/getNapiName.js
var require_getNapiName2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getNapiName = exports2.NAPI_QUERY_ENGINE_URL_BASE = void 0;
  exports2.NAPI_QUERY_ENGINE_URL_BASE = "libquery_engine_napi";
  function getNapiName(platform, type) {
    const isUrl = type === "url";
    if (platform.includes("windows")) {
      return isUrl ? `query_engine_napi.dll.node` : `query_engine_napi-${platform}.dll.node`;
    } else if (platform.includes("linux") || platform.includes("debian") || platform.includes("rhel")) {
      return isUrl ? `${exports2.NAPI_QUERY_ENGINE_URL_BASE}.so.node` : `${exports2.NAPI_QUERY_ENGINE_URL_BASE}-${platform}.so.node`;
    } else if (platform.includes("darwin")) {
      return isUrl ? `${exports2.NAPI_QUERY_ENGINE_URL_BASE}.dylib.node` : `${exports2.NAPI_QUERY_ENGINE_URL_BASE}-${platform}.dylib.node`;
    } else {
      throw new Error(`NAPI is currently not supported on your platform: ${platform}`);
    }
  }
  exports2.getNapiName = getNapiName;
});

// ../get-platform/dist/getPlatform.js
var require_getPlatform2 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getPlatform = exports2.getOpenSSLVersion = exports2.parseOpenSSLVersion = exports2.resolveDistro = exports2.parseDistro = exports2.getos = void 0;
  var child_process_12 = require("child_process");
  var fs_12 = __importDefault2(require("fs"));
  var os_1 = __importDefault2(require("os"));
  var util_12 = require("util");
  var readFile = util_12.promisify(fs_12.default.readFile);
  var exists2 = util_12.promisify(fs_12.default.exists);
  async function getos() {
    const platform = os_1.default.platform();
    const arch = process.arch;
    if (platform === "freebsd") {
      const version = await gracefulExec(`freebsd-version`);
      if (version && version.trim().length > 0) {
        const regex = /^(\d+)\.?/;
        const match = regex.exec(version);
        if (match) {
          return {
            platform: "freebsd",
            distro: `freebsd${match[1]}`,
            arch
          };
        }
      }
    }
    if (platform !== "linux") {
      return {
        platform,
        arch
      };
    }
    return {
      platform: "linux",
      libssl: await getOpenSSLVersion(),
      distro: await resolveDistro(),
      arch
    };
  }
  exports2.getos = getos;
  function parseDistro(input) {
    const idRegex = /^ID="?([^"\n]*)"?$/im;
    const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
    const idMatch = idRegex.exec(input);
    const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
    const idLikeMatch = idLikeRegex.exec(input);
    const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
    if (id === "raspbian") {
      return "arm";
    }
    if (id === "nixos") {
      return "nixos";
    }
    if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
      return "rhel";
    }
    if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
      return "debian";
    }
    return;
  }
  exports2.parseDistro = parseDistro;
  async function resolveDistro() {
    const osReleaseFile = "/etc/os-release";
    const alpineReleaseFile = "/etc/alpine-release";
    if (await exists2(alpineReleaseFile)) {
      return "musl";
    } else if (await exists2(osReleaseFile)) {
      return parseDistro(await readFile(osReleaseFile, "utf-8"));
    } else {
      return;
    }
  }
  exports2.resolveDistro = resolveDistro;
  function parseOpenSSLVersion(input) {
    const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
    if (match) {
      return match[1] + ".x";
    }
    return;
  }
  exports2.parseOpenSSLVersion = parseOpenSSLVersion;
  async function getOpenSSLVersion() {
    const [version, ls] = await Promise.all([
      gracefulExec(`openssl version -v`),
      gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
    ]);
    if (version) {
      const v = parseOpenSSLVersion(version);
      if (v) {
        return v;
      }
    }
    if (ls) {
      const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
      if (match) {
        return match[1] + ".x";
      }
    }
    return void 0;
  }
  exports2.getOpenSSLVersion = getOpenSSLVersion;
  async function gracefulExec(cmd) {
    return new Promise((resolve) => {
      try {
        child_process_12.exec(cmd, (err, stdout) => {
          resolve(String(stdout));
        });
      } catch (e) {
        resolve(void 0);
        return void 0;
      }
    });
  }
  async function getPlatform() {
    const {platform, libssl, distro, arch} = await getos();
    if (platform === "darwin") {
      return "darwin";
    }
    if (platform === "win32") {
      return "windows";
    }
    if (platform === "freebsd") {
      return distro;
    }
    if (platform === "openbsd") {
      return "openbsd";
    }
    if (platform === "netbsd") {
      return "netbsd";
    }
    if (platform === "linux" && arch === "arm64") {
      return `linux-arm-openssl-${libssl}`;
    }
    if (platform === "linux" && distro === "nixos") {
      return "linux-nixos";
    }
    if (platform === "linux" && distro === "musl") {
      return "linux-musl";
    }
    if (platform === "linux" && distro && libssl) {
      return distro + "-openssl-" + libssl;
    }
    if (libssl) {
      return "debian-openssl-" + libssl;
    }
    if (distro) {
      return distro + "-openssl-1.1.x";
    }
    return "debian-openssl-1.1.x";
  }
  exports2.getPlatform = getPlatform;
});

// ../get-platform/dist/platforms.js
var require_platforms2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.platforms = void 0;
  exports2.platforms = [
    "darwin",
    "debian-openssl-1.0.x",
    "debian-openssl-1.1.x",
    "rhel-openssl-1.0.x",
    "rhel-openssl-1.1.x",
    "linux-arm-openssl-1.1.x",
    "linux-arm-openssl-1.0.x",
    "linux-musl",
    "linux-nixos",
    "windows",
    "freebsd11",
    "freebsd12",
    "openbsd",
    "netbsd",
    "arm"
  ];
});

// ../get-platform/dist/index.js
var require_dist10 = __commonJS2((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar3 = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.platforms = exports2.getPlatform = exports2.getos = void 0;
  __exportStar3(require_getNapiName2(), exports2);
  var getPlatform_1 = require_getPlatform2();
  Object.defineProperty(exports2, "getos", {enumerable: true, get: function() {
    return getPlatform_1.getos;
  }});
  Object.defineProperty(exports2, "getPlatform", {enumerable: true, get: function() {
    return getPlatform_1.getPlatform;
  }});
  var platforms_1 = require_platforms2();
  Object.defineProperty(exports2, "platforms", {enumerable: true, get: function() {
    return platforms_1.platforms;
  }});
});

// ../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js
var require_strip_final_newline2 = __commonJS2((exports2, module2) => {
  "use strict";
  module2.exports = (input) => {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
    if (input[input.length - 1] === LF) {
      input = input.slice(0, input.length - 1);
    }
    if (input[input.length - 1] === CR) {
      input = input.slice(0, input.length - 1);
    }
    return input;
  };
});

// ../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js
var require_npm_run_path2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  var pathKey = require_path_key2();
  var npmRunPath = (options) => {
    options = {
      cwd: process.cwd(),
      path: process.env[pathKey()],
      execPath: process.execPath,
      ...options
    };
    let previous;
    let cwdPath = path2.resolve(options.cwd);
    const result = [];
    while (previous !== cwdPath) {
      result.push(path2.join(cwdPath, "node_modules/.bin"));
      previous = cwdPath;
      cwdPath = path2.resolve(cwdPath, "..");
    }
    const execPathDir = path2.resolve(options.cwd, options.execPath, "..");
    result.push(execPathDir);
    return result.concat(options.path).join(path2.delimiter);
  };
  module2.exports = npmRunPath;
  module2.exports.default = npmRunPath;
  module2.exports.env = (options) => {
    options = {
      env: process.env,
      ...options
    };
    const env = {...options.env};
    const path3 = pathKey({env});
    options.path = env[path3];
    env[path3] = module2.exports(options);
    return env;
  };
});

// ../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js
var require_mimic_fn2 = __commonJS2((exports2, module2) => {
  "use strict";
  var mimicFn = (to, from) => {
    for (const prop of Reflect.ownKeys(from)) {
      Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
    }
    return to;
  };
  module2.exports = mimicFn;
  module2.exports.default = mimicFn;
});

// ../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js
var require_onetime2 = __commonJS2((exports2, module2) => {
  "use strict";
  var mimicFn = require_mimic_fn2();
  var calledFunctions = new WeakMap();
  var onetime = (function_, options = {}) => {
    if (typeof function_ !== "function") {
      throw new TypeError("Expected a function");
    }
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>";
    const onetime2 = function(...arguments_) {
      calledFunctions.set(onetime2, ++callCount);
      if (callCount === 1) {
        returnValue = function_.apply(this, arguments_);
        function_ = null;
      } else if (options.throw === true) {
        throw new Error(`Function \`${functionName}\` can only be called once`);
      }
      return returnValue;
    };
    mimicFn(onetime2, function_);
    calledFunctions.set(onetime2, callCount);
    return onetime2;
  };
  module2.exports = onetime;
  module2.exports.default = onetime;
  module2.exports.callCount = (function_) => {
    if (!calledFunctions.has(function_)) {
      throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    }
    return calledFunctions.get(function_);
  };
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js
var require_core2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SIGNALS = void 0;
  var SIGNALS = [
    {
      name: "SIGHUP",
      number: 1,
      action: "terminate",
      description: "Terminal closed",
      standard: "posix"
    },
    {
      name: "SIGINT",
      number: 2,
      action: "terminate",
      description: "User interruption with CTRL-C",
      standard: "ansi"
    },
    {
      name: "SIGQUIT",
      number: 3,
      action: "core",
      description: "User interruption with CTRL-\\",
      standard: "posix"
    },
    {
      name: "SIGILL",
      number: 4,
      action: "core",
      description: "Invalid machine instruction",
      standard: "ansi"
    },
    {
      name: "SIGTRAP",
      number: 5,
      action: "core",
      description: "Debugger breakpoint",
      standard: "posix"
    },
    {
      name: "SIGABRT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "ansi"
    },
    {
      name: "SIGIOT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "bsd"
    },
    {
      name: "SIGBUS",
      number: 7,
      action: "core",
      description: "Bus error due to misaligned, non-existing address or paging error",
      standard: "bsd"
    },
    {
      name: "SIGEMT",
      number: 7,
      action: "terminate",
      description: "Command should be emulated but is not implemented",
      standard: "other"
    },
    {
      name: "SIGFPE",
      number: 8,
      action: "core",
      description: "Floating point arithmetic error",
      standard: "ansi"
    },
    {
      name: "SIGKILL",
      number: 9,
      action: "terminate",
      description: "Forced termination",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGUSR1",
      number: 10,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGSEGV",
      number: 11,
      action: "core",
      description: "Segmentation fault",
      standard: "ansi"
    },
    {
      name: "SIGUSR2",
      number: 12,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGPIPE",
      number: 13,
      action: "terminate",
      description: "Broken pipe or socket",
      standard: "posix"
    },
    {
      name: "SIGALRM",
      number: 14,
      action: "terminate",
      description: "Timeout or timer",
      standard: "posix"
    },
    {
      name: "SIGTERM",
      number: 15,
      action: "terminate",
      description: "Termination",
      standard: "ansi"
    },
    {
      name: "SIGSTKFLT",
      number: 16,
      action: "terminate",
      description: "Stack is empty or overflowed",
      standard: "other"
    },
    {
      name: "SIGCHLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "posix"
    },
    {
      name: "SIGCLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "other"
    },
    {
      name: "SIGCONT",
      number: 18,
      action: "unpause",
      description: "Unpaused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGSTOP",
      number: 19,
      action: "pause",
      description: "Paused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGTSTP",
      number: 20,
      action: "pause",
      description: 'Paused using CTRL-Z or "suspend"',
      standard: "posix"
    },
    {
      name: "SIGTTIN",
      number: 21,
      action: "pause",
      description: "Background process cannot read terminal input",
      standard: "posix"
    },
    {
      name: "SIGBREAK",
      number: 21,
      action: "terminate",
      description: "User interruption with CTRL-BREAK",
      standard: "other"
    },
    {
      name: "SIGTTOU",
      number: 22,
      action: "pause",
      description: "Background process cannot write to terminal output",
      standard: "posix"
    },
    {
      name: "SIGURG",
      number: 23,
      action: "ignore",
      description: "Socket received out-of-band data",
      standard: "bsd"
    },
    {
      name: "SIGXCPU",
      number: 24,
      action: "core",
      description: "Process timed out",
      standard: "bsd"
    },
    {
      name: "SIGXFSZ",
      number: 25,
      action: "core",
      description: "File too big",
      standard: "bsd"
    },
    {
      name: "SIGVTALRM",
      number: 26,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGPROF",
      number: 27,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGWINCH",
      number: 28,
      action: "ignore",
      description: "Terminal window size changed",
      standard: "bsd"
    },
    {
      name: "SIGIO",
      number: 29,
      action: "terminate",
      description: "I/O is available",
      standard: "other"
    },
    {
      name: "SIGPOLL",
      number: 29,
      action: "terminate",
      description: "Watched event",
      standard: "other"
    },
    {
      name: "SIGINFO",
      number: 29,
      action: "ignore",
      description: "Request for process information",
      standard: "other"
    },
    {
      name: "SIGPWR",
      number: 30,
      action: "terminate",
      description: "Device running out of power",
      standard: "systemv"
    },
    {
      name: "SIGSYS",
      number: 31,
      action: "core",
      description: "Invalid system call",
      standard: "other"
    },
    {
      name: "SIGUNUSED",
      number: 31,
      action: "terminate",
      description: "Invalid system call",
      standard: "other"
    }
  ];
  exports2.SIGNALS = SIGNALS;
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js
var require_realtime2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
  var getRealtimeSignals = function() {
    const length = SIGRTMAX - SIGRTMIN + 1;
    return Array.from({length}, getRealtimeSignal);
  };
  exports2.getRealtimeSignals = getRealtimeSignals;
  var getRealtimeSignal = function(value, index) {
    return {
      name: `SIGRT${index + 1}`,
      number: SIGRTMIN + index,
      action: "terminate",
      description: "Application-specific signal (realtime)",
      standard: "posix"
    };
  };
  var SIGRTMIN = 34;
  var SIGRTMAX = 64;
  exports2.SIGRTMAX = SIGRTMAX;
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js
var require_signals3 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getSignals = void 0;
  var _os = require("os");
  var _core = require_core2();
  var _realtime = require_realtime2();
  var getSignals = function() {
    const realtimeSignals = (0, _realtime.getRealtimeSignals)();
    const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
    return signals;
  };
  exports2.getSignals = getSignals;
  var normalizeSignal = function({
    name,
    number: defaultNumber,
    description,
    action,
    forced = false,
    standard
  }) {
    const {
      signals: {[name]: constantSignal}
    } = _os.constants;
    const supported = constantSignal !== void 0;
    const number = supported ? constantSignal : defaultNumber;
    return {name, number, description, supported, action, forced, standard};
  };
});

// ../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js
var require_main2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.signalsByNumber = exports2.signalsByName = void 0;
  var _os = require("os");
  var _signals = require_signals3();
  var _realtime = require_realtime2();
  var getSignalsByName = function() {
    const signals = (0, _signals.getSignals)();
    return signals.reduce(getSignalByName, {});
  };
  var getSignalByName = function(signalByNameMemo, {name, number, description, supported, action, forced, standard}) {
    return {
      ...signalByNameMemo,
      [name]: {name, number, description, supported, action, forced, standard}
    };
  };
  var signalsByName = getSignalsByName();
  exports2.signalsByName = signalsByName;
  var getSignalsByNumber = function() {
    const signals = (0, _signals.getSignals)();
    const length = _realtime.SIGRTMAX + 1;
    const signalsA = Array.from({length}, (value, number) => getSignalByNumber(number, signals));
    return Object.assign({}, ...signalsA);
  };
  var getSignalByNumber = function(number, signals) {
    const signal = findSignalByNumber(number, signals);
    if (signal === void 0) {
      return {};
    }
    const {name, description, supported, action, forced, standard} = signal;
    return {
      [number]: {
        name,
        number,
        description,
        supported,
        action,
        forced,
        standard
      }
    };
  };
  var findSignalByNumber = function(number, signals) {
    const signal = signals.find(({name}) => _os.constants.signals[name] === number);
    if (signal !== void 0) {
      return signal;
    }
    return signals.find((signalA) => signalA.number === number);
  };
  var signalsByNumber = getSignalsByNumber();
  exports2.signalsByNumber = signalsByNumber;
});

// ../../node_modules/.pnpm/execa@5.0.0/node_modules/execa/lib/error.js
var require_error3 = __commonJS2((exports2, module2) => {
  "use strict";
  var {signalsByName} = require_main2();
  var getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {
    if (timedOut) {
      return `timed out after ${timeout} milliseconds`;
    }
    if (isCanceled) {
      return "was canceled";
    }
    if (errorCode !== void 0) {
      return `failed with ${errorCode}`;
    }
    if (signal !== void 0) {
      return `was killed with ${signal} (${signalDescription})`;
    }
    if (exitCode !== void 0) {
      return `failed with exit code ${exitCode}`;
    }
    return "failed";
  };
  var makeError = ({
    stdout,
    stderr,
    all,
    error,
    signal,
    exitCode,
    command,
    timedOut,
    isCanceled,
    killed,
    parsed: {options: {timeout}}
  }) => {
    exitCode = exitCode === null ? void 0 : exitCode;
    signal = signal === null ? void 0 : signal;
    const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
    const errorCode = error && error.code;
    const prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});
    const execaMessage = `Command ${prefix}: ${command}`;
    const isError3 = Object.prototype.toString.call(error) === "[object Error]";
    const shortMessage = isError3 ? `${execaMessage}
${error.message}` : execaMessage;
    const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
    if (isError3) {
      error.originalMessage = error.message;
      error.message = message;
    } else {
      error = new Error(message);
    }
    error.shortMessage = shortMessage;
    error.command = command;
    error.exitCode = exitCode;
    error.signal = signal;
    error.signalDescription = signalDescription;
    error.stdout = stdout;
    error.stderr = stderr;
    if (all !== void 0) {
      error.all = all;
    }
    if ("bufferedData" in error) {
      delete error.bufferedData;
    }
    error.failed = true;
    error.timedOut = Boolean(timedOut);
    error.isCanceled = isCanceled;
    error.killed = killed && !timedOut;
    return error;
  };
  module2.exports = makeError;
});

// ../../node_modules/.pnpm/execa@5.0.0/node_modules/execa/lib/stdio.js
var require_stdio2 = __commonJS2((exports2, module2) => {
  "use strict";
  var aliases = ["stdin", "stdout", "stderr"];
  var hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
  var normalizeStdio = (options) => {
    if (!options) {
      return;
    }
    const {stdio} = options;
    if (stdio === void 0) {
      return aliases.map((alias) => options[alias]);
    }
    if (hasAlias(options)) {
      throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
    }
    if (typeof stdio === "string") {
      return stdio;
    }
    if (!Array.isArray(stdio)) {
      throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    }
    const length = Math.max(stdio.length, aliases.length);
    return Array.from({length}, (value, index) => stdio[index]);
  };
  module2.exports = normalizeStdio;
  module2.exports.node = (options) => {
    const stdio = normalizeStdio(options);
    if (stdio === "ipc") {
      return "ipc";
    }
    if (stdio === void 0 || typeof stdio === "string") {
      return [stdio, stdio, stdio, "ipc"];
    }
    if (stdio.includes("ipc")) {
      return stdio;
    }
    return [...stdio, "ipc"];
  };
});

// ../../node_modules/.pnpm/signal-exit@3.0.3/node_modules/signal-exit/signals.js
var require_signals4 = __commonJS2((exports2, module2) => {
  module2.exports = [
    "SIGABRT",
    "SIGALRM",
    "SIGHUP",
    "SIGINT",
    "SIGTERM"
  ];
  if (process.platform !== "win32") {
    module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
  }
  if (process.platform === "linux") {
    module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
  }
});

// ../../node_modules/.pnpm/signal-exit@3.0.3/node_modules/signal-exit/index.js
var require_signal_exit2 = __commonJS2((exports2, module2) => {
  var assert = require("assert");
  var signals = require_signals4();
  var isWin = /^win/i.test(process.platform);
  var EE = require("events");
  if (typeof EE !== "function") {
    EE = EE.EventEmitter;
  }
  var emitter;
  if (process.__signal_exit_emitter__) {
    emitter = process.__signal_exit_emitter__;
  } else {
    emitter = process.__signal_exit_emitter__ = new EE();
    emitter.count = 0;
    emitter.emitted = {};
  }
  if (!emitter.infinite) {
    emitter.setMaxListeners(Infinity);
    emitter.infinite = true;
  }
  module2.exports = function(cb, opts) {
    assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
    if (loaded === false) {
      load();
    }
    var ev = "exit";
    if (opts && opts.alwaysLast) {
      ev = "afterexit";
    }
    var remove = function() {
      emitter.removeListener(ev, cb);
      if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
        unload();
      }
    };
    emitter.on(ev, cb);
    return remove;
  };
  module2.exports.unload = unload;
  function unload() {
    if (!loaded) {
      return;
    }
    loaded = false;
    signals.forEach(function(sig) {
      try {
        process.removeListener(sig, sigListeners[sig]);
      } catch (er) {
      }
    });
    process.emit = originalProcessEmit;
    process.reallyExit = originalProcessReallyExit;
    emitter.count -= 1;
  }
  function emit(event, code, signal) {
    if (emitter.emitted[event]) {
      return;
    }
    emitter.emitted[event] = true;
    emitter.emit(event, code, signal);
  }
  var sigListeners = {};
  signals.forEach(function(sig) {
    sigListeners[sig] = function listener() {
      var listeners = process.listeners(sig);
      if (listeners.length === emitter.count) {
        unload();
        emit("exit", null, sig);
        emit("afterexit", null, sig);
        if (isWin && sig === "SIGHUP") {
          sig = "SIGINT";
        }
        process.kill(process.pid, sig);
      }
    };
  });
  module2.exports.signals = function() {
    return signals;
  };
  module2.exports.load = load;
  var loaded = false;
  function load() {
    if (loaded) {
      return;
    }
    loaded = true;
    emitter.count += 1;
    signals = signals.filter(function(sig) {
      try {
        process.on(sig, sigListeners[sig]);
        return true;
      } catch (er) {
        return false;
      }
    });
    process.emit = processEmit;
    process.reallyExit = processReallyExit;
  }
  var originalProcessReallyExit = process.reallyExit;
  function processReallyExit(code) {
    process.exitCode = code || 0;
    emit("exit", process.exitCode, null);
    emit("afterexit", process.exitCode, null);
    originalProcessReallyExit.call(process, process.exitCode);
  }
  var originalProcessEmit = process.emit;
  function processEmit(ev, arg) {
    if (ev === "exit") {
      if (arg !== void 0) {
        process.exitCode = arg;
      }
      var ret = originalProcessEmit.apply(this, arguments);
      emit("exit", process.exitCode, null);
      emit("afterexit", process.exitCode, null);
      return ret;
    } else {
      return originalProcessEmit.apply(this, arguments);
    }
  }
});

// ../../node_modules/.pnpm/execa@5.0.0/node_modules/execa/lib/kill.js
var require_kill2 = __commonJS2((exports2, module2) => {
  "use strict";
  var os = require("os");
  var onExit = require_signal_exit2();
  var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
  var spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
    const killResult = kill(signal);
    setKillTimeout(kill, signal, options, killResult);
    return killResult;
  };
  var setKillTimeout = (kill, signal, options, killResult) => {
    if (!shouldForceKill(signal, options, killResult)) {
      return;
    }
    const timeout = getForceKillAfterTimeout(options);
    const t = setTimeout(() => {
      kill("SIGKILL");
    }, timeout);
    if (t.unref) {
      t.unref();
    }
  };
  var shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {
    return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
  };
  var isSigterm = (signal) => {
    return signal === os.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
  };
  var getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {
    if (forceKillAfterTimeout === true) {
      return DEFAULT_FORCE_KILL_TIMEOUT;
    }
    if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
      throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    }
    return forceKillAfterTimeout;
  };
  var spawnedCancel = (spawned, context) => {
    const killResult = spawned.kill();
    if (killResult) {
      context.isCanceled = true;
    }
  };
  var timeoutKill = (spawned, signal, reject) => {
    spawned.kill(signal);
    reject(Object.assign(new Error("Timed out"), {timedOut: true, signal}));
  };
  var setupTimeout = (spawned, {timeout, killSignal = "SIGTERM"}, spawnedPromise) => {
    if (timeout === 0 || timeout === void 0) {
      return spawnedPromise;
    }
    if (!Number.isFinite(timeout) || timeout < 0) {
      throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
    }
    let timeoutId;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutId = setTimeout(() => {
        timeoutKill(spawned, killSignal, reject);
      }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(() => {
      clearTimeout(timeoutId);
    });
    return Promise.race([timeoutPromise, safeSpawnedPromise]);
  };
  var setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {
    if (!cleanup || detached) {
      return timedPromise;
    }
    const removeExitHandler = onExit(() => {
      spawned.kill();
    });
    return timedPromise.finally(() => {
      removeExitHandler();
    });
  };
  module2.exports = {
    spawnedKill,
    spawnedCancel,
    setupTimeout,
    setExitHandler
  };
});

// ../../node_modules/.pnpm/is-stream@2.0.0/node_modules/is-stream/index.js
var require_is_stream2 = __commonJS2((exports2, module2) => {
  "use strict";
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
  module2.exports = isStream;
});

// ../../node_modules/.pnpm/get-stream@6.0.0/node_modules/get-stream/buffer-stream.js
var require_buffer_stream2 = __commonJS2((exports2, module2) => {
  "use strict";
  var {PassThrough: PassThroughStream} = require("stream");
  module2.exports = (options) => {
    options = {...options};
    const {array} = options;
    let {encoding} = options;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || isBuffer);
    } else {
      encoding = encoding || "utf8";
    }
    if (isBuffer) {
      encoding = null;
    }
    const stream = new PassThroughStream({objectMode});
    if (encoding) {
      stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(chunk);
      if (objectMode) {
        length = chunks.length;
      } else {
        length += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return chunks;
      }
      return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = () => length;
    return stream;
  };
});

// ../../node_modules/.pnpm/get-stream@6.0.0/node_modules/get-stream/index.js
var require_get_stream2 = __commonJS2((exports2, module2) => {
  "use strict";
  var {constants: BufferConstants} = require("buffer");
  var stream = require("stream");
  var {promisify} = require("util");
  var bufferStream = require_buffer_stream2();
  var streamPipelinePromisified = promisify(stream.pipeline);
  var MaxBufferError = class extends Error {
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  };
  async function getStream(inputStream, options) {
    if (!inputStream) {
      throw new Error("Expected a stream");
    }
    options = {
      maxBuffer: Infinity,
      ...options
    };
    const {maxBuffer} = options;
    const stream2 = bufferStream(options);
    await new Promise((resolve, reject) => {
      const rejectPromise = (error) => {
        if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
          error.bufferedData = stream2.getBufferedValue();
        }
        reject(error);
      };
      (async () => {
        try {
          await streamPipelinePromisified(inputStream, stream2);
          resolve();
        } catch (error) {
          rejectPromise(error);
        }
      })();
      stream2.on("data", () => {
        if (stream2.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError());
        }
      });
    });
    return stream2.getBufferedValue();
  }
  module2.exports = getStream;
  module2.exports.buffer = (stream2, options) => getStream(stream2, {...options, encoding: "buffer"});
  module2.exports.array = (stream2, options) => getStream(stream2, {...options, array: true});
  module2.exports.MaxBufferError = MaxBufferError;
});

// ../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js
var require_merge_stream2 = __commonJS2((exports2, module2) => {
  "use strict";
  var {PassThrough} = require("stream");
  module2.exports = function() {
    var sources = [];
    var output = new PassThrough({objectMode: true});
    output.setMaxListeners(0);
    output.add = add2;
    output.isEmpty = isEmpty;
    output.on("unpipe", remove);
    Array.prototype.slice.call(arguments).forEach(add2);
    return output;
    function add2(source) {
      if (Array.isArray(source)) {
        source.forEach(add2);
        return this;
      }
      sources.push(source);
      source.once("end", remove.bind(null, source));
      source.once("error", output.emit.bind(output, "error"));
      source.pipe(output, {end: false});
      return this;
    }
    function isEmpty() {
      return sources.length == 0;
    }
    function remove(source) {
      sources = sources.filter(function(it) {
        return it !== source;
      });
      if (!sources.length && output.readable) {
        output.end();
      }
    }
  };
});

// ../../node_modules/.pnpm/execa@5.0.0/node_modules/execa/lib/stream.js
var require_stream6 = __commonJS2((exports2, module2) => {
  "use strict";
  var isStream = require_is_stream2();
  var getStream = require_get_stream2();
  var mergeStream = require_merge_stream2();
  var handleInput = (spawned, input) => {
    if (input === void 0 || spawned.stdin === void 0) {
      return;
    }
    if (isStream(input)) {
      input.pipe(spawned.stdin);
    } else {
      spawned.stdin.end(input);
    }
  };
  var makeAllStream = (spawned, {all}) => {
    if (!all || !spawned.stdout && !spawned.stderr) {
      return;
    }
    const mixed = mergeStream();
    if (spawned.stdout) {
      mixed.add(spawned.stdout);
    }
    if (spawned.stderr) {
      mixed.add(spawned.stderr);
    }
    return mixed;
  };
  var getBufferedData = async (stream, streamPromise) => {
    if (!stream) {
      return;
    }
    stream.destroy();
    try {
      return await streamPromise;
    } catch (error) {
      return error.bufferedData;
    }
  };
  var getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {
    if (!stream || !buffer) {
      return;
    }
    if (encoding) {
      return getStream(stream, {encoding, maxBuffer});
    }
    return getStream.buffer(stream, {maxBuffer});
  };
  var getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {
    const stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});
    const stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});
    const allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});
    try {
      return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
    } catch (error) {
      return Promise.all([
        {error, signal: error.signal, timedOut: error.timedOut},
        getBufferedData(stdout, stdoutPromise),
        getBufferedData(stderr, stderrPromise),
        getBufferedData(all, allPromise)
      ]);
    }
  };
  var validateInputSync = ({input}) => {
    if (isStream(input)) {
      throw new TypeError("The `input` option cannot be a stream in sync mode");
    }
  };
  module2.exports = {
    handleInput,
    makeAllStream,
    getSpawnedResult,
    validateInputSync
  };
});

// ../../node_modules/.pnpm/execa@5.0.0/node_modules/execa/lib/promise.js
var require_promise2 = __commonJS2((exports2, module2) => {
  "use strict";
  var nativePromisePrototype = (async () => {
  })().constructor.prototype;
  var descriptors = ["then", "catch", "finally"].map((property) => [
    property,
    Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
  ]);
  var mergePromise = (spawned, promise) => {
    for (const [property, descriptor] of descriptors) {
      const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
      Reflect.defineProperty(spawned, property, {...descriptor, value});
    }
    return spawned;
  };
  var getSpawnedPromise = (spawned) => {
    return new Promise((resolve, reject) => {
      spawned.on("exit", (exitCode, signal) => {
        resolve({exitCode, signal});
      });
      spawned.on("error", (error) => {
        reject(error);
      });
      if (spawned.stdin) {
        spawned.stdin.on("error", (error) => {
          reject(error);
        });
      }
    });
  };
  module2.exports = {
    mergePromise,
    getSpawnedPromise
  };
});

// ../../node_modules/.pnpm/execa@5.0.0/node_modules/execa/lib/command.js
var require_command2 = __commonJS2((exports2, module2) => {
  "use strict";
  var SPACES_REGEXP = / +/g;
  var joinCommand = (file, args = []) => {
    if (!Array.isArray(args)) {
      return file;
    }
    return [file, ...args].join(" ");
  };
  var parseCommand = (command) => {
    const tokens = [];
    for (const token of command.trim().split(SPACES_REGEXP)) {
      const previousToken = tokens[tokens.length - 1];
      if (previousToken && previousToken.endsWith("\\")) {
        tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
      } else {
        tokens.push(token);
      }
    }
    return tokens;
  };
  module2.exports = {
    joinCommand,
    parseCommand
  };
});

// ../../node_modules/.pnpm/execa@5.0.0/node_modules/execa/index.js
var require_execa2 = __commonJS2((exports2, module2) => {
  "use strict";
  var path2 = require("path");
  var childProcess = require("child_process");
  var crossSpawn = require_cross_spawn2();
  var stripFinalNewline = require_strip_final_newline2();
  var npmRunPath = require_npm_run_path2();
  var onetime = require_onetime2();
  var makeError = require_error3();
  var normalizeStdio = require_stdio2();
  var {spawnedKill, spawnedCancel, setupTimeout, setExitHandler} = require_kill2();
  var {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = require_stream6();
  var {mergePromise, getSpawnedPromise} = require_promise2();
  var {joinCommand, parseCommand} = require_command2();
  var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
  var getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
    const env = extendEnv ? {...process.env, ...envOption} : envOption;
    if (preferLocal) {
      return npmRunPath.env({env, cwd: localDir, execPath});
    }
    return env;
  };
  var handleArguments = (file, args, options = {}) => {
    const parsed = crossSpawn._parse(file, args, options);
    file = parsed.command;
    args = parsed.args;
    options = parsed.options;
    options = {
      maxBuffer: DEFAULT_MAX_BUFFER,
      buffer: true,
      stripFinalNewline: true,
      extendEnv: true,
      preferLocal: false,
      localDir: options.cwd || process.cwd(),
      execPath: process.execPath,
      encoding: "utf8",
      reject: true,
      cleanup: true,
      all: false,
      windowsHide: true,
      ...options
    };
    options.env = getEnv(options);
    options.stdio = normalizeStdio(options);
    if (process.platform === "win32" && path2.basename(file, ".exe") === "cmd") {
      args.unshift("/q");
    }
    return {file, args, options, parsed};
  };
  var handleOutput = (options, value, error) => {
    if (typeof value !== "string" && !Buffer.isBuffer(value)) {
      return error === void 0 ? void 0 : "";
    }
    if (options.stripFinalNewline) {
      return stripFinalNewline(value);
    }
    return value;
  };
  var execa = (file, args, options) => {
    const parsed = handleArguments(file, args, options);
    const command = joinCommand(file, args);
    let spawned;
    try {
      spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
    } catch (error) {
      const dummySpawned = new childProcess.ChildProcess();
      const errorPromise = Promise.reject(makeError({
        error,
        stdout: "",
        stderr: "",
        all: "",
        command,
        parsed,
        timedOut: false,
        isCanceled: false,
        killed: false
      }));
      return mergePromise(dummySpawned, errorPromise);
    }
    const spawnedPromise = getSpawnedPromise(spawned);
    const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
    const processDone = setExitHandler(spawned, parsed.options, timedPromise);
    const context = {isCanceled: false};
    spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
    spawned.cancel = spawnedCancel.bind(null, spawned, context);
    const handlePromise = async () => {
      const [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
      const stdout = handleOutput(parsed.options, stdoutResult);
      const stderr = handleOutput(parsed.options, stderrResult);
      const all = handleOutput(parsed.options, allResult);
      if (error || exitCode !== 0 || signal !== null) {
        const returnedError = makeError({
          error,
          exitCode,
          signal,
          stdout,
          stderr,
          all,
          command,
          parsed,
          timedOut,
          isCanceled: context.isCanceled,
          killed: spawned.killed
        });
        if (!parsed.options.reject) {
          return returnedError;
        }
        throw returnedError;
      }
      return {
        command,
        exitCode: 0,
        stdout,
        stderr,
        all,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    const handlePromiseOnce = onetime(handlePromise);
    handleInput(spawned, parsed.options.input);
    spawned.all = makeAllStream(spawned, parsed.options);
    return mergePromise(spawned, handlePromiseOnce);
  };
  module2.exports = execa;
  module2.exports.sync = (file, args, options) => {
    const parsed = handleArguments(file, args, options);
    const command = joinCommand(file, args);
    validateInputSync(parsed.options);
    let result;
    try {
      result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
    } catch (error) {
      throw makeError({
        error,
        stdout: "",
        stderr: "",
        all: "",
        command,
        parsed,
        timedOut: false,
        isCanceled: false,
        killed: false
      });
    }
    const stdout = handleOutput(parsed.options, result.stdout, result.error);
    const stderr = handleOutput(parsed.options, result.stderr, result.error);
    if (result.error || result.status !== 0 || result.signal !== null) {
      const error = makeError({
        stdout,
        stderr,
        error: result.error,
        signal: result.signal,
        exitCode: result.status,
        command,
        parsed,
        timedOut: result.error && result.error.code === "ETIMEDOUT",
        isCanceled: false,
        killed: result.signal !== null
      });
      if (!parsed.options.reject) {
        return error;
      }
      throw error;
    }
    return {
      command,
      exitCode: 0,
      stdout,
      stderr,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  };
  module2.exports.command = (command, options) => {
    const [file, ...args] = parseCommand(command);
    return execa(file, args, options);
  };
  module2.exports.commandSync = (command, options) => {
    const [file, ...args] = parseCommand(command);
    return execa.sync(file, args, options);
  };
  module2.exports.node = (scriptPath, args, options = {}) => {
    if (args && !Array.isArray(args) && typeof args === "object") {
      options = args;
      args = [];
    }
    const stdio = normalizeStdio.node(options);
    const defaultExecArgv = process.execArgv.filter((arg) => !arg.startsWith("--inspect"));
    const {
      nodePath = process.execPath,
      nodeOptions = defaultExecArgv
    } = options;
    return execa(nodePath, [
      ...nodeOptions,
      scriptPath,
      ...Array.isArray(args) ? args : []
    ], {
      ...options,
      stdin: void 0,
      stdout: void 0,
      stderr: void 0,
      stdio,
      shell: false
    });
  };
});

// ../../node_modules/.pnpm/retry@0.12.0/node_modules/retry/lib/retry_operation.js
var require_retry_operation2 = __commonJS2((exports2, module2) => {
  function RetryOperation(timeouts, options) {
    if (typeof options === "boolean") {
      options = {forever: options};
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  module2.exports = RetryOperation;
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts;
  };
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.unshift(new Error("RetryOperation timeout occurred"));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === void 0) {
      if (this._cachedTimeouts) {
        this._errors.splice(this._errors.length - 1, this._errors.length);
        this._timeouts = this._cachedTimeouts.slice(0);
        timeout = this._timeouts.shift();
      } else {
        return false;
      }
    }
    var self = this;
    var timer = setTimeout(function() {
      self._attempts++;
      if (self._operationTimeoutCb) {
        self._timeout = setTimeout(function() {
          self._operationTimeoutCb(self._attempts);
        }, self._operationTimeout);
        if (self._options.unref) {
          self._timeout.unref();
        }
      }
      self._fn(self._attempts);
    }, timeout);
    if (this._options.unref) {
      timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self._operationTimeoutCb();
      }, self._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function(fn) {
    console.log("Using RetryOperation.try() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = function(fn) {
    console.log("Using RetryOperation.start() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0; i < this._errors.length; i++) {
      var error = this._errors[i];
      var message = error.message;
      var count = (counts[message] || 0) + 1;
      counts[message] = count;
      if (count >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count;
      }
    }
    return mainError;
  };
});

// ../../node_modules/.pnpm/retry@0.12.0/node_modules/retry/lib/retry.js
var require_retry3 = __commonJS2((exports2) => {
  var RetryOperation = require_retry_operation2();
  exports2.operation = function(options) {
    var timeouts = exports2.timeouts(options);
    return new RetryOperation(timeouts, {
      forever: options && options.forever,
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports2.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i = 0; i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }
    timeouts.sort(function(a, b) {
      return a - b;
    });
    return timeouts;
  };
  exports2.createTimeout = function(attempt, opts) {
    var random2 = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random2 * opts.minTimeout * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports2.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          methods.push(key);
        }
      }
    }
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports2.operation(options);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
});

// ../../node_modules/.pnpm/retry@0.12.0/node_modules/retry/index.js
var require_retry4 = __commonJS2((exports2, module2) => {
  module2.exports = require_retry3();
});

// ../../node_modules/.pnpm/p-retry@4.5.0/node_modules/p-retry/index.js
var require_p_retry2 = __commonJS2((exports2, module2) => {
  "use strict";
  var retry = require_retry4();
  var networkErrorMsgs = [
    "Failed to fetch",
    "NetworkError when attempting to fetch resource",
    "The Internet connection appears to be offline",
    "Network request failed"
  ];
  var AbortError = class extends Error {
    constructor(message) {
      super();
      if (message instanceof Error) {
        this.originalError = message;
        ({message} = message);
      } else {
        this.originalError = new Error(message);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message;
    }
  };
  var decorateErrorWithCounts = (error, attemptNumber, options) => {
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
  };
  var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
  var pRetry = (input, options) => new Promise((resolve, reject) => {
    options = {
      onFailedAttempt: () => {
      },
      retries: 10,
      ...options
    };
    const operation = retry.operation(options);
    operation.attempt(async (attemptNumber) => {
      try {
        resolve(await input(attemptNumber));
      } catch (error) {
        if (!(error instanceof Error)) {
          reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
          return;
        }
        if (error instanceof AbortError) {
          operation.stop();
          reject(error.originalError);
        } else if (error instanceof TypeError && !isNetworkError(error.message)) {
          operation.stop();
          reject(error);
        } else {
          decorateErrorWithCounts(error, attemptNumber, options);
          try {
            await options.onFailedAttempt(error);
          } catch (error2) {
            reject(error2);
            return;
          }
          if (!operation.retry(error)) {
            reject(operation.mainError());
          }
        }
      }
    });
  });
  module2.exports = pRetry;
  module2.exports.default = pRetry;
  module2.exports.AbortError = AbortError;
});

// ../engine-core/dist/byline.js
var require_byline2 = __commonJS2((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createLineStream = void 0;
  var stream = require("stream");
  var util = require("util");
  function byline(readStream, options) {
    return module2.exports.createStream(readStream, options);
  }
  exports2.default = byline;
  module2.exports.createStream = function(readStream, options) {
    if (readStream) {
      return createLineStream(readStream, options);
    } else {
      return new LineStream(options);
    }
  };
  function createLineStream(readStream, options) {
    if (!readStream) {
      throw new Error("expected readStream");
    }
    if (!readStream.readable) {
      throw new Error("readStream must be readable");
    }
    var ls = new LineStream(options);
    readStream.pipe(ls);
    return ls;
  }
  exports2.createLineStream = createLineStream;
  module2.exports.LineStream = LineStream;
  function LineStream(options) {
    stream.Transform.call(this, options);
    options = options || {};
    this._readableState.objectMode = true;
    this._lineBuffer = [];
    this._keepEmptyLines = options.keepEmptyLines || false;
    this._lastChunkEndedWithCR = false;
    this.on("pipe", function(src) {
      if (!this.encoding) {
        if (src instanceof stream.Readable) {
          this.encoding = src._readableState.encoding;
        }
      }
    });
  }
  util.inherits(LineStream, stream.Transform);
  LineStream.prototype._transform = function(chunk, encoding, done) {
    encoding = encoding || "utf8";
    if (Buffer.isBuffer(chunk)) {
      if (encoding == "buffer") {
        chunk = chunk.toString();
        encoding = "utf8";
      } else {
        chunk = chunk.toString(encoding);
      }
    }
    this._chunkEncoding = encoding;
    var lines = chunk.split(/\r\n|\r|\n/g);
    if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
      lines.shift();
    }
    if (this._lineBuffer.length > 0) {
      this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
      lines.shift();
    }
    this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
    this._lineBuffer = this._lineBuffer.concat(lines);
    this._pushBuffer(encoding, 1, done);
  };
  LineStream.prototype._pushBuffer = function(encoding, keep, done) {
    while (this._lineBuffer.length > keep) {
      var line = this._lineBuffer.shift();
      if (this._keepEmptyLines || line.length > 0) {
        if (!this.push(this._reencode(line, encoding))) {
          var self = this;
          setImmediate(function() {
            self._pushBuffer(encoding, keep, done);
          });
          return;
        }
      }
    }
    done();
  };
  LineStream.prototype._flush = function(done) {
    this._pushBuffer(this._chunkEncoding, 0, done);
  };
  LineStream.prototype._reencode = function(line, chunkEncoding) {
    if (this.encoding && this.encoding != chunkEncoding) {
      return Buffer.from(line, chunkEncoding).toString(this.encoding);
    } else if (this.encoding) {
      return line;
    } else {
      return Buffer.from(line, chunkEncoding);
    }
  };
});

// ../engine-core/dist/omit.js
var require_omit = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.omit = void 0;
  function omit2(obj, keys2) {
    return Object.keys(obj).filter((key) => !keys2.includes(key)).reduce((result, key) => {
      result[key] = obj[key];
      return result;
    }, {});
  }
  exports2.omit = omit2;
});

// ../engine-core/dist/printGeneratorConfig.js
var require_printGeneratorConfig = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.printDatamodelObject = exports2.GeneratorConfigClass = exports2.printGeneratorConfig = void 0;
  var indent_string_1 = __importDefault2(require_indent_string2());
  function printGeneratorConfig(config2) {
    return String(new GeneratorConfigClass(config2));
  }
  exports2.printGeneratorConfig = printGeneratorConfig;
  var GeneratorConfigClass = class {
    constructor(config2) {
      this.config = config2;
    }
    toString() {
      const {config: config2} = this;
      const obj = JSON.parse(JSON.stringify({
        provider: config2.provider.fromEnvVar ? `env("${config2.provider.fromEnvVar}")` : config2.provider.value,
        binaryTargets: config2.binaryTargets || void 0
      }));
      return `generator ${config2.name} {
${indent_string_1.default(printDatamodelObject(obj), 2)}
}`;
    }
  };
  exports2.GeneratorConfigClass = GeneratorConfigClass;
  function printDatamodelObject(obj) {
    const maxLength = Object.keys(obj).reduce((max2, curr) => Math.max(max2, curr.length), 0);
    return Object.entries(obj).map(([key, value]) => `${key.padEnd(maxLength)} = ${niceStringify(value)}`).join("\n");
  }
  exports2.printDatamodelObject = printDatamodelObject;
  function niceStringify(value) {
    return JSON.parse(JSON.stringify(value, (_, value2) => {
      if (Array.isArray(value2)) {
        return `[${value2.map((element) => JSON.stringify(element)).join(", ")}]`;
      }
      return JSON.stringify(value2);
    }));
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/node/http-parser.js
var require_http_parser = __commonJS2((exports2, module2) => {
  "use strict";
  var common = require("_http_common");
  if (common.HTTPParser) {
    module2.exports = common.HTTPParser;
  } else {
    module2.exports = process.binding("http_parser").HTTPParser;
  }
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS2((exports2, module2) => {
  module2.exports = {
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kIdleTimeout: Symbol("idle timeout"),
    kIdleTimeoutValue: Symbol("idle timeout value"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kTLSServerName: Symbol("server name"),
    kHost: Symbol("host"),
    kTLSOpts: Symbol("TLS Options"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol("destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelinig"),
    kSocketPath: Symbol("socket path"),
    kSocket: Symbol("socket"),
    kTLSSession: Symbol("tls session cache"),
    kHostHeader: Symbol("host header"),
    kAgentOpts: Symbol("agent opts"),
    kAgentCache: Symbol("agent cache")
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/errors.js
var require_errors2 = __commonJS2((exports2, module2) => {
  "use strict";
  var UndiciError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
  };
  var HeadersTimeoutError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersTimeoutError);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  };
  var BodyTimeoutError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, BodyTimeoutError);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
  };
  var InvalidArgumentError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidArgumentError);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
  };
  var InvalidReturnValueError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidReturnValueError);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  };
  var RequestAbortedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestAbortedError);
      this.name = "RequestAbortedError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
  };
  var InformationalError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InformationalError);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
  };
  var ContentLengthMismatchError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ContentLengthMismatchError);
      this.name = "ContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_CONTENT_LENGTH_MISMATCH";
    }
  };
  var TrailerMismatchError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, TrailerMismatchError);
      this.name = "TrailerMismatchError";
      this.message = message || "Trailers does not match trailer header";
      this.code = "UND_ERR_TRAILER_MISMATCH";
    }
  };
  var ClientDestroyedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientDestroyedError);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
  };
  var ClientClosedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientClosedError);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
  };
  var SocketError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, SocketError);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
    }
  };
  var NotSupportedError = class extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
  };
  module2.exports = {
    UndiciError,
    HeadersTimeoutError,
    BodyTimeoutError,
    ContentLengthMismatchError,
    TrailerMismatchError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/util.js
var require_util6 = __commonJS2((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var {kDestroyed} = require_symbols();
  var {IncomingMessage} = require("http");
  var util = require("util");
  var net = require("net");
  var {InvalidArgumentError} = require_errors2();
  function nop() {
  }
  function isStream(body) {
    return !!(body && typeof body.on === "function");
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("invalid url");
    }
    if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
      throw new InvalidArgumentError("invalid port");
    }
    if (url.hostname != null && typeof url.hostname !== "string") {
      throw new InvalidArgumentError("invalid hostname");
    }
    if (!/https?/.test(url.protocol)) {
      throw new InvalidArgumentError("invalid protocol");
    }
    if (!(url instanceof URL)) {
      const port = url.port || {
        "http:": 80,
        "https:": 443
      }[url.protocol];
      assert(port != null);
      const path2 = url.path || `${url.pathname || "/"}${url.search || ""}`;
      url = new URL(`${url.protocol}//${url.hostname}:${port}${path2}`);
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (/\/.+/.test(url.pathname) || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    let servername = host;
    if (servername.startsWith("[")) {
      const idx = servername.indexOf("]");
      servername = idx === -1 ? servername : servername.substr(1, idx - 1);
    } else {
      servername = servername.split(":", 1)[0];
    }
    if (net.isIP(servername)) {
      servername = null;
    }
    return servername;
  }
  function bodyLength(body) {
    if (body && typeof body.on === "function") {
      const state = body._readableState;
      return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    }
    assert(!body || Number.isFinite(body.byteLength));
    return body ? body.length : 0;
  }
  function isDestroyed(stream) {
    return !stream || !!(stream.destroyed || stream[kDestroyed]);
  }
  function destroy(stream, err) {
    if (!isStream(stream) || isDestroyed(stream)) {
      return;
    }
    if (typeof stream.destroy === "function") {
      if (err || Object.getPrototypeOf(stream).constructor !== IncomingMessage) {
        stream.destroy(err);
      }
    } else if (err) {
      process.nextTick((stream2, err2) => {
        stream2.emit("error", err2);
      }, stream, err);
    }
    if (stream.destroyed !== true) {
      stream[kDestroyed] = true;
    }
  }
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    const m = val.match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1]) * 1e3 : null;
  }
  function parseHeaders(headers, obj = {}) {
    for (let i = 0; i < headers.length; i += 2) {
      const key = headers[i].toLowerCase();
      let val = obj[key];
      if (!val) {
        obj[key] = headers[i + 1];
      } else {
        if (!Array.isArray(val)) {
          val = [val];
          obj[key] = val;
        }
        val.push(headers[i + 1]);
      }
    }
    return obj;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function errnoException(code, syscall) {
    const name = util.getSystemErrorName(code);
    const err = new Error(`${syscall} ${name}`);
    err.errno = err;
    err.code = code;
    err.syscall = syscall;
    return err;
  }
  module2.exports = {
    nop,
    parseOrigin,
    parseURL,
    getServerName,
    errnoException,
    isStream,
    isDestroyed,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    isBuffer,
    queueMicrotask: global.queueMicrotask ? global.queueMicrotask.bind(global) : (cb) => Promise.resolve().then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0))
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/request.js
var require_request = __commonJS2((exports2, module2) => {
  "use strict";
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors2();
  var util = require_util6();
  var assert = require("assert");
  var kHandler = Symbol("handler");
  var REGEXP_ABSOLUTE_URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\x00a1-\xffff0-9]+-?)*[a-z\x00a1-\xffff0-9]+)(?:\.(?:[a-z\x00a1-\xffff0-9]+-?)*[a-z\x00a1-\xffff0-9]+)*(?:\.(?:[a-z\x00a1-\xffff]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/ius;
  var Request = class {
    constructor({
      path: path2,
      method,
      body,
      headers,
      idempotent,
      upgrade
    }, handler) {
      if (typeof path2 !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path2[0] !== "/" && !REGEXP_ABSOLUTE_URL.test(path2)) {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      this.method = method;
      if (body == null) {
        this.body = null;
      } else if (util.isStream(body)) {
        this.body = body;
      } else if (util.isBuffer(body)) {
        this.body = body.length ? body : null;
      } else if (typeof body === "string") {
        this.body = body.length ? Buffer.from(body) : null;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer or a Readable stream");
      }
      this.aborted = false;
      this.upgrade = upgrade || method === "CONNECT" || null;
      this.path = path2;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.host = null;
      this.contentLength = null;
      this.headers = "";
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0; i < headers.length; i += 2) {
          processHeader(this, headers[i + 0], headers[i + 1]);
        }
      } else if (headers && typeof headers === "object") {
        for (const [key, val] of Object.entries(headers)) {
          processHeader(this, key, val);
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (this.upgrade) {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
      this[kHandler] = handler;
    }
    onConnect(abort) {
      assert(!this.aborted);
      return this[kHandler].onConnect(abort);
    }
    onHeaders(statusCode, headers, resume) {
      assert(!this.aborted);
      return this[kHandler].onHeaders(statusCode, headers, resume);
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.upgrade);
      return this[kHandler].onData(chunk);
    }
    onUpgrade(statusCode, headers, socket) {
      assert(!this.aborted);
      assert(this.upgrade);
      return this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      assert(!this.aborted);
      assert(!this.upgrade);
      return this[kHandler].onComplete(trailers);
    }
    onError(err) {
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      util.queueMicrotask(() => this[kHandler].onError(err));
    }
  };
  function processHeader(request, key, val) {
    if (val && typeof val === "object") {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === void 0) {
      return;
    }
    if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
      request.host = val;
      request.headers += `${key}: ${val}\r
`;
    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
      request.contentLength = parseInt(val);
      if (!Number.isFinite(request.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
      throw new InvalidArgumentError("invalid transfer-encoding header");
    } else if (key.length === 10 && key.toLowerCase() === "connection") {
      throw new InvalidArgumentError("invalid connection header");
    } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
      throw new InvalidArgumentError("invalid keep-alive header");
    } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
      throw new InvalidArgumentError("invalid upgrade header");
    } else if (key.length === 6 && key.toLowerCase() === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else {
      request.headers += `${key}: ${val}\r
`;
    }
  }
  module2.exports = Request;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/core/client.js
var require_client = __commonJS2((exports2, module2) => {
  "use strict";
  var net = require("net");
  var tls = require("tls");
  var HTTPParser = require_http_parser();
  var EventEmitter = require("events");
  var assert = require("assert");
  var util = require_util6();
  var Request = require_request();
  var {
    ContentLengthMismatchError,
    TrailerMismatchError,
    InvalidArgumentError,
    RequestAbortedError,
    HeadersTimeoutError,
    ClientDestroyedError,
    ClientClosedError,
    SocketError,
    InformationalError,
    BodyTimeoutError
  } = require_errors2();
  var {
    kUrl,
    kReset,
    kHost,
    kClient,
    kParser,
    kConnect,
    kResuming,
    kWriting,
    kQueue,
    kNeedDrain,
    kTLSServerName,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kTLSOpts,
    kClosed,
    kDestroyed,
    kPendingIdx,
    kRunningIdx,
    kError,
    kOnDestroyed,
    kPipelining,
    kSocket,
    kSocketPath,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kTLSSession,
    kIdleTimeout,
    kIdleTimeoutValue,
    kHeadersTimeout,
    kBodyTimeout
  } = require_symbols();
  var nodeVersions = process.version.split(".");
  var nodeMajorVersion = parseInt(nodeVersions[0].slice(1));
  var nodeMinorVersion = parseInt(nodeVersions[1]);
  var insecureHTTPParser = process.execArgv.includes("--insecure-http-parser");
  function getServerName(client, host) {
    return util.getServerName(host) || client[kTLSOpts] && client[kTLSOpts].servername || util.getServerName(client[kUrl].host || client[kUrl].hostname) || null;
  }
  var Client = class extends EventEmitter {
    constructor(url, {
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls: tls2
    } = {}) {
      super();
      if (keepAlive !== void 0) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      this[kSocket] = null;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || 16384;
      this[kUrl] = util.parseOrigin(url);
      this[kSocketPath] = socketPath;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kClosed] = false;
      this[kDestroyed] = false;
      this[kTLSOpts] = tls2;
      this[kTLSServerName] = getServerName(this);
      this[kHost] = null;
      this[kOnDestroyed] = [];
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kTLSSession] = null;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
    }
    get url() {
      return this[kUrl];
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      resume(this, true);
    }
    get connected() {
      return this[kSocket] && this[kSocket].connecting !== true && (this[kSocket].authorized !== false || this[kSocket].authorizationError) && !this[kSocket].destroyed;
    }
    get pending() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get running() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get size() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get busy() {
      const socket = this[kSocket];
      return socket && (socket[kReset] || socket[kWriting]) || this.size >= (this[kPipelining] || 1) || this.pending > 0;
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    [kConnect](cb) {
      connect(this);
      this.once("connect", cb);
    }
    dispatch(opts, handler) {
      try {
        const request = new Request(opts, handler);
        if (this[kDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (this[kClosed]) {
          throw new ClientClosedError();
        }
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.isStream(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
      }
    }
    close(callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        process.nextTick(callback, new ClientDestroyedError(), null);
        return;
      }
      this[kClosed] = true;
      if (!this.size) {
        this.destroy(callback);
      } else {
        this[kOnDestroyed].push(callback);
      }
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          process.nextTick(callback, null, null);
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError();
      }
      for (const request of this[kQueue].splice(this[kPendingIdx])) {
        request.onError(err);
      }
      this[kClosed] = true;
      this[kDestroyed] = true;
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (const callback2 of callbacks) {
          callback2(null, null);
        }
      };
      if (!this[kSocket]) {
        process.nextTick(onDestroyed);
      } else {
        util.destroy(this[kSocket].on("close", onDestroyed), err);
      }
      resume(this);
    }
  };
  var Parser = class extends HTTPParser {
    constructor(client, socket) {
      if (nodeMajorVersion === 12 && nodeMinorVersion < 19) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, 0);
      } else if (nodeMajorVersion === 12 && nodeMinorVersion >= 19) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], 0);
      } else if (nodeMajorVersion > 12 && nodeMajorVersion < 16) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], insecureHTTPParser, 0);
      } else if (nodeMajorVersion >= 16) {
        super();
        this.initialize(HTTPParser.RESPONSE, {}, client[kMaxHeadersSize], 0);
      } else {
        super(HTTPParser.RESPONSE);
      }
      this.client = client;
      this.socket = socket;
      this.timeout = null;
      this.statusCode = null;
      this.upgrade = false;
      this.headers = null;
      this.shouldKeepAlive = false;
      this.request = null;
      this.paused = false;
      this.resuming = false;
      this.queue = [];
      this._resume = () => {
        if (!this.paused || this.resuming) {
          return;
        }
        this.paused = false;
        this.resuming = true;
        while (this.queue.length) {
          const [fn, ...args] = this.queue.shift();
          Reflect.apply(fn, this, args);
          if (this.paused) {
            this.resuming = false;
            return;
          }
        }
        this.resuming = false;
        socketResume(this.socket);
      };
      this._pause = () => {
        if (this.paused) {
          return;
        }
        this.paused = true;
        socketPause(this.socket);
      };
    }
    [HTTPParser.kOnHeaders](rawHeaders) {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnHeaders], rawHeaders]);
        return;
      }
      if (this.headers) {
        Array.prototype.push.apply(this.headers, rawHeaders);
      } else {
        this.headers = rawHeaders;
      }
    }
    [HTTPParser.kOnExecute](ret) {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnExecute], ret]);
        return;
      }
      const {upgrade, socket} = this;
      if (!Number.isFinite(ret)) {
        assert(ret instanceof Error);
        util.destroy(socket, ret);
        return;
      }
      if (upgrade && !socket.destroyed) {
        const {client, headers, statusCode, request} = this;
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!socket.isPaused());
        assert(socket._handle && socket._handle.reading);
        assert(request.upgrade);
        this.headers = null;
        this.statusCode = null;
        this.request = null;
        socket._readableState.flowing = null;
        socket.unshift(this.getCurrentBuffer().slice(ret));
        try {
          request.onUpgrade(statusCode, headers, socket);
          if (!socket.destroyed && !request.aborted) {
            detachSocket(socket);
            client[kSocket] = null;
            client[kQueue][client[kRunningIdx]++] = null;
            client.emit("disconnect", new InformationalError("upgrade"));
          }
          resume(client);
        } catch (err) {
          util.destroy(socket, err);
        }
      }
    }
    [HTTPParser.kOnHeadersComplete](versionMajor, versionMinor, rawHeaders, method, url, statusCode, statusMessage, upgrade, shouldKeepAlive) {
      if (this.paused) {
        this.queue.push([
          this[HTTPParser.kOnHeadersComplete],
          versionMajor,
          versionMinor,
          rawHeaders,
          method,
          url,
          statusCode,
          statusMessage,
          upgrade,
          shouldKeepAlive
        ]);
        return;
      }
      const {client, socket} = this;
      const request = client[kQueue][client[kRunningIdx]];
      if (socket.destroyed) {
        return;
      }
      clearTimeout(this.timeout);
      this.timeout = client[kBodyTimeout] ? setTimeout(onBodyTimeout, client[kBodyTimeout], this) : null;
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util.destroy(socket, new SocketError("bad response"));
        return 1;
      }
      if (request.upgrade !== true && upgrade !== Boolean(request.upgrade)) {
        util.destroy(socket, new SocketError("bad upgrade"));
        return 1;
      }
      if (this.headers) {
        Array.prototype.push.apply(this.headers, rawHeaders);
      } else {
        this.headers = rawHeaders;
      }
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive;
      this.request = request;
      if (request.upgrade) {
        this.unconsume();
        this.upgrade = true;
        return 2;
      }
      let keepAlive;
      let trailers;
      const {headers} = this;
      this.headers = null;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0];
        const val = headers[n + 1];
        if (!keepAlive && key.length === 10 && key.toLowerCase() === "keep-alive") {
          keepAlive = val;
        } else if (!trailers && key.length === 7 && key.toLowerCase() === "trailer") {
          trailers = val;
        }
      }
      this.trailers = trailers ? trailers.toLowerCase().split(/,\s*/) : null;
      if (shouldKeepAlive && client[kPipelining]) {
        const keepAliveTimeout = keepAlive ? util.parseKeepAliveTimeout(keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      try {
        if (request.onHeaders(statusCode, headers, this._resume) === false) {
          this._pause();
        }
      } catch (err) {
        util.destroy(socket, err);
        return 1;
      }
      return request.method === "HEAD" || statusCode < 200 ? 1 : 0;
    }
    [HTTPParser.kOnBody](chunk, offset, length) {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnBody], chunk, offset, length]);
        return;
      }
      const {socket, statusCode, request, timeout} = this;
      if (socket.destroyed) {
        return;
      }
      if (timeout && timeout.refresh) {
        timeout.refresh();
      }
      assert(statusCode >= 200);
      try {
        if (request.onData(chunk.slice(offset, offset + length)) === false) {
          this._pause();
        }
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    [HTTPParser.kOnMessageComplete]() {
      if (this.paused) {
        this.queue.push([this[HTTPParser.kOnMessageComplete]]);
        return;
      }
      const {client, socket, statusCode, headers, upgrade, request, trailers} = this;
      if (socket.destroyed) {
        return;
      }
      assert(statusCode >= 100);
      assert(this.resuming || socket._handle && socket._handle.reading);
      if (upgrade) {
        assert(statusCode < 300 || request.method === "CONNECT");
        return;
      }
      this.statusCode = null;
      this.headers = null;
      this.request = null;
      this.trailers = null;
      clearTimeout(this.timeout);
      this.timeout = client[kHeadersTimeout] ? setTimeout(onHeadersTimeout, client[kHeadersTimeout], this) : null;
      if (statusCode < 200) {
        return;
      }
      try {
        if (trailers) {
          if (!headers) {
            throw new TrailerMismatchError();
          }
          for (const trailer of trailers) {
            let found = false;
            for (let n = 0; n < headers.length; n += 2) {
              const key = headers[n + 0];
              if (key.length === trailer.length && key.toLowerCase() === trailer.toLowerCase()) {
                found = true;
                break;
              }
            }
            if (!found) {
              throw new TrailerMismatchError();
            }
          }
        }
        try {
          request.onComplete(headers);
        } catch (err) {
          request.onError(err);
        }
      } catch (err) {
        util.destroy(socket, err);
        return;
      }
      client[kQueue][client[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        util.destroy(socket, new InformationalError("reset"));
      } else if (!this.shouldKeepAlive) {
        util.destroy(socket, new InformationalError("reset"));
      } else if (socket[kReset] && !client.running) {
        util.destroy(socket, new InformationalError("reset"));
      } else {
        resume(client);
      }
    }
    destroy() {
      clearTimeout(this.timeout);
      this.timeout = null;
      this.unconsume();
      setImmediate((self) => self.close(), this);
    }
  };
  function onBodyTimeout(self) {
    if (!self.paused) {
      util.destroy(self.socket, new BodyTimeoutError());
    }
  }
  function onHeadersTimeout(self) {
    util.destroy(self.socket, new HeadersTimeoutError());
  }
  function onSocketConnect() {
    const {[kClient]: client} = this;
    client.emit("connect");
    resume(client);
  }
  function onSocketError(err) {
    const {[kClient]: client} = this;
    this[kError] = err;
    if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
      assert(!client.running);
      while (client.pending && client[kQueue][client[kPendingIdx]].host === client[kHost]) {
        client[kQueue][client[kPendingIdx]++].onError(err);
      }
    } else if (!client.running && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      for (const request of client[kQueue].splice(client[kRunningIdx])) {
        request.onError(err);
      }
    }
  }
  function onSocketEnd() {
    util.destroy(this, new SocketError("other side closed"));
  }
  function detachSocket(socket) {
    clearTimeout(socket[kIdleTimeout]);
    socket[kIdleTimeout] = null;
    socket[kIdleTimeoutValue] = null;
    socket[kParser].destroy();
    socket[kParser] = null;
    socket[kClient] = null;
    socket[kError] = null;
    socket.removeListener("session", onSocketSession).removeListener("error", onSocketError).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
  }
  function onSocketClose() {
    const {[kClient]: client} = this;
    const err = this[kError] || new SocketError("closed");
    detachSocket(this);
    client[kSocket] = null;
    if (err.code !== "UND_ERR_INFO") {
      client[kTLSSession] = null;
    }
    if (client[kDestroyed]) {
      assert(!client.pending);
      for (const request of client[kQueue].splice(client[kRunningIdx])) {
        request.onError(err);
      }
      client[kPendingIdx] = client[kRunningIdx];
    } else {
      if (client.running && err.code !== "UND_ERR_INFO") {
        client[kQueue][client[kRunningIdx]].onError(err);
        client[kQueue][client[kRunningIdx]++] = null;
      }
      client[kPendingIdx] = client[kRunningIdx];
      client.emit("disconnect", err);
    }
    resume(client);
  }
  function onSocketSession(session) {
    const {[kClient]: client} = this;
    client[kTLSSession] = session;
  }
  function connect(client) {
    assert(!client[kSocket]);
    const {protocol, port, hostname} = client[kUrl];
    let socket;
    if (protocol === "https:") {
      const tlsOpts = {
        ...client[kTLSOpts],
        servername: client[kTLSServerName],
        session: client[kTLSSession]
      };
      socket = client[kSocketPath] ? tls.connect(client[kSocketPath], tlsOpts) : tls.connect(port || 443, hostname, tlsOpts);
      socket.on("session", onSocketSession);
    } else {
      socket = client[kSocketPath] ? net.connect(client[kSocketPath]) : net.connect(port || 80, hostname);
    }
    client[kSocket] = socket;
    const parser = new Parser(client, socket);
    if (nodeMajorVersion >= 12) {
      assert(socket._handle);
      parser.consume(socket._handle);
    } else {
      assert(socket._handle && socket._handle._externalStream);
      parser.consume(socket._handle._externalStream);
    }
    socket[kIdleTimeout] = null;
    socket[kIdleTimeoutValue] = null;
    socket[kWriting] = false;
    socket[kReset] = false;
    socket[kError] = null;
    socket[kParser] = parser;
    socket[kClient] = client;
    socket.setNoDelay(true).on(protocol === "https:" ? "secureConnect" : "connect", onSocketConnect).on("error", onSocketError).on("end", onSocketEnd).on("close", onSocketClose);
  }
  function socketPause(socket) {
    if (socket._handle && socket._handle.reading) {
      socket._handle.reading = false;
      const err = socket._handle.readStop();
      if (err) {
        socket.destroy(util.errnoException(err, "read"));
      }
    }
  }
  function socketResume(socket) {
    if (socket._handle && !socket._handle.reading) {
      socket._handle.reading = true;
      const err = socket._handle.readStart();
      if (err) {
        socket.destroy(util.errnoException(err, "read"));
      }
    }
  }
  function emitDrain(client) {
    client[kNeedDrain] = 0;
    client.emit("drain");
  }
  function resume(client, sync) {
    if (client[kResuming] === 2) {
      return;
    }
    client[kResuming] = 2;
    _resume(client, sync);
    client[kResuming] = 0;
    if (client[kRunningIdx] > 256) {
      client[kQueue].splice(0, client[kRunningIdx]);
      client[kPendingIdx] -= client[kRunningIdx];
      client[kRunningIdx] = 0;
    }
  }
  function _resume(client, sync) {
    while (true) {
      if (client[kDestroyed]) {
        assert(!client.pending);
        return;
      }
      if (client[kClosed] && !client.size) {
        client.destroy(util.nop);
        continue;
      }
      if (client[kSocket]) {
        const socket2 = client[kSocket];
        const timeout = client.running ? 0 : client[kKeepAliveTimeoutValue];
        if (socket2[kIdleTimeoutValue] !== timeout) {
          clearTimeout(socket2[kIdleTimeout]);
          if (timeout) {
            socket2[kIdleTimeout] = setTimeout((socket3) => {
              util.destroy(socket3, new InformationalError("socket idle timeout"));
            }, timeout, socket2);
          }
          socket2[kIdleTimeoutValue] = timeout;
        }
      }
      if (client.running) {
        const {aborted} = client[kQueue][client[kRunningIdx]];
        if (aborted) {
          util.destroy(client[kSocket]);
          return;
        }
      }
      if (client.busy) {
        client[kNeedDrain] = 2;
      } else if (client[kNeedDrain] === 2) {
        if (sync) {
          client[kNeedDrain] = 1;
          process.nextTick(emitDrain, client);
        } else {
          emitDrain(client);
        }
        continue;
      }
      if (!client.pending) {
        return;
      }
      if (client.running >= (client[kPipelining] || 1)) {
        return;
      }
      const socket = client[kSocket];
      const request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kHost] !== request.host) {
        if (client.running) {
          return;
        }
        client[kHost] = request.host;
        const servername = getServerName(client, request.host);
        if (client[kTLSServerName] !== servername) {
          client[kTLSServerName] = servername;
          client[kTLSSession] = null;
          if (socket) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
      }
      if (!socket) {
        connect(client);
        return;
      }
      if (!client.connected) {
        return;
      }
      if (socket[kWriting] || socket[kReset]) {
        return;
      }
      if (client.running && !request.idempotent) {
        return;
      }
      if (client.running && request.upgrade) {
        return;
      }
      if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {
        request.body.on("data", function() {
          assert(false);
        }).on("error", function(err) {
          request.onError(err);
        }).on("end", function() {
          util.destroy(this);
        });
        request.body = null;
      }
      if (client.running && util.isStream(request.body)) {
        return;
      }
      if (!request.aborted && write(client, request)) {
        const parser = client[kSocket][kParser];
        if (!parser.timeout && client[kHeadersTimeout]) {
          parser.timeout = setTimeout(onHeadersTimeout, client[kHeadersTimeout], parser);
        }
        client[kPendingIdx]++;
      } else {
        client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
  }
  function write(client, request) {
    const {body, method, path: path2, host, upgrade, headers} = request;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    let contentLength = util.bodyLength(body);
    if (contentLength === null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (request.contentLength !== null && request.contentLength !== contentLength) {
      request.onError(new ContentLengthMismatchError());
      return false;
    }
    if (request.aborted) {
      return false;
    }
    try {
      request.onConnect((err) => {
        if (request.aborted) {
          return;
        }
        request.onError(err || new RequestAbortedError());
        if (client[kResuming] === 0) {
          resume(client, true);
        }
      });
    } catch (err) {
      request.onError(err);
    }
    if (request.aborted) {
      return false;
    }
    const socket = client[kSocket];
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade) {
      socket[kReset] = true;
    }
    let header;
    if (typeof upgrade === "string") {
      header = `${method} ${path2} HTTP/1.1\r
connection: upgrade\r
upgrade: ${upgrade}\r
`;
    } else if (client[kPipelining]) {
      header = `${method} ${path2} HTTP/1.1\r
connection: keep-alive\r
`;
    } else {
      header = `${method} ${path2} HTTP/1.1\r
connection: close\r
`;
    }
    if (!host) {
      header += client[kHostHeader];
    }
    if (headers) {
      header += headers;
    }
    if (!body) {
      if (contentLength === 0) {
        socket.write(`${header}content-length: ${contentLength}\r
\r
\r
`, "ascii");
      } else {
        assert(contentLength === null, "no body must not have content length");
        socket.write(`${header}\r
`, "ascii");
      }
    } else if (util.isBuffer(body)) {
      assert(contentLength !== null, "buffer body must have content length");
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
      socket.write(body);
      socket.write("\r\n", "ascii");
      socket.uncork();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
    } else {
      socket[kWriting] = true;
      assert(util.isStream(body));
      assert(contentLength !== 0 || !client.running, "stream body cannot be pipelined");
      let finished = false;
      let bytesWritten = 0;
      const onData = function(chunk) {
        try {
          assert(!finished);
          const len = Buffer.byteLength(chunk);
          if (!len) {
            return;
          }
          if (contentLength !== null && bytesWritten + len > contentLength) {
            util.destroy(socket, new ContentLengthMismatchError());
            return;
          }
          if (bytesWritten === 0) {
            if (!expectsPayload) {
              socket[kReset] = true;
            }
            if (contentLength === null) {
              socket.write(`${header}transfer-encoding: chunked\r
`, "ascii");
            } else {
              socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
            }
          }
          if (contentLength === null) {
            socket.write(`\r
${len.toString(16)}\r
`, "ascii");
          }
          bytesWritten += len;
          if (!socket.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        assert(!finished);
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        onFinished(new RequestAbortedError());
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client.running <= 1);
        socket[kWriting] = false;
        if (!err && contentLength !== null && bytesWritten !== contentLength) {
          err = new ContentLengthMismatchError();
        }
        socket.removeListener("drain", onDrain).removeListener("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        util.destroy(body, err);
        if (err) {
          assert(client.running <= 1, "pipeline should only contain this request");
          util.destroy(socket, err);
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
\r
`, "ascii");
          } else {
            socket.write(`${header}\r
`, "ascii");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "ascii");
        }
        resume(client);
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      socket.on("drain", onDrain).on("error", onFinished);
    }
    return true;
  }
  module2.exports = Client;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS2((exports2, module2) => {
  "use strict";
  var kSize = 2048;
  var kMask = kSize - 1;
  var FixedCircularBuffer = class {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === void 0)
        return null;
      this.list[this.bottom] = void 0;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  };
  module2.exports = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer();
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/abort-signal.js
var require_abort_signal = __commonJS2((exports2, module2) => {
  var {RequestAbortedError} = require_errors2();
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  function abort(self) {
    if (self.abort) {
      self.abort();
    } else {
      self.onError(new RequestAbortedError());
    }
  }
  function addSignal(self, signal) {
    self[kSignal] = null;
    self[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self);
      return;
    }
    self[kSignal] = signal;
    self[kListener] = () => {
      abort(self);
    };
    if ("addEventListener" in self[kSignal]) {
      self[kSignal].addEventListener("abort", self[kListener]);
    } else {
      self[kSignal].addListener("abort", self[kListener]);
    }
  }
  function removeSignal(self) {
    if (!self[kSignal]) {
      return;
    }
    if ("removeEventListener" in self[kSignal]) {
      self[kSignal].removeEventListener("abort", self[kListener]);
    } else {
      self[kSignal].removeListener("abort", self[kListener]);
    }
    self[kSignal] = null;
    self[kListener] = null;
  }
  module2.exports = {
    addSignal,
    removeSignal
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-request.js
var require_client_request = __commonJS2((exports2, module2) => {
  "use strict";
  var {Readable} = require("stream");
  var {
    InvalidArgumentError,
    RequestAbortedError
  } = require_errors2();
  var util = require_util6();
  var {AsyncResource: AsyncResource2} = require("async_hooks");
  var {addSignal, removeSignal} = require_abort_signal();
  var kAbort = Symbol("abort");
  var RequestResponse = class extends Readable {
    constructor(resume, abort) {
      super({autoDestroy: true, read: resume});
      this[kAbort] = abort;
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      if (err) {
        this[kAbort]();
      }
      callback(err);
    }
  };
  var RequestHandler = class extends AsyncResource2 {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, method, opaque, body} = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body;
      this.trailers = {};
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onHeaders(statusCode, headers, resume) {
      const {callback, opaque, abort} = this;
      if (statusCode < 200) {
        return;
      }
      const body = new RequestResponse(resume, abort);
      this.callback = null;
      this.res = body;
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers: util.parseHeaders(headers),
        trailers: this.trailers,
        opaque,
        body
      });
    }
    onData(chunk) {
      const {res} = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const {res} = this;
      removeSignal(this);
      if (trailers) {
        util.parseHeaders(trailers, this.trailers);
      }
      res.push(null);
    }
    onError(err) {
      const {res, callback, body, opaque} = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        process.nextTick((self, callback2, err2, opaque2) => {
          self.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
      if (res) {
        this.res = null;
        util.destroy(res, err);
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  };
  function request(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback === "function") {
        process.nextTick(callback, err, {opaque: opts && opts.opaque});
      } else {
        throw err;
      }
    }
  }
  module2.exports = request;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-stream.js
var require_client_stream = __commonJS2((exports2, module2) => {
  "use strict";
  var {finished} = require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors2();
  var util = require_util6();
  var {AsyncResource: AsyncResource2} = require("async_hooks");
  var {addSignal, removeSignal} = require_abort_signal();
  var StreamHandler = class extends AsyncResource2 {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, method, opaque, body} = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.trailers = null;
      this.body = body;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onHeaders(statusCode, headers, resume) {
      const {factory, opaque} = this;
      if (statusCode < 200) {
        return;
      }
      this.factory = null;
      const res = this.runInAsyncScope(factory, null, {
        statusCode,
        headers: util.parseHeaders(headers),
        opaque
      });
      if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
        throw new InvalidReturnValueError("expected Writable");
      }
      res.on("drain", resume);
      finished(res, {readable: false}, (err) => {
        const {callback, res: res2, opaque: opaque2, trailers, abort} = this;
        this.res = null;
        if (err || !res2.readable) {
          util.destroy(res2, err);
        }
        this.callback = null;
        this.runInAsyncScope(callback, null, err || null, {opaque: opaque2, trailers});
        if (err) {
          abort();
        }
      });
      this.res = res;
      const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const {res} = this;
      return res.write(chunk);
    }
    onComplete(trailers) {
      const {res} = this;
      removeSignal(this);
      this.trailers = trailers ? util.parseHeaders(trailers) : {};
      res.end();
    }
    onError(err) {
      const {res, callback, opaque, body} = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        process.nextTick((self, callback2, err2, opaque2) => {
          self.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  };
  function stream(opts, factory, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback === "function") {
        process.nextTick(callback, err, {opaque: opts && opts.opaque});
      } else {
        throw err;
      }
    }
  }
  module2.exports = stream;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-pipeline.js
var require_client_pipeline = __commonJS2((exports2, module2) => {
  "use strict";
  var {
    Readable,
    Duplex,
    PassThrough
  } = require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors2();
  var util = require_util6();
  var {AsyncResource: AsyncResource2} = require("async_hooks");
  var {assert} = require("console");
  var {addSignal, removeSignal} = require_abort_signal();
  var kResume = Symbol("resume");
  var PipelineRequest = class extends Readable {
    constructor() {
      super({autoDestroy: true});
      this[kResume] = null;
    }
    _read() {
      const {[kResume]: resume} = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      assert(err || this._readableState.endEmitted);
      callback(err);
    }
  };
  var PipelineResponse = class extends Readable {
    constructor(resume) {
      super({autoDestroy: true});
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      callback(err);
    }
  };
  var PipelineHandler = class extends AsyncResource2 {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const {signal, method, opaque} = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.handler = handler;
      this.abort = null;
      this.req = new PipelineRequest().on("error", util.nop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const {body} = this;
          if (body && body.resume) {
            body.resume();
          }
        },
        write: (chunk, encoding, callback) => {
          const {req} = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const {body, req, res, ret, abort} = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError();
          }
          if (abort && err) {
            abort();
          }
          util.destroy(body, err);
          util.destroy(req, err);
          util.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const {req} = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort) {
      const {ret} = this;
      if (ret.destroyed) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onHeaders(statusCode, headers, resume) {
      const {opaque, handler} = this;
      if (statusCode < 200) {
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers: util.parseHeaders(headers),
          opaque,
          body: this.res
        });
      } catch (err) {
        this.res.on("error", util.nop);
        throw err;
      }
      if (!body || typeof body.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body.on("data", (chunk) => {
        const {ret, body: body2} = this;
        if (!ret.push(chunk) && body2.pause) {
          body2.pause();
        }
      }).on("error", (err) => {
        const {ret} = this;
        util.destroy(ret, err);
      }).on("end", () => {
        const {ret} = this;
        ret.push(null);
      }).on("close", () => {
        const {ret} = this;
        if (!ret._readableState.ended) {
          util.destroy(ret, new RequestAbortedError());
        }
      });
      this.body = body;
    }
    onData(chunk) {
      const {res} = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const {res} = this;
      res.push(null);
    }
    onError(err) {
      const {ret} = this;
      this.handler = null;
      util.destroy(ret, err);
    }
  };
  function pipeline(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      const {
        path: path2,
        method,
        headers,
        idempotent,
        signal
      } = opts;
      this.dispatch({
        path: path2,
        method,
        body: pipelineHandler.req,
        headers,
        idempotent,
        signal
      }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  module2.exports = pipeline;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-upgrade.js
var require_client_upgrade = __commonJS2((exports2, module2) => {
  "use strict";
  var {InvalidArgumentError, RequestAbortedError} = require_errors2();
  var {AsyncResource: AsyncResource2} = require("async_hooks");
  var util = require_util6();
  var {addSignal, removeSignal} = require_abort_signal();
  var assert = require("assert");
  var UpgradeHandler = class extends AsyncResource2 {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, opaque} = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onUpgrade(statusCode, headers, socket) {
      const {callback, opaque} = this;
      assert.strictEqual(statusCode, 101);
      removeSignal(this);
      this.callback = null;
      this.runInAsyncScope(callback, null, null, {
        headers: util.parseHeaders(headers),
        socket,
        opaque
      });
    }
    onError(err) {
      const {callback, opaque} = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        process.nextTick((self, callback2, err2, opaque2) => {
          self.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
    }
  };
  function upgrade(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError("invalid callback");
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      const {
        path: path2,
        method,
        headers,
        signal,
        protocol
      } = opts;
      this.dispatch({
        path: path2,
        method: method || "GET",
        headers,
        signal,
        upgrade: protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      process.nextTick(callback, err, {opaque: opts && opts.opaque});
    }
  }
  module2.exports = upgrade;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/client-connect.js
var require_client_connect = __commonJS2((exports2, module2) => {
  "use strict";
  var {InvalidArgumentError, RequestAbortedError} = require_errors2();
  var {AsyncResource: AsyncResource2} = require("async_hooks");
  var util = require_util6();
  var {addSignal, removeSignal} = require_abort_signal();
  var ConnectHandler = class extends AsyncResource2 {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const {signal, opaque} = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort) {
      if (!this.callback) {
        throw new RequestAbortedError();
      }
      this.abort = abort;
    }
    onUpgrade(statusCode, headers, socket) {
      const {callback, opaque} = this;
      removeSignal(this);
      this.callback = null;
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers: util.parseHeaders(headers),
        socket,
        opaque
      });
    }
    onError(err) {
      const {callback, opaque} = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        process.nextTick((self, callback2, err2, opaque2) => {
          self.runInAsyncScope(callback2, null, err2, {opaque: opaque2});
        }, this, callback, err, opaque);
      }
    }
  };
  function connect(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    if (typeof callback !== "function") {
      throw new InvalidArgumentError("invalid callback");
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      const {
        path: path2,
        headers,
        signal
      } = opts;
      this.dispatch({
        path: path2,
        method: "CONNECT",
        headers,
        signal
      }, connectHandler);
    } catch (err) {
      process.nextTick(callback, err, {opaque: opts && opts.opaque});
    }
  }
  module2.exports = connect;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/pool.js
var require_pool = __commonJS2((exports2, module2) => {
  "use strict";
  var EventEmitter = require("events");
  var Client = require_client();
  var {
    ClientClosedError,
    InvalidArgumentError,
    ClientDestroyedError
  } = require_errors2();
  var FixedQueue = require_fixed_queue();
  var util = require_util6();
  var kClients = Symbol("clients");
  var kNeedDrain = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kDestroyed = Symbol("destroyed");
  var kClosedPromise = Symbol("closed promise");
  var kClosedResolve = Symbol("closed resolve");
  var kOptions = Symbol("options");
  var kUrl = Symbol("url");
  var kOnDrain = Symbol("onDrain");
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kPending = Symbol("pending");
  var kConnected = Symbol("connected");
  var kConnections = Symbol("connections");
  var Pool = class extends EventEmitter {
    constructor(origin, {connections, ...options} = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      this[kConnections] = connections || null;
      this[kUrl] = util.parseOrigin(origin);
      this[kOptions] = JSON.parse(JSON.stringify(options));
      this[kQueue] = new FixedQueue();
      this[kClosedPromise] = null;
      this[kClosedResolve] = null;
      this[kDestroyed] = false;
      this[kClients] = [];
      this[kNeedDrain] = false;
      this[kPending] = 0;
      this[kConnected] = 0;
      const pool = this;
      this[kOnDrain] = function onDrain() {
        const queue = pool[kQueue];
        while (!this.busy) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool[kPending]--;
          this.dispatch(item.opts, item.handler);
        }
        if (pool[kNeedDrain] && !this.busy) {
          pool[kNeedDrain] = false;
          pool.emit("drain");
        }
        if (pool[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
        }
      };
      this[kOnConnect] = function onConnect() {
        pool[kConnected]++;
        pool.emit("connect", this);
      };
      this[kOnDisconnect] = function onDisconnect(err) {
        pool[kConnected]--;
        pool.emit("disconnect", this, err);
      };
    }
    get url() {
      return this[kUrl];
    }
    get connected() {
      return this[kConnected];
    }
    get busy() {
      if (this[kPending] > 0) {
        return true;
      }
      if (this[kConnections] && this[kClients].length === this[kConnections]) {
        for (const {busy} of this[kClients]) {
          if (!busy) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
    get pending() {
      let ret = this[kPending];
      for (const {pending} of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get running() {
      let ret = 0;
      for (const {running} of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get size() {
      let ret = this[kPending];
      for (const {size} of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosedPromise] != null;
    }
    dispatch(opts, handler) {
      try {
        if (this[kDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (this[kClosedPromise]) {
          throw new ClientClosedError();
        }
        let client = this[kClients].find((client2) => !client2.busy);
        if (!client) {
          if (!this[kConnections] || this[kClients].length < this[kConnections]) {
            client = new Client(this[kUrl], this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]);
            this[kClients].push(client);
          }
        }
        if (!client) {
          this[kNeedDrain] = true;
          this[kQueue].push({opts, handler});
          this[kPending]++;
        } else {
          client.dispatch(opts, handler);
          if (client.busy && this.busy) {
            this[kNeedDrain] = true;
          }
        }
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
      }
    }
    close(cb) {
      try {
        if (this[kDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (!this[kClosedPromise]) {
          if (this[kQueue].isEmpty()) {
            this[kClosedPromise] = Promise.all(this[kClients].map((c) => c.close()));
          } else {
            this[kClosedPromise] = new Promise((resolve) => {
              this[kClosedResolve] = resolve;
            });
          }
          this[kClosedPromise] = this[kClosedPromise].then(() => {
            this[kDestroyed] = true;
          });
        }
        if (cb) {
          this[kClosedPromise].then(() => cb(null, null));
        } else {
          return this[kClosedPromise];
        }
      } catch (err) {
        if (cb) {
          cb(err);
        } else {
          return Promise.reject(err);
        }
      }
    }
    destroy(err, cb) {
      this[kDestroyed] = true;
      if (typeof err === "function") {
        cb = err;
        err = null;
      }
      if (!err) {
        err = new ClientDestroyedError();
      }
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      const promise = Promise.all(this[kClients].map((c) => c.destroy(err)));
      if (cb) {
        promise.then(() => cb(null, null));
      } else {
        return promise;
      }
    }
  };
  Pool.prototype.request = require_client_request();
  Pool.prototype.stream = require_client_stream();
  Pool.prototype.pipeline = require_client_pipeline();
  Pool.prototype.upgrade = require_client_upgrade();
  Pool.prototype.connect = require_client_connect();
  module2.exports = Pool;
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/lib/agent.js
var require_agent3 = __commonJS2((exports2, module2) => {
  "use strict";
  var {InvalidArgumentError, InvalidReturnValueError} = require_errors2();
  var Pool = require_pool();
  var util = require_util6();
  var {kAgentOpts, kAgentCache} = require_symbols();
  var Agent = class {
    constructor(opts) {
      this[kAgentOpts] = opts;
      this[kAgentCache] = new Map();
    }
    get(origin) {
      if (typeof origin !== "string" || origin === "") {
        throw new InvalidArgumentError("Origin must be a non-empty string.");
      }
      const self = this;
      let pool = self[kAgentCache].get(origin);
      function onDisconnect() {
        if (this.connected === 0 && this.size === 0) {
          this.off("disconnect", onDisconnect);
          self[kAgentCache].delete(origin);
        }
      }
      if (!pool) {
        pool = new Pool(origin, self[kAgentOpts]);
        pool.on("disconnect", onDisconnect);
        self[kAgentCache].set(origin, pool);
      }
      return pool;
    }
    close() {
      const closePromises = [];
      for (const pool of this[kAgentCache].values()) {
        closePromises.push(pool.close());
      }
      return Promise.all(closePromises);
    }
    destroy() {
      const destroyPromises = [];
      for (const pool of this[kAgentCache].values()) {
        destroyPromises.push(pool.destroy());
      }
      return Promise.all(destroyPromises);
    }
  };
  var globalAgent = new Agent({connections: null});
  function setGlobalAgent(agent) {
    if (!agent || typeof agent.get !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    globalAgent = agent;
  }
  function dispatchFromAgent(requestType) {
    return (url, {agent = globalAgent, method = "GET", ...opts} = {}, ...additionalArgs) => {
      if (opts.path != null) {
        throw new InvalidArgumentError("unsupported opts.path");
      }
      const {origin, pathname, search} = util.parseURL(url);
      const path2 = `${pathname || "/"}${search || ""}`;
      const client = agent.get(origin);
      if (client && typeof client[requestType] !== "function") {
        throw new InvalidReturnValueError(`Client returned from Agent.get() does not implement method ${requestType}`);
      }
      return client[requestType]({...opts, method, path: path2}, ...additionalArgs);
    };
  }
  module2.exports = {
    request: dispatchFromAgent("request"),
    stream: dispatchFromAgent("stream"),
    pipeline: dispatchFromAgent("pipeline"),
    connect: dispatchFromAgent("connect"),
    upgrade: dispatchFromAgent("upgrade"),
    setGlobalAgent,
    Agent
  };
});

// ../../node_modules/.pnpm/undici@3.3.6/node_modules/undici/index.js
var require_undici = __commonJS2((exports2, module2) => {
  "use strict";
  var Client = require_client();
  var errors = require_errors2();
  var Pool = require_pool();
  var {Agent, request, stream, pipeline, setGlobalAgent} = require_agent3();
  Client.prototype.request = require_client_request();
  Client.prototype.stream = require_client_stream();
  Client.prototype.pipeline = require_client_pipeline();
  Client.prototype.upgrade = require_client_upgrade();
  Client.prototype.connect = require_client_connect();
  function undici(url, opts) {
    return new Pool(url, opts);
  }
  undici.Pool = Pool;
  undici.Client = Client;
  undici.errors = errors;
  undici.Agent = Agent;
  undici.request = request;
  undici.stream = stream;
  undici.pipeline = pipeline;
  undici.setGlobalAgent = setGlobalAgent;
  module2.exports = undici;
});

// ../engine-core/dist/undici.js
var require_undici2 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Undici = void 0;
  var getStream = require_get_stream2();
  var undici_12 = require_undici();
  var Undici = class {
    constructor(url, moreArgs) {
      this.closed = false;
      this.pool = new undici_12.Pool(url, {
        connections: 100,
        pipelining: 10,
        keepAliveMaxTimeout: 6e5,
        headersTimeout: 0,
        ...moreArgs
      });
    }
    request(body, customHeaders) {
      return new Promise((resolve, reject) => {
        this.pool.request({
          path: "/",
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...customHeaders
          },
          body,
          bodyTimeout: 0
        }, async (err, result) => {
          if (err) {
            reject(err);
          } else {
            const {statusCode, headers, body: body2} = result;
            const data = JSON.parse(await getStream(body2));
            resolve({statusCode, headers, data});
          }
        });
      });
    }
    status() {
      return new Promise((resolve, reject) => {
        this.pool.request({
          path: "/",
          method: "GET"
        }, async (err, result) => {
          if (err) {
            reject(err);
          } else {
            const {statusCode, headers, body} = result;
            const data = JSON.parse(await getStream(body));
            resolve({statusCode, headers, data});
          }
        });
      });
    }
    close() {
      if (!this.closed) {
        this.pool.close(() => {
        });
      }
      this.closed = true;
    }
  };
  exports2.Undici = Undici;
});

// ../engine-core/dist/NodeEngine.js
var require_NodeEngine = __commonJS2((exports, module) => {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.NodeEngine = void 0;
  var debug_1 = __importDefault(require_dist7());
  var engines_1 = require_dist9();
  var get_platform_1 = require_dist10();
  var chalk_1 = __importDefault(require_source2());
  var child_process_1 = require("child_process");
  var events_1 = __importDefault(require("events"));
  var execa_1 = __importDefault(require_execa2());
  var fs_1 = __importDefault(require("fs"));
  var net_1 = __importDefault(require("net"));
  var p_retry_1 = __importDefault(require_p_retry2());
  var path_1 = __importDefault(require("path"));
  var url_1 = require("url");
  var util_1 = require("util");
  var byline_1 = __importDefault(require_byline2());
  var errors_1 = require_errors();
  var log_1 = require_log2();
  var omit_1 = require_omit();
  var printGeneratorConfig_1 = require_printGeneratorConfig();
  var undici_1 = require_undici2();
  var util_2 = require_util5();
  var debug = debug_1.default("prisma:engine");
  var exists = util_1.promisify(fs_1.default.exists);
  var logger = (...args) => {
  };
  var knownPlatforms = [...get_platform_1.platforms, "native"];
  var engines = [];
  var socketPaths = [];
  var MAX_STARTS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
  var MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
  var NodeEngine = class {
    constructor({cwd, datamodelPath, prismaPath, generator, datasources, showColors, logLevel, logQueries, env, flags, clientVersion: clientVersion2, previewFeatures, engineEndpoint, enableDebugLogs, enableEngineDebugMode, dirname, useUds, activeProvider}) {
      var _a;
      this.startCount = 0;
      this.previewFeatures = [];
      this.useUds = false;
      this.stderrLogs = "";
      this.handleRequestError = async (error, graceful = false) => {
        var _a2, _b;
        debug({error});
        if (this.startPromise) {
          await this.startPromise;
        }
        this.throwAsyncErrorIfExists();
        if ((_a2 = this.currentRequestPromise) === null || _a2 === void 0 ? void 0 : _a2.isCanceled) {
          this.throwAsyncErrorIfExists();
        } else if (error.code === "ECONNRESET" || error.code === "ECONNREFUSED" || error.code === "UND_ERR_CLOSED" || error.code === "UND_ERR_SOCKET" || error.code === "UND_ERR_DESTROYED" || error.code === "UND_ERR_ABORTED" || error.message.toLowerCase().includes("client is destroyed") || error.message.toLowerCase().includes("other side closed") || error.message.toLowerCase().includes("the client is closed")) {
          if (this.globalKillSignalReceived && !((_b = this.child) === null || _b === void 0 ? void 0 : _b.connected)) {
            throw new errors_1.PrismaClientUnknownRequestError(`The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited
and your request can't be processed.
You probably have some open handle that prevents your process from exiting.
It could be an open http server or stream that didn't close yet.
We recommend using the \`wtfnode\` package to debug open handles.`, this.clientVersion);
          }
          this.throwAsyncErrorIfExists();
          if (this.startCount > MAX_STARTS) {
            for (let i = 0; i < 5; i++) {
              await new Promise((r) => setTimeout(r, 50));
              this.throwAsyncErrorIfExists(true);
            }
            throw new Error(`Query engine is trying to restart, but can't.
Please look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);
          }
        }
        if (!graceful) {
          this.throwAsyncErrorIfExists(true);
          throw error;
        }
        return false;
      };
      this.dirname = dirname;
      this.useUds = useUds !== null && useUds !== void 0 ? useUds : false;
      this.env = env;
      this.cwd = this.resolveCwd(cwd);
      this.enableDebugLogs = enableDebugLogs !== null && enableDebugLogs !== void 0 ? enableDebugLogs : false;
      this.enableEngineDebugMode = enableEngineDebugMode !== null && enableEngineDebugMode !== void 0 ? enableEngineDebugMode : false;
      this.datamodelPath = datamodelPath;
      this.prismaPath = (_a = process.env.PRISMA_QUERY_ENGINE_BINARY) !== null && _a !== void 0 ? _a : prismaPath;
      this.generator = generator;
      this.datasources = datasources;
      this.logEmitter = new events_1.default();
      this.logEmitter.on("error", () => {
      });
      this.showColors = showColors !== null && showColors !== void 0 ? showColors : false;
      this.logLevel = logLevel;
      this.logQueries = logQueries !== null && logQueries !== void 0 ? logQueries : false;
      this.clientVersion = clientVersion2;
      this.flags = flags !== null && flags !== void 0 ? flags : [];
      this.previewFeatures = previewFeatures !== null && previewFeatures !== void 0 ? previewFeatures : [];
      this.activeProvider = activeProvider;
      initHooks();
      const removedFlags = [
        "middlewares",
        "aggregateApi",
        "distinct",
        "aggregations",
        "insensitiveFilters",
        "atomicNumberOperations",
        "transactionApi",
        "transaction",
        "connectOrCreate",
        "uncheckedScalarInputs",
        "nativeTypes",
        "createMany",
        "groupBy"
      ];
      const removedFlagsUsed = this.previewFeatures.filter((e) => removedFlags.includes(e));
      if (removedFlagsUsed.length > 0 && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
        console.log(`${chalk_1.default.blueBright("info")} The preview flags \`${removedFlagsUsed.join("`, `")}\` were removed, you can now safely remove them from your schema.prisma.`);
      }
      this.previewFeatures = this.previewFeatures.filter((e) => !removedFlags.includes(e));
      this.engineEndpoint = engineEndpoint;
      if (engineEndpoint) {
        const url = new url_1.URL(engineEndpoint);
        this.port = Number(url.port);
      }
      if (this.platform) {
        if (!knownPlatforms.includes(this.platform) && !fs_1.default.existsSync(this.platform)) {
          throw new errors_1.PrismaClientInitializationError(`Unknown ${chalk_1.default.red("PRISMA_QUERY_ENGINE_BINARY")} ${chalk_1.default.redBright.bold(this.platform)}. Possible binaryTargets: ${chalk_1.default.greenBright(knownPlatforms.join(", "))} or a path to the query engine binary.
You may have to run ${chalk_1.default.greenBright("prisma generate")} for your changes to take effect.`, this.clientVersion);
        }
      } else {
        void this.getPlatform();
      }
      if (this.enableDebugLogs) {
        debug_1.default.enable("*");
      }
      engines.push(this);
      this.checkForTooManyEngines();
    }
    setError(err) {
      var _a;
      if (log_1.isRustError(err)) {
        this.lastRustError = err;
        this.logEmitter.emit("error", new errors_1.PrismaClientRustError({
          clientVersion: this.clientVersion,
          error: err
        }));
        if (err.is_panic) {
          this.handlePanic();
        }
      } else if (log_1.isRustErrorLog(err)) {
        this.lastErrorLog = err;
        this.logEmitter.emit("error", new errors_1.PrismaClientRustError({
          clientVersion: this.clientVersion,
          log: err
        }));
        if (((_a = err.fields) === null || _a === void 0 ? void 0 : _a.message) === "PANIC") {
          this.handlePanic();
        }
      } else {
        this.logEmitter.emit("error", err);
      }
    }
    checkForTooManyEngines() {
      if (engines.length >= 10) {
        const runningEngines = engines.filter((e) => e.child);
        if (runningEngines.length === 10) {
          console.warn(`${chalk_1.default.yellow("warn(prisma-client)")} Already 10 Prisma Clients are actively running.`);
        }
      }
    }
    resolveCwd(cwd) {
      if (cwd && fs_1.default.existsSync(cwd) && fs_1.default.lstatSync(cwd).isDirectory()) {
        return cwd;
      }
      return process.cwd();
    }
    on(event, listener) {
      if (event === "beforeExit") {
        this.beforeExitListener = listener;
      } else {
        this.logEmitter.on(event, listener);
      }
    }
    async emitExit() {
      if (this.beforeExitListener) {
        try {
          await this.beforeExitListener();
        } catch (e) {
          console.error(e);
        }
      }
    }
    async getPlatform() {
      if (this.platformPromise) {
        return this.platformPromise;
      }
      this.platformPromise = get_platform_1.getPlatform();
      return this.platformPromise;
    }
    getQueryEnginePath(platform, prefix = __dirname) {
      let queryEnginePath = path_1.default.join(prefix, `query-engine-${platform}`);
      if (platform === "windows") {
        queryEnginePath = `${queryEnginePath}.exe`;
      }
      return queryEnginePath;
    }
    handlePanic() {
      var _a, _b;
      (_a = this.child) === null || _a === void 0 ? void 0 : _a.kill();
      if ((_b = this.currentRequestPromise) === null || _b === void 0 ? void 0 : _b.cancel) {
        this.currentRequestPromise.cancel();
      }
    }
    async resolvePrismaPath() {
      var _a, _b, _c;
      const searchedLocations = [];
      let enginePath;
      if (this.prismaPath) {
        return {prismaPath: this.prismaPath, searchedLocations};
      }
      const platform = await this.getPlatform();
      if (this.platform && this.platform !== platform) {
        this.incorrectlyPinnedBinaryTarget = this.platform;
      }
      this.platform = this.platform || platform;
      if (__filename.includes("NodeEngine")) {
        enginePath = this.getQueryEnginePath(this.platform, engines_1.getEnginesPath());
        return {prismaPath: enginePath, searchedLocations};
      }
      const searchLocations = [
        eval(`require('path').join(__dirname, '../../../.prisma/client')`),
        (_c = (_b = (_a = this.generator) === null || _a === void 0 ? void 0 : _a.output) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : eval("__dirname"),
        path_1.default.join(eval("__dirname"), ".."),
        path_1.default.dirname(this.datamodelPath),
        this.cwd,
        "/tmp/prisma-engines"
      ];
      if (this.dirname) {
        searchLocations.push(this.dirname);
      }
      for (const location of searchLocations) {
        searchedLocations.push(location);
        debug(`Search for Query Engine in ${location}`);
        enginePath = this.getQueryEnginePath(this.platform, location);
        if (fs_1.default.existsSync(enginePath)) {
          return {prismaPath: enginePath, searchedLocations};
        }
      }
      enginePath = this.getQueryEnginePath(this.platform);
      return {prismaPath: enginePath !== null && enginePath !== void 0 ? enginePath : "", searchedLocations};
    }
    async getPrismaPath() {
      const {prismaPath, searchedLocations} = await this.resolvePrismaPath();
      const platform = await this.getPlatform();
      if (!await exists(prismaPath)) {
        const pinnedStr = this.incorrectlyPinnedBinaryTarget ? `
You incorrectly pinned it to ${chalk_1.default.redBright.bold(`${this.incorrectlyPinnedBinaryTarget}`)}
` : "";
        let errorText = `Query engine binary for current platform "${chalk_1.default.bold(platform)}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${chalk_1.default.underline(prismaPath)}")

Searched Locations:

${searchedLocations.map((f) => {
          let msg = `  ${f}`;
          if (process.env.DEBUG === "node-engine-search-locations" && fs_1.default.existsSync(f)) {
            const dir = fs_1.default.readdirSync(f);
            msg += dir.map((d) => `    ${d}`).join("\n");
          }
          return msg;
        }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
        if (this.generator) {
          if (this.generator.binaryTargets.includes(this.platform) || this.generator.binaryTargets.includes("native")) {
            errorText += `
You already added the platform${this.generator.binaryTargets.length > 1 ? "s" : ""} ${this.generator.binaryTargets.map((t) => `"${chalk_1.default.bold(t)}"`).join(", ")} to the "${chalk_1.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
            errorText += ``;
          } else {
            errorText += `

To solve this problem, add the platform "${this.platform}" to the "${chalk_1.default.underline("binaryTargets")}" attribute in the "${chalk_1.default.underline("generator")}" block in the "schema.prisma" file:
${chalk_1.default.greenBright(this.getFixedGenerator())}

Then run "${chalk_1.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
          }
        } else {
          errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
        }
        throw new errors_1.PrismaClientInitializationError(errorText, this.clientVersion);
      }
      if (this.incorrectlyPinnedBinaryTarget) {
        console.error(`${chalk_1.default.yellow("Warning:")} You pinned the platform ${chalk_1.default.bold(this.incorrectlyPinnedBinaryTarget)}, but Prisma Client detects ${chalk_1.default.bold(await this.getPlatform())}.
This means you should very likely pin the platform ${chalk_1.default.greenBright(await this.getPlatform())} instead.
${chalk_1.default.dim("In case we're mistaken, please report this to us \u{1F64F}.")}`);
      }
      if (process.platform !== "win32") {
        util_2.plusX(prismaPath);
      }
      return prismaPath;
    }
    getFixedGenerator() {
      const fixedGenerator = {
        ...this.generator,
        binaryTargets: util_2.fixBinaryTargets(this.generator.binaryTargets, this.platform)
      };
      return printGeneratorConfig_1.printGeneratorConfig(fixedGenerator);
    }
    printDatasources() {
      if (this.datasources) {
        return JSON.stringify(this.datasources);
      }
      return "[]";
    }
    async start() {
      if (!this.startPromise) {
        this.startCount++;
        this.startPromise = this.internalStart();
      }
      return this.startPromise;
    }
    getEngineEnvVars() {
      const env = {
        PRISMA_DML_PATH: this.datamodelPath,
        RUST_BACKTRACE: "1",
        RUST_LOG: "info"
      };
      if (this.logQueries || this.logLevel === "info") {
        env.RUST_LOG = "info";
        if (this.logQueries) {
          env.LOG_QUERIES = "true";
        }
      }
      if (this.datasources) {
        env.OVERWRITE_DATASOURCES = this.printDatasources();
      }
      if (!process.env.NO_COLOR && this.showColors) {
        env.CLICOLOR_FORCE = "1";
      }
      return {
        ...this.env,
        ...process.env,
        ...env
      };
    }
    internalStart() {
      return new Promise(async (resolve, reject) => {
        var _a, _b, _c;
        await new Promise((r) => process.nextTick(r));
        if (this.stopPromise) {
          await this.stopPromise;
        }
        if (this.engineEndpoint) {
          try {
            await p_retry_1.default(() => this.undici.status(), {
              retries: 10
            });
          } catch (e) {
            return reject(e);
          }
          return resolve();
        }
        try {
          if (((_a = this.child) === null || _a === void 0 ? void 0 : _a.connected) || this.child && !((_b = this.child) === null || _b === void 0 ? void 0 : _b.killed)) {
            debug(`There is a child that still runs and we want to start again`);
          }
          this.lastRustError = void 0;
          this.lastErrorLog = void 0;
          this.lastPanic = void 0;
          logger("startin & resettin");
          this.globalKillSignalReceived = void 0;
          if (this.useUds) {
            this.socketPath = `/tmp/prisma-${util_2.getRandomString()}.sock`;
            socketPaths.push(this.socketPath);
          }
          debug({cwd: this.cwd});
          const prismaPath = await this.getPrismaPath();
          const debugFlag = this.enableEngineDebugMode ? ["--debug"] : [];
          const flags = [...debugFlag, "--enable-raw-queries", ...this.flags];
          if (this.useUds) {
            flags.push("--unix-path", this.socketPath);
          } else {
            this.port = await this.getFreePort();
            flags.push("--port", String(this.port));
          }
          debug({flags});
          const env = this.getEngineEnvVars();
          this.child = child_process_1.spawn(prismaPath, flags, {
            env,
            cwd: this.cwd,
            windowsHide: true,
            stdio: ["ignore", "pipe", "pipe"]
          });
          byline_1.default(this.child.stderr).on("data", (msg) => {
            const data = String(msg);
            debug("stderr", data);
            try {
              const json = JSON.parse(data);
              if (typeof json.is_panic !== "undefined") {
                debug(json);
                this.setError(json);
                if (this.engineStartDeferred) {
                  const err = new errors_1.PrismaClientInitializationError(json.message, this.clientVersion);
                  this.engineStartDeferred.reject(err);
                }
              }
            } catch (e) {
              if (!data.includes("Printing to stderr") && !data.includes("Listening on ")) {
                this.stderrLogs += "\n" + data;
              }
            }
          });
          byline_1.default(this.child.stdout).on("data", (msg) => {
            var _a2, _b2;
            const data = String(msg);
            try {
              const json = JSON.parse(data);
              debug("stdout", log_1.getMessage(json));
              if (this.engineStartDeferred && json.level === "INFO" && json.target === "query_engine::server" && ((_b2 = (_a2 = json.fields) === null || _a2 === void 0 ? void 0 : _a2.message) === null || _b2 === void 0 ? void 0 : _b2.startsWith("Started http server"))) {
                if (this.useUds) {
                  this.undici = new undici_1.Undici("http://localhost", {
                    socketPath: this.socketPath
                  });
                } else {
                  this.undici = new undici_1.Undici(`http://localhost:${this.port}`);
                }
                this.engineStartDeferred.resolve();
                this.engineStartDeferred = void 0;
              }
              if (typeof json.is_panic === "undefined") {
                const log4 = log_1.convertLog(json);
                const logIsRustErrorLog = log_1.isRustErrorLog(log4);
                if (logIsRustErrorLog) {
                  this.setError(log4);
                } else {
                  this.logEmitter.emit(log4.level, log4);
                }
              } else {
                this.setError(json);
              }
            } catch (e) {
              debug(e, data);
            }
          });
          this.child.on("exit", (code) => {
            var _a2, _b2;
            logger("removing startPromise");
            this.startPromise = void 0;
            if (this.engineStopDeferred) {
              this.engineStopDeferred.resolve(code);
              return;
            }
            (_a2 = this.undici) === null || _a2 === void 0 ? void 0 : _a2.close();
            if (code !== 0 && this.engineStartDeferred && this.startCount === 1) {
              let err;
              let msg = this.stderrLogs;
              if (this.lastRustError) {
                msg = log_1.getMessage(this.lastRustError);
              } else if (this.lastErrorLog) {
                msg = log_1.getMessage(this.lastErrorLog);
              }
              if (code !== null) {
                err = new errors_1.PrismaClientInitializationError(`Query engine exited with code ${code}
` + msg, this.clientVersion);
              } else if ((_b2 = this.child) === null || _b2 === void 0 ? void 0 : _b2.signalCode) {
                err = new errors_1.PrismaClientInitializationError(`Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${prismaPath} is not corrupt.
` + msg, this.clientVersion);
              } else {
                err = new errors_1.PrismaClientInitializationError(msg, this.clientVersion);
              }
              this.engineStartDeferred.reject(err);
            }
            if (!this.child) {
              return;
            }
            if (this.lastRustError) {
              return;
            }
            if (code === 126) {
              this.setError({
                timestamp: new Date(),
                target: "exit",
                level: "error",
                fields: {
                  message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.`
                }
              });
            }
          });
          this.child.on("error", (err) => {
            this.setError({
              message: err.message,
              backtrace: "Could not start query engine",
              is_panic: false
            });
            reject(err);
          });
          this.child.on("close", (code, signal) => {
            var _a2, _b2;
            (_a2 = this.undici) === null || _a2 === void 0 ? void 0 : _a2.close();
            if (code === null && signal === "SIGABRT" && this.child) {
              const error = new errors_1.PrismaClientRustPanicError(this.getErrorMessageWithLink("Panic in Query Engine with SIGABRT signal"), this.clientVersion);
              this.logEmitter.emit("error", error);
            } else if (code === 255 && signal === null && ((_b2 = this.lastErrorLog) === null || _b2 === void 0 ? void 0 : _b2.fields.message) === "PANIC" && !this.lastPanic) {
              const error = new errors_1.PrismaClientRustPanicError(this.getErrorMessageWithLink(`${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in ${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}`), this.clientVersion);
              this.setError(error);
            }
          });
          if (this.lastRustError) {
            return reject(new errors_1.PrismaClientInitializationError(log_1.getMessage(this.lastRustError), this.clientVersion));
          }
          if (this.lastErrorLog) {
            return reject(new errors_1.PrismaClientInitializationError(log_1.getMessage(this.lastErrorLog), this.clientVersion));
          }
          try {
            await new Promise((resolve2, reject2) => {
              this.engineStartDeferred = {resolve: resolve2, reject: reject2};
            });
          } catch (err) {
            (_c = this.child) === null || _c === void 0 ? void 0 : _c.kill();
            throw err;
          }
          void (async () => {
            try {
              const engineVersion = await this.version(true);
              debug(`Client Version: ${this.clientVersion}`);
              debug(`Engine Version: ${engineVersion}`);
              debug(`Active provider: ${this.activeProvider}`);
            } catch (e) {
              debug(e);
            }
          })();
          this.stopPromise = void 0;
          resolve();
        } catch (e) {
          reject(e);
        }
      });
    }
    async stop() {
      if (!this.stopPromise) {
        this.stopPromise = this._stop();
      }
      return this.stopPromise;
    }
    async _stop() {
      var _a, _b;
      if (this.startPromise) {
        await this.startPromise;
      }
      await new Promise((resolve) => process.nextTick(resolve));
      if (this.currentRequestPromise) {
        try {
          await this.currentRequestPromise;
        } catch (e) {
        }
      }
      this.getConfigPromise = void 0;
      let stopChildPromise;
      if (this.child) {
        debug(`Stopping Prisma engine4`);
        if (this.startPromise) {
          debug(`Waiting for start promise`);
          await this.startPromise;
        }
        debug(`Done waiting for start promise`);
        stopChildPromise = new Promise((resolve, reject) => {
          this.engineStopDeferred = {resolve, reject};
        });
        (_a = this.undici) === null || _a === void 0 ? void 0 : _a.close();
        (_b = this.child) === null || _b === void 0 ? void 0 : _b.kill();
        this.child = void 0;
      }
      if (stopChildPromise) {
        await stopChildPromise;
      }
      await new Promise((r) => process.nextTick(r));
      this.startPromise = void 0;
      this.engineStopDeferred = void 0;
    }
    kill(signal) {
      var _a, _b;
      this.getConfigPromise = void 0;
      this.globalKillSignalReceived = signal;
      (_a = this.child) === null || _a === void 0 ? void 0 : _a.kill();
      (_b = this.undici) === null || _b === void 0 ? void 0 : _b.close();
    }
    getFreePort() {
      return new Promise((resolve, reject) => {
        const server = net_1.default.createServer((s) => s.end(""));
        server.unref();
        server.on("error", reject);
        server.listen(0, () => {
          const address = server.address();
          const port = typeof address === "string" ? parseInt(address.split(":").slice(-1)[0], 10) : address.port;
          server.close((e) => {
            if (e) {
              reject(e);
            }
            resolve(port);
          });
        });
      });
    }
    async getConfig() {
      if (!this.getConfigPromise) {
        this.getConfigPromise = this._getConfig();
      }
      return this.getConfigPromise;
    }
    async _getConfig() {
      const prismaPath = await this.getPrismaPath();
      const env = await this.getEngineEnvVars();
      const result = await execa_1.default(prismaPath, ["cli", "get-config"], {
        env: omit_1.omit(env, ["PORT"]),
        cwd: this.cwd
      });
      return JSON.parse(result.stdout);
    }
    async version(forceRun = false) {
      if (this.versionPromise && !forceRun) {
        return this.versionPromise;
      }
      this.versionPromise = this.internalVersion();
      return this.versionPromise;
    }
    async internalVersion() {
      const prismaPath = await this.getPrismaPath();
      const result = await execa_1.default(prismaPath, ["--version"]);
      this.lastVersion = result.stdout;
      return this.lastVersion;
    }
    async request(query, headers, numTry = 1) {
      if (this.stopPromise) {
        await this.stopPromise;
      }
      await this.start();
      if (!this.child && !this.engineEndpoint) {
        throw new errors_1.PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, this.clientVersion);
      }
      this.currentRequestPromise = this.undici.request(stringifyQuery(query), headers);
      this.lastQuery = query;
      try {
        const {data, headers: headers2} = await this.currentRequestPromise;
        if (data.errors) {
          if (data.errors.length === 1) {
            throw this.graphQLToJSError(data.errors[0]);
          }
          throw new errors_1.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.clientVersion);
        }
        const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
        if (this.startCount > 0) {
          this.startCount = 0;
        }
        this.currentRequestPromise = void 0;
        return {data, elapsed};
      } catch (error) {
        logger("req - e", error);
        if (error instanceof errors_1.PrismaClientKnownRequestError) {
          throw error;
        }
        await this.handleRequestError(error, numTry <= MAX_REQUEST_RETRIES);
        if (numTry <= MAX_REQUEST_RETRIES) {
          logger("trying a retry now");
          return this.request(query, headers, numTry + 1);
        }
      }
      return null;
    }
    async requestBatch(queries, transaction = false, numTry = 1) {
      await this.start();
      if (!this.child && !this.engineEndpoint) {
        throw new errors_1.PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, this.clientVersion);
      }
      const variables = {};
      const body = {
        batch: queries.map((query) => ({query, variables})),
        transaction
      };
      const stringifiedQuery = JSON.stringify(body);
      this.currentRequestPromise = this.undici.request(stringifiedQuery);
      this.lastQuery = stringifiedQuery;
      return this.currentRequestPromise.then(({data, headers}) => {
        const elapsed = parseInt(headers["x-elapsed"]) / 1e3;
        const {batchResult, errors} = data;
        if (Array.isArray(batchResult)) {
          return batchResult.map((result) => {
            if (result.errors) {
              return this.graphQLToJSError(result.errors[0]);
            }
            return {
              data: result,
              elapsed
            };
          });
        } else {
          if (errors && errors.length === 1) {
            throw new Error(errors[0].error);
          }
          throw new Error(JSON.stringify(data));
        }
      }).catch(async (e) => {
        const isError3 = await this.handleRequestError(e, numTry < 3);
        if (!isError3) {
          if (numTry <= MAX_REQUEST_RETRIES) {
            return this.requestBatch(queries, transaction, numTry + 1);
          }
        }
        throw isError3;
      });
    }
    get hasMaxRestarts() {
      return this.startCount >= MAX_STARTS;
    }
    throwAsyncErrorIfExists(forceThrow = false) {
      var _a, _b;
      logger("throwAsyncErrorIfExists", this.startCount, this.hasMaxRestarts);
      if (this.lastRustError) {
        const err = new errors_1.PrismaClientRustPanicError(this.getErrorMessageWithLink(log_1.getMessage(this.lastRustError)), this.clientVersion);
        if (this.lastRustError.is_panic) {
          this.lastPanic = err;
        }
        if (this.hasMaxRestarts || forceThrow) {
          throw err;
        }
      }
      if (this.lastErrorLog && log_1.isRustErrorLog(this.lastErrorLog)) {
        const err = new errors_1.PrismaClientUnknownRequestError(this.getErrorMessageWithLink(log_1.getMessage(this.lastErrorLog)), this.clientVersion);
        if (((_b = (_a = this.lastErrorLog) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.message) === "PANIC") {
          this.lastPanic = err;
        }
        if (this.hasMaxRestarts || forceThrow) {
          throw err;
        }
      }
    }
    getErrorMessageWithLink(title) {
      return errors_1.getErrorMessageWithLink({
        platform: this.platform,
        title,
        version: this.clientVersion,
        engineVersion: this.lastVersion,
        database: this.lastActiveProvider,
        query: this.lastQuery
      });
    }
    graphQLToJSError(error) {
      if (error.user_facing_error.error_code) {
        return new errors_1.PrismaClientKnownRequestError(error.user_facing_error.message, error.user_facing_error.error_code, this.clientVersion, error.user_facing_error.meta);
      }
      return new errors_1.PrismaClientUnknownRequestError(error.user_facing_error.message, this.clientVersion);
    }
  };
  exports.NodeEngine = NodeEngine;
  function stringifyQuery(q) {
    return `{"variables":{},"query":${JSON.stringify(q)}}`;
  }
  function hookProcess(handler, exit = false) {
    process.once(handler, async () => {
      for (const engine of engines) {
        await engine.emitExit();
        engine.kill(handler);
      }
      engines.splice(0, engines.length);
      if (socketPaths.length > 0) {
        for (const socketPath of socketPaths) {
          try {
            fs_1.default.unlinkSync(socketPath);
          } catch (e) {
          }
        }
      }
      if (exit && process.listenerCount(handler) === 0) {
        process.exit();
      }
    });
  }
  var hooksInitialized = false;
  function initHooks() {
    if (!hooksInitialized) {
      if (!process.env.PRISMA_FORCE_NAPI) {
        hookProcess("beforeExit");
        hookProcess("exit");
        hookProcess("SIGINT", true);
        hookProcess("SIGUSR1", true);
        hookProcess("SIGUSR2", true);
        hookProcess("SIGTERM", true);
      }
      hooksInitialized = true;
    }
  }
});

// ../engine-core/dist/NAPIEngine.js
var require_NAPIEngine = __commonJS2((exports, module) => {
  "use strict";
  var __importDefault = exports && exports.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.NAPIEngine = void 0;
  var debug_1 = __importDefault(require_dist7());
  var engines_1 = require_dist9();
  var get_platform_1 = require_dist10();
  var chalk_1 = __importDefault(require_source2());
  var events_1 = __importDefault(require("events"));
  var fs_1 = __importDefault(require("fs"));
  var path_1 = __importDefault(require("path"));
  var errors_1 = require_errors();
  var printGeneratorConfig_1 = require_printGeneratorConfig();
  var util_1 = require_util5();
  var debug = debug_1.default("prisma:client:napi");
  var MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
  function isQueryEvent(event) {
    return event.level === "info" && event["item_type"] === "query";
  }
  function isPanicEvent(event) {
    return event.level === "error" && event["message"] === "PANIC";
  }
  var knownPlatforms = [...get_platform_1.platforms, "native"];
  var NAPIEngine = class {
    constructor(config2) {
      var _a, _b;
      this.datamodel = fs_1.default.readFileSync(config2.datamodelPath, "utf-8");
      this.config = config2;
      this.connected = false;
      this.logQueries = (_a = config2.logQueries) !== null && _a !== void 0 ? _a : false;
      this.logLevel = (_b = config2.logLevel) !== null && _b !== void 0 ? _b : "error";
      this.logEmitter = new events_1.default();
      this.logEmitter.on("error", (e) => {
      });
      this.datasourceOverrides = config2.datasources ? this.convertDatasources(config2.datasources) : {};
      if (this.logQueries) {
        process.env.LOG_QUERIES = "true";
        this.logLevel = "info";
      }
      if (config2.enableEngineDebugMode) {
        this.logLevel = "debug";
      }
      this.setupPromise = this.internalSetup();
    }
    async internalSetup() {
      debug("internalSetup");
      if (this.setupPromise)
        return this.setupPromise;
      this.platform = await this.getPlatform();
      this.libQueryEnginePath = await this.getLibQueryEnginePath();
      return this.loadEngine();
    }
    async getPlatform() {
      if (this.platform)
        return this.platform;
      const platform = await get_platform_1.getPlatform();
      if (!knownPlatforms.includes(platform)) {
        throw new errors_1.PrismaClientInitializationError(`Unknown ${chalk_1.default.red("PRISMA_QUERY_ENGINE_LIBRARY")} ${chalk_1.default.redBright.bold(this.platform)}. Possible binaryTargets: ${chalk_1.default.greenBright(knownPlatforms.join(", "))} or a path to the query engine library.
You may have to run ${chalk_1.default.greenBright("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
      }
      return platform;
    }
    parseEngineResponse(response) {
      try {
        const config2 = JSON.parse(response);
        return config2;
      } catch (err) {
        throw new errors_1.PrismaClientUnknownRequestError(`Unable to JSON.parse response from engine`, this.config.clientVersion);
      }
    }
    convertDatasources(datasources) {
      const obj = Object.create(null);
      for (const {name, url} of datasources) {
        obj[name] = url;
      }
      return obj;
    }
    async loadEngine() {
      debug("loadEngine");
      if (!this.engine) {
        if (!this.QueryEngine) {
          if (!this.libQueryEnginePath) {
            this.libQueryEnginePath = await this.getLibQueryEnginePath();
            debug(`using ${this.libQueryEnginePath}`);
          }
          try {
            this.QueryEngine = eval("require")(this.libQueryEnginePath).QueryEngine;
          } catch (e) {
            if (fs_1.default.existsSync(this.libQueryEnginePath)) {
              throw new errors_1.PrismaClientInitializationError(`Unable to load NAPI Library from ${chalk_1.default.dim(this.libQueryEnginePath)}, Library may be corrupt`, this.config.clientVersion);
            } else {
              throw new errors_1.PrismaClientInitializationError(`Unable to load NAPI Library from ${chalk_1.default.dim(this.libQueryEnginePath)}, It does not exist`, this.config.clientVersion);
            }
          }
        }
        if (this.QueryEngine) {
          try {
            this.engine = new this.QueryEngine({
              datamodel: this.datamodel,
              datasourceOverrides: this.datasourceOverrides,
              logLevel: this.logLevel,
              configDir: this.config.cwd
            }, (err, log4) => this.logger(err, log4));
          } catch (e) {
            const error = this.parseInitError(e.message);
            if (typeof error === "string") {
              throw e;
            } else {
              throw new errors_1.PrismaClientInitializationError(error.message, this.config.clientVersion, error.error_code);
            }
          }
        }
      }
    }
    logger(err, log4) {
      var _a;
      if (err) {
        throw err;
      }
      const event = this.parseEngineResponse(log4);
      if (!event)
        return;
      event.level = (_a = event === null || event === void 0 ? void 0 : event.level.toLowerCase()) !== null && _a !== void 0 ? _a : "unknown";
      if (isQueryEvent(event)) {
        this.logEmitter.emit("query", {
          timestamp: Date.now(),
          query: event.query,
          params: event.params,
          duration: event.duration_ms,
          target: event.module_path
        });
      } else if (isPanicEvent(event)) {
        this.lastError = new errors_1.PrismaClientRustPanicError(this.getErrorMessageWithLink(`${event.message}: ${event.reason} in ${event.file}:${event.line}:${event.column}`), this.config.clientVersion);
        this.logEmitter.emit("error", this.lastError);
      } else {
        this.logEmitter.emit(event.level, event);
      }
    }
    getErrorMessageWithLink(title) {
      var _a, _b;
      return errors_1.getErrorMessageWithLink({
        platform: this.platform,
        title,
        version: this.config.clientVersion,
        engineVersion: (_a = this.serverInfo) === null || _a === void 0 ? void 0 : _a.version,
        database: (_b = this.serverInfo) === null || _b === void 0 ? void 0 : _b.primaryConnector,
        query: this.lastQuery
      });
    }
    parseInitError(str) {
      try {
        const error = JSON.parse(str);
        if (typeof error.is_panic !== "undefined") {
          return error;
        }
      } catch (e) {
      }
      return str;
    }
    parseRequestError(str) {
      try {
        const error = JSON.parse(str);
        if (typeof error.is_panic !== "undefined") {
          return error;
        }
      } catch (e) {
      }
      return str;
    }
    on(event, listener) {
      if (event === "beforeExit") {
        this.beforeExitListener = listener;
      } else {
        this.logEmitter.on(event, listener);
      }
    }
    async emitExit() {
      await this.currentQuery;
      debug("emitExit");
      if (this.beforeExitListener) {
        try {
          await this.beforeExitListener();
        } catch (e) {
          console.error(e);
        }
      }
    }
    async start() {
      await this.setupPromise;
      await this.disconnectPromise;
      if (this.connectPromise) {
        debug(`already starting: ${this.connected}`);
        await this.connectPromise;
        if (this.connected) {
          return;
        }
      }
      if (!this.connected) {
        this.connectPromise = new Promise(async (res) => {
          var _a;
          debug("starting");
          await ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.connect({enableRawQueries: true}));
          this.connected = true;
          debug("started");
          void this.version();
          res();
        });
        return this.connectPromise;
      }
    }
    async stop() {
      await this.connectPromise;
      await this.currentQuery;
      debug(`stop state ${this.connected}`);
      if (this.disconnectPromise) {
        debug("engine is already disconnecting");
        await this.disconnectPromise;
        if (!this.connected) {
          this.disconnectPromise = void 0;
          return;
        }
      }
      if (this.connected) {
        this.disconnectPromise = new Promise(async (res) => {
          var _a;
          await this.emitExit();
          debug("disconnect called");
          await ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.disconnect());
          this.connected = false;
          debug("disconnect resolved");
          res();
        });
      }
      return this.disconnectPromise;
    }
    kill(signal) {
      if (this.connected && !this.disconnectPromise) {
        this.disconnectPromise = new Promise(async (res) => {
          var _a;
          await this.emitExit();
          debug(`disconnect called with kill signal ${signal}`);
          await ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.disconnect());
          this.connected = false;
          debug(`disconnect resolved`);
          res();
        });
      }
    }
    async getConfig() {
      await this.start();
      const config2 = this.parseEngineResponse(await this.engine.getConfig());
      return config2;
    }
    async version(forceRun) {
      await this.start();
      const serverInfo = this.parseEngineResponse(await this.engine.serverInfo());
      this.serverInfo = serverInfo;
      return this.serverInfo.version;
    }
    graphQLToJSError(error) {
      debug("graphQLToJSError");
      if (error.user_facing_error.error_code) {
        return new errors_1.PrismaClientKnownRequestError(error.user_facing_error.message, error.user_facing_error.error_code, this.config.clientVersion, error.user_facing_error.meta);
      }
      return new errors_1.PrismaClientUnknownRequestError(error.error, this.config.clientVersion);
    }
    async request(query, headers, numTry) {
      try {
        await this.start();
        debug(`request state: ${this.connected}`);
        const request = {query, variables: {}};
        this.lastQuery = JSON.stringify(request);
        this.currentQuery = this.engine.query(request, {});
        const data = this.parseEngineResponse(await this.currentQuery);
        if (data.errors) {
          if (data.errors.length === 1) {
            if (this.lastError) {
              throw this.lastError;
            }
            throw this.graphQLToJSError(data.errors[0]);
          }
          throw new errors_1.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
        }
        return {data, elapsed: 0};
      } catch (e) {
        const error = this.parseRequestError(e.message);
        if (typeof error === "string") {
          throw e;
        } else {
          throw new errors_1.PrismaClientUnknownRequestError(`${error.message}
${error.backtrace}`, this.config.clientVersion);
        }
      }
    }
    async requestBatch(queries, transaction = false, numTry = 1) {
      await this.start();
      debug("requestBatch");
      const variables = {};
      const request = {
        batch: queries.map((query) => ({query, variables})),
        transaction
      };
      this.lastQuery = JSON.stringify(request);
      this.currentQuery = this.engine.query(request, {});
      const result = await this.currentQuery;
      const data = this.parseEngineResponse(result);
      if (data.errors) {
        if (data.errors.length === 1) {
          throw this.graphQLToJSError(data.errors[0]);
        }
        throw new errors_1.PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
      }
      try {
        const {batchResult, errors} = data;
        if (Array.isArray(batchResult)) {
          return batchResult.map((result2) => {
            var _a;
            if (result2.errors) {
              return (_a = this.lastError) !== null && _a !== void 0 ? _a : this.graphQLToJSError(result2.errors[0]);
            }
            return {
              data: result2,
              elapsed: 0
            };
          });
        } else {
          if (errors && errors.length === 1) {
            throw new Error(errors[0].error);
          }
          throw new Error(JSON.stringify(data));
        }
      } catch (e) {
        if (numTry <= MAX_REQUEST_RETRIES) {
          return this.requestBatch(queries, transaction, numTry + 1);
        }
        throw e;
      }
    }
    async resolveEnginePath() {
      var _a, _b, _c, _d;
      const searchedLocations = [];
      let enginePath;
      if (this.libQueryEnginePath) {
        return {enginePath: this.libQueryEnginePath, searchedLocations};
      }
      this.platform = (_a = this.platform) !== null && _a !== void 0 ? _a : await get_platform_1.getPlatform();
      if (__filename.includes("NAPIEngine")) {
        enginePath = path_1.default.join(engines_1.getEnginesPath(), get_platform_1.getNapiName(this.platform, "fs"));
        return {enginePath, searchedLocations};
      }
      const searchLocations = [
        eval(`require('path').join(__dirname, '../../../.prisma/client')`),
        (_d = (_c = (_b = this.config.generator) === null || _b === void 0 ? void 0 : _b.output) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : eval("__dirname"),
        path_1.default.join(eval("__dirname"), ".."),
        path_1.default.dirname(this.config.datamodelPath),
        this.config.cwd,
        "/tmp/prisma-engines"
      ];
      if (this.config.dirname) {
        searchLocations.push(this.config.dirname);
      }
      for (const location of searchLocations) {
        searchedLocations.push(location);
        debug(`Search for Query Engine Library in ${location}`);
        enginePath = path_1.default.join(location, get_platform_1.getNapiName(this.platform, "fs"));
        if (fs_1.default.existsSync(enginePath)) {
          return {enginePath, searchedLocations};
        }
      }
      enginePath = path_1.default.join(__dirname, get_platform_1.getNapiName(this.platform, "fs"));
      return {enginePath: enginePath !== null && enginePath !== void 0 ? enginePath : "", searchedLocations};
    }
    async getLibQueryEnginePath() {
      var _a, _b, _c, _d;
      const libPath = (_a = process.env.PRISMA_QUERY_ENGINE_LIBRARY) !== null && _a !== void 0 ? _a : this.config.prismaPath;
      if (libPath && fs_1.default.existsSync(libPath)) {
        return libPath;
      }
      this.platform = (_b = this.platform) !== null && _b !== void 0 ? _b : await get_platform_1.getPlatform();
      const {enginePath, searchedLocations} = await this.resolveEnginePath();
      if (!fs_1.default.existsSync(enginePath)) {
        const pinnedStr = this.platform ? `
You incorrectly pinned it to ${chalk_1.default.redBright.bold(`${this.platform}`)}
` : "";
        let errorText = `Query engine library for current platform "${chalk_1.default.bold(this.platform)}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${chalk_1.default.underline(enginePath)}")

Searched Locations:

${searchedLocations.map((f) => {
          let msg = `  ${f}`;
          if (process.env.DEBUG === "node-engine-search-locations" && fs_1.default.existsSync(f)) {
            const dir = fs_1.default.readdirSync(f);
            msg += dir.map((d) => `    ${d}`).join("\n");
          }
          return msg;
        }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
        if (this.config.generator) {
          this.platform = (_c = this.platform) !== null && _c !== void 0 ? _c : await get_platform_1.getPlatform();
          if (this.config.generator.binaryTargets.includes(this.platform) || this.config.generator.binaryTargets.includes("native")) {
            errorText += `
You already added the platform${this.config.generator.binaryTargets.length > 1 ? "s" : ""} ${this.config.generator.binaryTargets.map((t) => `"${chalk_1.default.bold(t)}"`).join(", ")} to the "${chalk_1.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
            errorText += ``;
          } else {
            errorText += `

To solve this problem, add the platform "${this.platform}" to the "${chalk_1.default.underline("binaryTargets")}" attribute in the "${chalk_1.default.underline("generator")}" block in the "schema.prisma" file:
${chalk_1.default.greenBright(this.getFixedGenerator())}

Then run "${chalk_1.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
          }
        } else {
          errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
        }
        throw new errors_1.PrismaClientInitializationError(errorText, this.config.clientVersion);
      }
      this.platform = (_d = this.platform) !== null && _d !== void 0 ? _d : await get_platform_1.getPlatform();
      return enginePath;
    }
    getFixedGenerator() {
      const fixedGenerator = {
        ...this.config.generator,
        binaryTargets: util_1.fixBinaryTargets(this.config.generator.binaryTargets, this.platform)
      };
      return printGeneratorConfig_1.printGeneratorConfig(fixedGenerator);
    }
  };
  exports.NAPIEngine = NAPIEngine;
});

// ../engine-core/dist/getInternalDatamodelJson.js
var require_getInternalDatamodelJson = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getInternalDatamodelJson = void 0;
  var path_12 = __importDefault2(require("path"));
  var child_process_12 = require("child_process");
  var byline_12 = __importDefault2(require_byline2());
  function getInternalDatamodelJson(datamodel, schemaInferrerPath = path_12.default.join(__dirname, "../schema-inferrer-bin")) {
    return new Promise((resolve, reject) => {
      const proc = child_process_12.spawn(schemaInferrerPath, {
        stdio: ["pipe", "pipe", process.stderr]
      });
      proc.on("error", function(err) {
        console.error("[schema-inferrer-bin] error: %s", err);
        reject(err);
      });
      proc.on("exit", function(code, signal) {
        if (code !== 0) {
          console.error("[schema-inferrer-bin] exit: code=%s signal=%s", code, signal);
        }
        reject();
      });
      const out = byline_12.default(proc.stdout);
      out.on("data", (line) => {
        const result = JSON.parse(line);
        const resultB64 = Buffer.from(JSON.stringify(result)).toString("base64");
        resolve(resultB64);
      });
      const cut = datamodel.replace(/\n/g, " ");
      proc.stdin.write(JSON.stringify({dataModel: cut}) + "\n");
    });
  }
  exports2.getInternalDatamodelJson = getInternalDatamodelJson;
});

// ../engine-core/dist/index.js
var require_dist11 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.fixBinaryTargets = exports2.printGeneratorConfig = exports2.getInternalDatamodelJson = exports2.NAPIEngine = exports2.Engine = exports2.PrismaClientRustPanicError = exports2.PrismaClientInitializationError = exports2.PrismaClientUnknownRequestError = exports2.PrismaClientKnownRequestError = void 0;
  var errors_12 = require_errors();
  Object.defineProperty(exports2, "PrismaClientKnownRequestError", {enumerable: true, get: function() {
    return errors_12.PrismaClientKnownRequestError;
  }});
  Object.defineProperty(exports2, "PrismaClientUnknownRequestError", {enumerable: true, get: function() {
    return errors_12.PrismaClientUnknownRequestError;
  }});
  Object.defineProperty(exports2, "PrismaClientInitializationError", {enumerable: true, get: function() {
    return errors_12.PrismaClientInitializationError;
  }});
  Object.defineProperty(exports2, "PrismaClientRustPanicError", {enumerable: true, get: function() {
    return errors_12.PrismaClientRustPanicError;
  }});
  var NodeEngine_1 = require_NodeEngine();
  Object.defineProperty(exports2, "Engine", {enumerable: true, get: function() {
    return NodeEngine_1.NodeEngine;
  }});
  var NAPIEngine_1 = require_NAPIEngine();
  Object.defineProperty(exports2, "NAPIEngine", {enumerable: true, get: function() {
    return NAPIEngine_1.NAPIEngine;
  }});
  var getInternalDatamodelJson_1 = require_getInternalDatamodelJson();
  Object.defineProperty(exports2, "getInternalDatamodelJson", {enumerable: true, get: function() {
    return getInternalDatamodelJson_1.getInternalDatamodelJson;
  }});
  var printGeneratorConfig_12 = require_printGeneratorConfig();
  Object.defineProperty(exports2, "printGeneratorConfig", {enumerable: true, get: function() {
    return printGeneratorConfig_12.printGeneratorConfig;
  }});
  var util_12 = require_util5();
  Object.defineProperty(exports2, "fixBinaryTargets", {enumerable: true, get: function() {
    return util_12.fixBinaryTargets;
  }});
});

// ../sdk/dist/logger.js
var require_logger = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.query = exports2.error = exports2.info = exports2.warn = exports2.log = exports2.should = exports2.tags = void 0;
  var chalk_12 = __importDefault2(require_source3());
  exports2.tags = {
    error: chalk_12.default.red("prisma:error"),
    warn: chalk_12.default.yellow("prisma:warn"),
    info: chalk_12.default.cyan("prisma:info"),
    query: chalk_12.default.blue("prisma:query")
  };
  exports2.should = {
    warn: !process.env.PRISMA_DISABLE_WARNINGS
  };
  function log4(...data) {
    console.log(...data);
  }
  exports2.log = log4;
  function warn(message, ...optionalParams) {
    if (exports2.should.warn) {
      console.warn(`${exports2.tags.warn} ${message}`, ...optionalParams);
    }
  }
  exports2.warn = warn;
  function info(message, ...optionalParams) {
    console.info(`${exports2.tags.info} ${message}`, ...optionalParams);
  }
  exports2.info = info;
  function error(message, ...optionalParams) {
    console.error(`${exports2.tags.error} ${message}`, ...optionalParams);
  }
  exports2.error = error;
  function query(message, ...optionalParams) {
    console.log(`${exports2.tags.query} ${message}`, ...optionalParams);
  }
  exports2.query = query;
});

// ../sdk/dist/utils/mapPreviewFeatures.js
var require_mapPreviewFeatures = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.mapPreviewFeatures = void 0;
  var featureFlagMap = {
    transactionApi: "transaction",
    aggregateApi: "aggregations"
  };
  function mapPreviewFeatures2(features) {
    if (Array.isArray(features) && features.length > 0) {
      return features.map((f) => {
        var _a;
        return (_a = featureFlagMap[f]) !== null && _a !== void 0 ? _a : f;
      });
    }
    return [];
  }
  exports2.mapPreviewFeatures = mapPreviewFeatures2;
});

// ../../node_modules/.pnpm/dotenv@8.2.0/node_modules/dotenv/lib/main.js
var require_main3 = __commonJS2((exports2, module2) => {
  var fs2 = require("fs");
  var path2 = require("path");
  function log4(message) {
    console.log(`[dotenv][DEBUG] ${message}`);
  }
  var NEWLINE = "\n";
  var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
  var RE_NEWLINES = /\\n/g;
  var NEWLINES_MATCH = /\n|\r|\r\n/;
  function parse2(src, options) {
    const debug4 = Boolean(options && options.debug);
    const obj = {};
    src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
      const keyValueArr = line.match(RE_INI_KEY_VAL);
      if (keyValueArr != null) {
        const key = keyValueArr[1];
        let val = keyValueArr[2] || "";
        const end = val.length - 1;
        const isDoubleQuoted = val[0] === '"' && val[end] === '"';
        const isSingleQuoted = val[0] === "'" && val[end] === "'";
        if (isSingleQuoted || isDoubleQuoted) {
          val = val.substring(1, end);
          if (isDoubleQuoted) {
            val = val.replace(RE_NEWLINES, NEWLINE);
          }
        } else {
          val = val.trim();
        }
        obj[key] = val;
      } else if (debug4) {
        log4(`did not match key and value when parsing line ${idx + 1}: ${line}`);
      }
    });
    return obj;
  }
  function config2(options) {
    let dotenvPath = path2.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let debug4 = false;
    if (options) {
      if (options.path != null) {
        dotenvPath = options.path;
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      }
      if (options.debug != null) {
        debug4 = true;
      }
    }
    try {
      const parsed = parse2(fs2.readFileSync(dotenvPath, {encoding}), {debug: debug4});
      Object.keys(parsed).forEach(function(key) {
        if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
          process.env[key] = parsed[key];
        } else if (debug4) {
          log4(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
        }
      });
      return {parsed};
    } catch (e) {
      return {error: e};
    }
  }
  module2.exports.config = config2;
  module2.exports.parse = parse2;
});

// ../sdk/dist/dotenvExpand.js
var require_dotenvExpand = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.dotenvExpand = void 0;
  function dotenvExpand(config2) {
    const environment = config2.ignoreProcessEnv ? {} : process.env;
    const interpolate = (envValue) => {
      const matches = envValue.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g) || [];
      return matches.reduce(function(newEnv, match) {
        const parts = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(match);
        if (!parts) {
          return newEnv;
        }
        const prefix = parts[1];
        let value, replacePart;
        if (prefix === "\\") {
          replacePart = parts[0];
          value = replacePart.replace("\\$", "$");
        } else {
          const key = parts[2];
          replacePart = parts[0].substring(prefix.length);
          value = Object.hasOwnProperty.call(environment, key) ? environment[key] : config2.parsed[key] || "";
          value = interpolate(value);
        }
        return newEnv.replace(replacePart, value);
      }, envValue);
    };
    for (const configKey in config2.parsed) {
      const value = Object.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config2.parsed[configKey];
      config2.parsed[configKey] = interpolate(value);
    }
    for (const processKey in config2.parsed) {
      environment[processKey] = config2.parsed[processKey];
    }
    return config2;
  }
  exports2.dotenvExpand = dotenvExpand;
});

// ../sdk/dist/utils/tryLoadEnvs.js
var require_tryLoadEnvs = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.exists = exports2.pathsEqual = exports2.loadEnv = exports2.tryLoadEnvs = void 0;
  var chalk_12 = __importDefault2(require_source3());
  var debug_12 = __importDefault2(require_dist7());
  var dotenv_1 = __importDefault2(require_main3());
  var fs_12 = __importDefault2(require("fs"));
  var path_12 = __importDefault2(require("path"));
  var dotenvExpand_1 = require_dotenvExpand();
  var debug4 = debug_12.default("prisma:tryLoadEnv");
  function tryLoadEnvs3({rootEnvPath, schemaEnvPath}, opts = {
    conflictCheck: "none"
  }) {
    var _a, _b;
    const rootEnvInfo = loadEnv(rootEnvPath);
    if (opts.conflictCheck !== "none") {
      checkForConflicts(rootEnvInfo, schemaEnvPath, opts.conflictCheck);
    }
    let schemaEnvInfo = null;
    if (!pathsEqual(rootEnvInfo === null || rootEnvInfo === void 0 ? void 0 : rootEnvInfo.path, schemaEnvPath)) {
      schemaEnvInfo = loadEnv(schemaEnvPath);
    }
    if (!rootEnvInfo && !schemaEnvInfo) {
      debug4("No Environment variables loaded");
    }
    if (schemaEnvInfo === null || schemaEnvInfo === void 0 ? void 0 : schemaEnvInfo.dotenvResult.error) {
      return console.error(chalk_12.default.redBright.bold("Schema Env Error: ") + schemaEnvInfo.dotenvResult.error);
    }
    const messages = [rootEnvInfo === null || rootEnvInfo === void 0 ? void 0 : rootEnvInfo.message, schemaEnvInfo === null || schemaEnvInfo === void 0 ? void 0 : schemaEnvInfo.message].filter(Boolean);
    return {
      message: messages.join("\n"),
      parsed: {
        ...(_a = rootEnvInfo === null || rootEnvInfo === void 0 ? void 0 : rootEnvInfo.dotenvResult) === null || _a === void 0 ? void 0 : _a.parsed,
        ...(_b = schemaEnvInfo === null || schemaEnvInfo === void 0 ? void 0 : schemaEnvInfo.dotenvResult) === null || _b === void 0 ? void 0 : _b.parsed
      }
    };
  }
  exports2.tryLoadEnvs = tryLoadEnvs3;
  function checkForConflicts(rootEnvInfo, envPath, type) {
    const parsedRootEnv = rootEnvInfo === null || rootEnvInfo === void 0 ? void 0 : rootEnvInfo.dotenvResult.parsed;
    const areNotTheSame = !pathsEqual(rootEnvInfo === null || rootEnvInfo === void 0 ? void 0 : rootEnvInfo.path, envPath);
    if (parsedRootEnv && envPath && areNotTheSame && fs_12.default.existsSync(envPath)) {
      const envConfig = dotenv_1.default.parse(fs_12.default.readFileSync(envPath));
      const conflicts = [];
      for (const k in envConfig) {
        if (parsedRootEnv[k] === envConfig[k]) {
          conflicts.push(k);
        }
      }
      if (conflicts.length > 0) {
        const relativeRootEnvPath = path_12.default.relative(process.cwd(), rootEnvInfo.path);
        const relativeEnvPath = path_12.default.relative(process.cwd(), envPath);
        if (type === "error") {
          const message = `There is a conflict between env var${conflicts.length > 1 ? "s" : ""} in ${chalk_12.default.underline(relativeRootEnvPath)} and ${chalk_12.default.underline(relativeEnvPath)}
Conflicting env vars:
${conflicts.map((conflict) => `  ${chalk_12.default.bold(conflict)}`).join("\n")}

We suggest to move the contents of ${chalk_12.default.underline(relativeEnvPath)} to ${chalk_12.default.underline(relativeRootEnvPath)} to consolidate your env vars.
`;
          throw new Error(message);
        } else if (type === "warn") {
          const message = `Conflict for env var${conflicts.length > 1 ? "s" : ""} ${conflicts.map((c) => chalk_12.default.bold(c)).join(", ")} in ${chalk_12.default.underline(relativeRootEnvPath)} and ${chalk_12.default.underline(relativeEnvPath)}
Env vars from ${chalk_12.default.underline(relativeEnvPath)} overwrite the ones from ${chalk_12.default.underline(relativeRootEnvPath)}
      `;
          console.warn(`${chalk_12.default.yellow("warn(prisma)")} ${message}`);
        }
      }
    }
  }
  function loadEnv(envPath) {
    if (exists2(envPath)) {
      debug4(`Environment variables loaded from ${envPath}`);
      const debugEnv = process.env.DEBUG;
      let enableDebug = void 0;
      if (debugEnv && (debugEnv.startsWith("prisma") || debugEnv === "*")) {
        enableDebug = true;
      }
      return {
        dotenvResult: dotenvExpand_1.dotenvExpand(dotenv_1.default.config({
          path: envPath,
          debug: enableDebug
        })),
        message: chalk_12.default.dim(`Environment variables loaded from ${path_12.default.relative(process.cwd(), envPath)}`),
        path: envPath
      };
    } else {
      debug4(`Environment variables not found at ${envPath}`);
    }
    return null;
  }
  exports2.loadEnv = loadEnv;
  function pathsEqual(path1, path2) {
    return path1 && path2 && path_12.default.resolve(path1) === path_12.default.resolve(path2);
  }
  exports2.pathsEqual = pathsEqual;
  function exists2(p) {
    return Boolean(p && fs_12.default.existsSync(p));
  }
  exports2.exists = exists2;
});

// ../../node_modules/.pnpm/sql-template-tag@4.0.0/node_modules/sql-template-tag/dist/index.js
var require_dist12 = __commonJS2((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.sqltag = exports2.empty = exports2.raw = exports2.join = exports2.Sql = void 0;
  var util_12 = require("util");
  var Sql2 = class {
    constructor(rawStrings, rawValues) {
      let valuesLength = rawValues.length;
      let stringsLength = rawStrings.length;
      if (stringsLength === 0) {
        throw new TypeError("Expected at least 1 string");
      }
      if (stringsLength - 1 !== valuesLength) {
        throw new TypeError(`Expected ${stringsLength} strings to have ${stringsLength - 1} values`);
      }
      for (const child of rawValues) {
        if (child instanceof Sql2) {
          valuesLength += child.values.length - 1;
          stringsLength += child.strings.length - 2;
        }
      }
      this.values = new Array(valuesLength);
      this.strings = new Array(stringsLength);
      this.strings[0] = rawStrings[0];
      let index = 1;
      let position = 0;
      while (index < rawStrings.length) {
        const child = rawValues[index - 1];
        const rawString = rawStrings[index++];
        if (child instanceof Sql2) {
          this.strings[position] += child.strings[0];
          let childIndex = 0;
          while (childIndex < child.values.length) {
            this.values[position++] = child.values[childIndex++];
            this.strings[position] = child.strings[childIndex];
          }
          this.strings[position] += rawString;
        } else {
          this.values[position++] = child;
          this.strings[position] = rawString;
        }
      }
    }
    get text() {
      return this.strings.reduce((text, part, index) => `${text}$${index}${part}`);
    }
    get sql() {
      return this.strings.join("?");
    }
    [util_12.inspect.custom]() {
      return {
        text: this.text,
        sql: this.sql,
        values: this.values
      };
    }
  };
  exports2.Sql = Sql2;
  Object.defineProperty(Sql2.prototype, "sql", {enumerable: true});
  Object.defineProperty(Sql2.prototype, "text", {enumerable: true});
  function join2(values, separator = ",") {
    if (values.length === 0) {
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    }
    return new Sql2(["", ...Array(values.length - 1).fill(separator), ""], values);
  }
  exports2.join = join2;
  function raw2(value) {
    return new Sql2([value], []);
  }
  exports2.raw = raw2;
  exports2.empty = raw2("");
  function sqltag3(strings, ...values) {
    return new Sql2(strings, values);
  }
  exports2.sqltag = sqltag3;
  exports2.default = sqltag3;
});

// package.json
var require_package2 = __commonJS2((exports2, module2) => {
  module2.exports = {
    name: "@prisma/client",
    version: "2.22.1",
    description: "Prisma Client is an auto-generated, type-safe and modern JavaScript/TypeScript ORM for Node.js that's tailored to your data. Supports MySQL, PostgreSQL, MariaDB, SQLite databases.",
    keywords: [
      "orm",
      "prisma2",
      "prisma",
      "client",
      "query",
      "database",
      "sql",
      "postgres",
      "postgresql",
      "mysql",
      "sqlite",
      "mariadb",
      "mssql",
      "typescript",
      "query-builder"
    ],
    main: "index.js",
    browser: "index-browser.js",
    types: "index.d.ts",
    license: "Apache-2.0",
    engines: {
      node: ">=10.16"
    },
    homepage: "https://www.prisma.io",
    repository: "git@github.com:prisma/prisma.git",
    author: "Tim Suchanek <suchanek@prisma.io>",
    maintainers: [
      "Tim Suchanek <suchanek@prisma.io>",
      "Jo\xEBl Galeran <galeran@prisma.io>",
      "William Luke <luke@prisma.io>"
    ],
    bugs: "https://github.com/prisma/prisma/issues",
    scripts: {
      build: "node helpers/build.js",
      test: "node helpers/patchJest.js && jest",
      format: "prettier --write .",
      lint: "eslint --cache --fix --ext .ts .",
      "lint-ci": "eslint --ext .ts .",
      generate: "node scripts/postinstall.js",
      postinstall: "node scripts/postinstall.js",
      prepare: "cp scripts/backup-index.js index.js && cp scripts/backup-index.d.ts index.d.ts",
      prepublishOnly: "pnpm run build",
      precommit: "lint-staged"
    },
    files: [
      "README.md",
      "runtime",
      "scripts",
      "generator-build",
      "index.js",
      "index.d.ts",
      "index-browser.js"
    ],
    devDependencies: {
      "@prisma/debug": "2.22.1",
      "@prisma/engine-core": "2.22.1",
      "@prisma/engines": "2.22.0-21.60cc71d884972ab4e897f0277c4b84383dddaf6c",
      "@prisma/fetch-engine": "2.22.1",
      "@prisma/generator-helper": "2.22.1",
      "@prisma/get-platform": "2.22.1",
      "@prisma/migrate": "2.22.1",
      "@prisma/sdk": "2.22.1",
      "@timsuchanek/copy": "1.4.5",
      "@types/debug": "4.1.5",
      "@types/jest": "26.0.23",
      "@types/js-levenshtein": "1.1.0",
      "@types/mssql": "6.0.8",
      "@types/node": "12.20.11",
      "@types/pg": "7.14.11",
      "@typescript-eslint/eslint-plugin": "4.22.0",
      "@typescript-eslint/parser": "4.22.0",
      arg: "5.0.0",
      chalk: "4.1.1",
      "decimal.js": "10.2.1",
      esbuild: "0.8.53",
      "escape-string-regexp": "4.0.0",
      eslint: "7.25.0",
      "eslint-config-prettier": "8.3.0",
      "eslint-plugin-eslint-comments": "3.2.0",
      "eslint-plugin-jest": "24.3.6",
      "eslint-plugin-prettier": "3.4.0",
      execa: "5.0.0",
      "flat-map-polyfill": "0.3.8",
      "fs-monkey": "1.0.3",
      "get-own-enumerable-property-symbols": "3.0.2",
      "indent-string": "4.0.0",
      "is-obj": "2.0.0",
      "is-regexp": "2.1.0",
      jest: "26.6.3",
      "js-levenshtein": "1.1.6",
      klona: "2.0.4",
      "lint-staged": "10.5.4",
      "make-dir": "3.1.0",
      mariadb: "2.5.3",
      mssql: "6.3.1",
      pg: "8.6.0",
      "pkg-up": "3.1.0",
      pluralize: "8.0.0",
      prettier: "2.2.1",
      "replace-string": "3.1.0",
      "resolve-from": "5.0.0",
      rimraf: "3.0.2",
      rollup: "2.46.0",
      "rollup-plugin-dts": "3.0.1",
      "sort-keys": "4.2.0",
      "source-map-support": "0.5.19",
      "sql-template-tag": "4.0.0",
      "stacktrace-parser": "0.1.10",
      "strip-ansi": "6.0.0",
      "strip-indent": "3.0.0",
      "ts-jest": "26.5.5",
      "ts-node": "9.1.1",
      tsd: "0.14.0",
      typescript: "4.2.4"
    },
    peerDependencies: {
      prisma: "*"
    },
    peerDependenciesMeta: {
      prisma: {
        optional: true
      }
    },
    dependencies: {
      "@prisma/engines-version": "2.22.0-21.60cc71d884972ab4e897f0277c4b84383dddaf6c"
    },
    "lint-staged": {
      "*.ts": [
        "eslint",
        "prettier --write"
      ]
    }
  };
});

// ../../node_modules/.pnpm/arg@5.0.0/node_modules/arg/index.js
var require_arg = __commonJS2((exports2, module2) => {
  var flagSymbol = Symbol("arg flag");
  var ArgError = class extends Error {
    constructor(msg, code) {
      super(msg);
      this.name = "ArgError";
      this.code = code;
      Object.setPrototypeOf(this, ArgError.prototype);
    }
  };
  function arg(opts, {argv = process.argv.slice(2), permissive = false, stopAtPositional = false} = {}) {
    if (!opts) {
      throw new ArgError("argument specification object is required", "ARG_CONFIG_NO_SPEC");
    }
    const result = {_: []};
    const aliases = {};
    const handlers = {};
    for (const key of Object.keys(opts)) {
      if (!key) {
        throw new ArgError("argument key cannot be an empty string", "ARG_CONFIG_EMPTY_KEY");
      }
      if (key[0] !== "-") {
        throw new ArgError(`argument key must start with '-' but found: '${key}'`, "ARG_CONFIG_NONOPT_KEY");
      }
      if (key.length === 1) {
        throw new ArgError(`argument key must have a name; singular '-' keys are not allowed: ${key}`, "ARG_CONFIG_NONAME_KEY");
      }
      if (typeof opts[key] === "string") {
        aliases[key] = opts[key];
        continue;
      }
      let type = opts[key];
      let isFlag = false;
      if (Array.isArray(type) && type.length === 1 && typeof type[0] === "function") {
        const [fn] = type;
        type = (value, name, prev = []) => {
          prev.push(fn(value, name, prev[prev.length - 1]));
          return prev;
        };
        isFlag = fn === Boolean || fn[flagSymbol] === true;
      } else if (typeof type === "function") {
        isFlag = type === Boolean || type[flagSymbol] === true;
      } else {
        throw new ArgError(`type missing or not a function or valid array type: ${key}`, "ARG_CONFIG_VAD_TYPE");
      }
      if (key[1] !== "-" && key.length > 2) {
        throw new ArgError(`short argument keys (with a single hyphen) must have only one character: ${key}`, "ARG_CONFIG_SHORTOPT_TOOLONG");
      }
      handlers[key] = [type, isFlag];
    }
    for (let i = 0, len = argv.length; i < len; i++) {
      const wholeArg = argv[i];
      if (stopAtPositional && result._.length > 0) {
        result._ = result._.concat(argv.slice(i));
        break;
      }
      if (wholeArg === "--") {
        result._ = result._.concat(argv.slice(i + 1));
        break;
      }
      if (wholeArg.length > 1 && wholeArg[0] === "-") {
        const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
        for (let j = 0; j < separatedArguments.length; j++) {
          const arg2 = separatedArguments[j];
          const [originalArgName, argStr] = arg2[1] === "-" ? arg2.split(/=(.*)/, 2) : [arg2, void 0];
          let argName = originalArgName;
          while (argName in aliases) {
            argName = aliases[argName];
          }
          if (!(argName in handlers)) {
            if (permissive) {
              result._.push(arg2);
              continue;
            } else {
              throw new ArgError(`unknown or unexpected option: ${originalArgName}`, "ARG_UNKNOWN_OPTION");
            }
          }
          const [type, isFlag] = handlers[argName];
          if (!isFlag && j + 1 < separatedArguments.length) {
            throw new ArgError(`option requires argument (but was followed by another short argument): ${originalArgName}`, "ARG_MISSING_REQUIRED_SHORTARG");
          }
          if (isFlag) {
            result[argName] = type(true, argName, result[argName]);
          } else if (argStr === void 0) {
            if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === "-" && !(argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type === Number || typeof BigInt !== "undefined" && type === BigInt))) {
              const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
              throw new ArgError(`option requires argument: ${originalArgName}${extended}`, "ARG_MISSING_REQUIRED_LONGARG");
            }
            result[argName] = type(argv[i + 1], argName, result[argName]);
            ++i;
          } else {
            result[argName] = type(argStr, argName, result[argName]);
          }
        }
      } else {
        result._.push(wholeArg);
      }
    }
    return result;
  }
  arg.flag = (fn) => {
    fn[flagSymbol] = true;
    return fn;
  };
  arg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);
  arg.ArgError = ArgError;
  module2.exports = arg;
});

// ../sdk/dist/cli/utils.js
var require_utils5 = __commonJS2((exports2) => {
  "use strict";
  var __importDefault2 = exports2 && exports2.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : {default: mod2};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isError = exports2.arg = exports2.format = void 0;
  var strip_indent_1 = __importDefault2(require_strip_indent());
  var arg_1 = __importDefault2(require_arg());
  function format(input = "") {
    return strip_indent_1.default(input).trimRight() + "\n";
  }
  exports2.format = format;
  function arg(argv, spec, stopAtPositional = true, permissive = false) {
    try {
      return arg_1.default(spec, {argv, stopAtPositional, permissive});
    } catch (err) {
      return err;
    }
  }
  exports2.arg = arg;
  function isError3(result) {
    return result instanceof Error;
  }
  exports2.isError = isError3;
});

// src/runtime/index.ts
__markAsModule2(exports);
__export2(exports, {
  DMMF: () => import_generator_helper.DMMF,
  DMMFClass: () => DMMFClass,
  Decimal: () => decimal_default,
  Engine: () => import_engine_core.Engine,
  PrismaClientInitializationError: () => import_engine_core.PrismaClientInitializationError,
  PrismaClientKnownRequestError: () => import_engine_core.PrismaClientKnownRequestError,
  PrismaClientRustPanicError: () => import_engine_core.PrismaClientRustPanicError,
  PrismaClientUnknownRequestError: () => import_engine_core.PrismaClientUnknownRequestError,
  PrismaClientValidationError: () => PrismaClientValidationError,
  RawValue: () => import_sql_template_tag.RawValue,
  Sql: () => import_sql_template_tag.Sql,
  Value: () => import_sql_template_tag.Value,
  empty: () => import_sql_template_tag.empty,
  getPrismaClient: () => getPrismaClient,
  join: () => import_sql_template_tag.join,
  makeDocument: () => makeDocument,
  raw: () => import_sql_template_tag.raw,
  sqltag: () => import_sql_template_tag.sqltag,
  transformDocument: () => transformDocument,
  unpack: () => unpack,
  warnEnvConflicts: () => warnEnvConflicts
});

// src/runtime/dmmf-types.ts
var import_generator_helper = __toModule2(require_dist8());

// src/runtime/utils/common.ts
var import_chalk = __toModule2(require_source3());
var import_indent_string = __toModule2(require_indent_string2());
var import_js_levenshtein = __toModule2(require_js_levenshtein());

// ../../node_modules/.pnpm/decimal.js@10.2.1/node_modules/decimal.js/decimal.mjs
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  precision: 20,
  rounding: 4,
  modulo: 1,
  toExpNeg: -7,
  toExpPos: 21,
  minE: -EXP_LIMIT,
  maxE: EXP_LIMIT,
  crypto: false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = {name: "[object Decimal]"};
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i])
      return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (; w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k; i; --i)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0)
      for (i = j; r.d[i] === t.d[i] && i--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; )
    r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
    return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str + w;
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10)
    --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0)
        rd = rd / 100 | 0;
      else if (i == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0)
        rd = rd / 1e3 | 0;
      else if (i == 1)
        rd = rd / 100 | 0;
      else if (i == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, y, len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k; i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a, b, aL, base) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0);
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++)
      ;
    if (yd[i] > (xd[i] || 0))
      e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL)
              prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0]; k >= 10; k /= 10)
        i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits = 1, k = xd[0]; k >= 10; k /= 10)
        digits++;
      i = sd - digits;
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (; k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits = 1; k >= 10; k /= 10)
            digits++;
          i %= LOG_BASE;
          j = i - LOG_BASE + digits;
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i = 1, j = xd[0]; j >= 10; j /= 10)
              i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10)
              k++;
            if (i != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i = xd.length; xd[--i] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits, e) {
  var w = digits[0];
  for (e *= LOG_BASE; w >= 10; w /= 10)
    e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w = digits.length - 1, len = w * LOG_BASE + 1;
  w = digits[w];
  if (w) {
    for (; w % 10 == 0; w /= 10)
      len--;
    for (w = digits[0]; w >= 10; w /= 10)
      len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, ltgt) {
  var y, x = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum2.plus(divide(pow2, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum2 = divide(sum2, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++)
    ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i)
    xd.pop();
  if (i < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3)
    return taylorSeries(Ctor, 2, x, x);
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e) {
  var n = b;
  while (--e)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i = 0, str = ""; i < len; i++)
        str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i = 1, str = "1."; i < len; i++)
              str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len)
          for (e -= len; e--; )
            str += "0";
        else if (e < len)
          str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh(x) {
  return new this(x).acosh();
}
function add(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function config(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh(x) {
  return new this(x).cosh();
}
function clone(obj) {
  var i, p, ps;
  function Decimal2(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal2))
      return new Decimal2(v);
    x.constructor = Decimal2;
    if (v instanceof Decimal2) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
          e++;
        if (external) {
          if (e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i2 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      if (i2 === 43)
        v = v.slice(1);
      x.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config;
  Decimal2.clone = clone;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs;
  Decimal2.acos = acos;
  Decimal2.acosh = acosh;
  Decimal2.add = add;
  Decimal2.asin = asin;
  Decimal2.asinh = asinh;
  Decimal2.atan = atan;
  Decimal2.atanh = atanh;
  Decimal2.atan2 = atan2;
  Decimal2.cbrt = cbrt;
  Decimal2.ceil = ceil;
  Decimal2.cos = cos;
  Decimal2.cosh = cosh;
  Decimal2.div = div;
  Decimal2.exp = exp;
  Decimal2.floor = floor;
  Decimal2.hypot = hypot;
  Decimal2.ln = ln;
  Decimal2.log = log;
  Decimal2.log10 = log10;
  Decimal2.log2 = log2;
  Decimal2.max = max;
  Decimal2.min = min;
  Decimal2.mod = mod;
  Decimal2.mul = mul;
  Decimal2.pow = pow;
  Decimal2.random = random;
  Decimal2.round = round;
  Decimal2.sign = sign;
  Decimal2.sin = sin;
  Decimal2.sinh = sinh;
  Decimal2.sqrt = sqrt;
  Decimal2.sub = sub;
  Decimal2.tan = tan;
  Decimal2.tanh = tanh;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i++]))
          obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.name === "[object Decimal]" || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log2(x) {
  return new this(x).log(2);
}
function log10(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, "lt");
}
function min() {
  return maxOrMin(this, arguments, "gt");
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i < k; )
      rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i < k; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (; rd[i] === 0; i--)
    rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function tan(x) {
  return new this(x).tan();
}
function tanh(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// src/runtime/utils/common.ts
var keyBy = (collection, prop) => {
  const acc = {};
  for (const obj of collection) {
    const key = obj[prop];
    acc[key] = obj;
  }
  return acc;
};
var keyBy2 = (collection1, collection2, prop) => {
  const acc = {};
  for (const obj of collection1) {
    const key = obj[prop];
    acc[key] = obj;
  }
  for (const obj of collection2) {
    const key = obj[prop];
    acc[key] = obj;
  }
  return acc;
};
var ScalarTypeTable = {
  String: true,
  Int: true,
  Float: true,
  Boolean: true,
  Long: true,
  DateTime: true,
  ID: true,
  UUID: true,
  Json: true,
  Bytes: true,
  Decimal: true,
  BigInt: true
};
var JSTypeToGraphQLType = {
  string: "String",
  boolean: "Boolean",
  object: "Json"
};
function stringifyGraphQLType(type) {
  if (typeof type === "string") {
    return type;
  }
  return type.name;
}
function wrapWithList(str, isList) {
  if (isList) {
    return `List<${str}>`;
  }
  return str;
}
var RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
function getGraphQLType(value, potentialType) {
  if (value === null) {
    return "null";
  }
  if (Object.prototype.toString.call(value) === "[object BigInt]") {
    return "BigInt";
  }
  if (decimal_default.isDecimal(value)) {
    return "Decimal";
  }
  if (Buffer.isBuffer(value)) {
    return "Bytes";
  }
  if (Array.isArray(value)) {
    let scalarTypes = value.reduce((acc, val) => {
      const type = getGraphQLType(val, potentialType);
      if (!acc.includes(type)) {
        acc.push(type);
      }
      return acc;
    }, []);
    if (scalarTypes.includes("Float") && scalarTypes.includes("Int")) {
      scalarTypes = ["Float"];
    }
    return `List<${scalarTypes.join(" | ")}>`;
  }
  const jsType = typeof value;
  if (jsType === "number") {
    if (Math.trunc(value) === value) {
      return "Int";
    } else {
      return "Float";
    }
  }
  if (Object.prototype.toString.call(value) === "[object Date]") {
    return "DateTime";
  }
  if (jsType === "string") {
    if (UUID_REGEX.test(value)) {
      return "UUID";
    }
    const date = new Date(value);
    if (potentialType && typeof potentialType === "object" && potentialType.values && potentialType.values.includes(value)) {
      return potentialType.name;
    }
    if (date.toString() === "Invalid Date") {
      return "String";
    }
    if (RFC_3339_REGEX.test(value)) {
      return "DateTime";
    }
  }
  return JSTypeToGraphQLType[jsType];
}
function getSuggestion(str, possibilities) {
  const bestMatch = possibilities.reduce((acc, curr) => {
    const distance = import_js_levenshtein.default(str, curr);
    if (distance < acc.distance) {
      return {
        distance,
        str: curr
      };
    }
    return acc;
  }, {
    distance: Math.min(Math.floor(str.length) * 1.1, ...possibilities.map((p) => p.length * 3)),
    str: null
  });
  return bestMatch.str;
}
function stringifyInputType(input, greenKeys = false) {
  if (typeof input === "string") {
    return input;
  }
  if (input.values) {
    return `enum ${input.name} {
${import_indent_string.default(input.values.join(", "), 2)}
}`;
  } else {
    const body = import_indent_string.default(input.fields.map((arg) => {
      const key = `${arg.name}`;
      const str = `${greenKeys ? import_chalk.default.green(key) : key}${arg.isRequired ? "" : "?"}: ${import_chalk.default.white(arg.inputTypes.map((argType) => {
        return wrapWithList(argIsInputType(argType.type) ? argType.type.name : stringifyGraphQLType(argType.type), argType.isList);
      }).join(" | "))}`;
      if (!arg.isRequired) {
        return import_chalk.default.dim(str);
      }
      return str;
    }).join("\n"), 2);
    return `${import_chalk.default.dim("type")} ${import_chalk.default.bold.dim(input.name)} ${import_chalk.default.dim("{")}
${body}
${import_chalk.default.dim("}")}`;
  }
}
function argIsInputType(arg) {
  if (typeof arg === "string") {
    return false;
  }
  return true;
}
function getInputTypeName(input) {
  if (typeof input === "string") {
    if (input === "Null") {
      return "null";
    }
    return input;
  }
  return input.name;
}
function getOutputTypeName(input) {
  if (typeof input === "string") {
    return input;
  }
  return input.name;
}
function inputTypeToJson(input, isRequired, nameOnly = false) {
  if (typeof input === "string") {
    if (input === "Null") {
      return "null";
    }
    return input;
  }
  if (input.values) {
    return input.values.join(" | ");
  }
  const inputType = input;
  const showDeepType = isRequired && inputType.fields.every((arg) => {
    var _a;
    return arg.inputTypes[0].location === "inputObjectTypes" || ((_a = arg.inputTypes[1]) == null ? void 0 : _a.location) === "inputObjectTypes";
  });
  if (nameOnly) {
    return getInputTypeName(input);
  }
  return inputType.fields.reduce((acc, curr) => {
    let str = "";
    if (!showDeepType && !curr.isRequired) {
      str = curr.inputTypes.map((argType) => getInputTypeName(argType.type)).join(" | ");
    } else {
      str = curr.inputTypes.map((argInputType) => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(" | ");
    }
    acc[curr.name + (curr.isRequired ? "" : "?")] = str;
    return acc;
  }, {});
}
function unionBy(arr1, arr2, iteratee) {
  const map = {};
  for (const element of arr1) {
    map[iteratee(element)] = element;
  }
  for (const element of arr2) {
    const key = iteratee(element);
    if (!map[key]) {
      map[key] = element;
    }
  }
  return Object.values(map);
}
function lowerCase(name) {
  return name.substring(0, 1).toLowerCase() + name.substring(1);
}
function isGroupByOutputName(type) {
  return type.endsWith("GroupByOutputType");
}

// src/runtime/dmmf.ts
var DMMFClass = class {
  constructor({datamodel, schema, mappings}) {
    this.outputTypeToMergedOutputType = (outputType) => {
      const model = this.modelMap[outputType.name];
      return {
        ...outputType,
        isEmbedded: model ? model.isEmbedded : false,
        fields: outputType.fields
      };
    };
    this.datamodel = datamodel;
    this.schema = schema;
    const type = this.schema.inputObjectTypes.prisma.find((t) => t.name === "OperatorCreateNestedOneWithoutAccountsInput");
    this.mappings = mappings;
    this.enumMap = this.getEnumMap();
    this.datamodelEnumMap = this.getDatamodelEnumMap();
    this.queryType = this.getQueryType();
    this.mutationType = this.getMutationType();
    this.modelMap = this.getModelMap();
    this.outputTypes = this.getOutputTypes();
    this.outputTypeMap = this.getMergedOutputTypeMap();
    this.resolveOutputTypes();
    this.inputObjectTypes = this.schema.inputObjectTypes;
    this.inputTypeMap = this.getInputTypeMap();
    this.resolveInputTypes();
    this.resolveFieldArgumentTypes();
    this.mappingsMap = this.getMappingsMap();
    this.queryType = this.outputTypeMap.Query;
    this.mutationType = this.outputTypeMap.Mutation;
    this.rootFieldMap = this.getRootFieldMap();
  }
  get [Symbol.toStringTag]() {
    return "DMMFClass";
  }
  resolveOutputTypes() {
    for (const type of this.outputTypes.model) {
      for (const field of type.fields) {
        if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
        }
      }
      type.fieldMap = keyBy(type.fields, "name");
    }
    for (const type of this.outputTypes.prisma) {
      for (const field of type.fields) {
        if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
          field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
        }
      }
      type.fieldMap = keyBy(type.fields, "name");
    }
  }
  resolveInputTypes() {
    const inputTypes = this.inputObjectTypes.prisma;
    if (this.inputObjectTypes.model) {
      inputTypes.push(...this.inputObjectTypes.model);
    }
    for (const type of inputTypes) {
      for (const field of type.fields) {
        for (const fieldInputType of field.inputTypes) {
          const fieldType = fieldInputType.type;
          if (typeof fieldType === "string" && !ScalarTypeTable[fieldType] && (this.inputTypeMap[fieldType] || this.enumMap[fieldType])) {
            fieldInputType.type = this.inputTypeMap[fieldType] || this.enumMap[fieldType] || fieldType;
          }
        }
      }
      type.fieldMap = keyBy(type.fields, "name");
    }
  }
  resolveFieldArgumentTypes() {
    for (const type of this.outputTypes.prisma) {
      for (const field of type.fields) {
        for (const arg of field.args) {
          for (const argInputType of arg.inputTypes) {
            const argType = argInputType.type;
            if (typeof argType === "string" && !ScalarTypeTable[argType]) {
              argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argType;
            }
          }
        }
      }
    }
    for (const type of this.outputTypes.model) {
      for (const field of type.fields) {
        for (const arg of field.args) {
          for (const argInputType of arg.inputTypes) {
            const argType = argInputType.type;
            if (typeof argType === "string" && !ScalarTypeTable[argType]) {
              argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argInputType.type;
            }
          }
        }
      }
    }
  }
  getQueryType() {
    return this.schema.outputObjectTypes.prisma.find((t) => t.name === "Query");
  }
  getMutationType() {
    return this.schema.outputObjectTypes.prisma.find((t) => t.name === "Mutation");
  }
  getOutputTypes() {
    return {
      model: this.schema.outputObjectTypes.model.map(this.outputTypeToMergedOutputType),
      prisma: this.schema.outputObjectTypes.prisma.map(this.outputTypeToMergedOutputType)
    };
  }
  getDatamodelEnumMap() {
    return keyBy(this.datamodel.enums, "name");
  }
  getEnumMap() {
    return {
      ...keyBy(this.schema.enumTypes.prisma, "name"),
      ...this.schema.enumTypes.model ? keyBy(this.schema.enumTypes.model, "name") : void 0
    };
  }
  getModelMap() {
    return keyBy(this.datamodel.models, "name");
  }
  getMergedOutputTypeMap() {
    return {
      ...keyBy(this.outputTypes.model, "name"),
      ...keyBy(this.outputTypes.prisma, "name")
    };
  }
  getInputTypeMap() {
    return {
      ...this.schema.inputObjectTypes.model ? keyBy(this.schema.inputObjectTypes.model, "name") : void 0,
      ...keyBy(this.schema.inputObjectTypes.prisma, "name")
    };
  }
  getMappingsMap() {
    return keyBy(this.mappings.modelOperations, "model");
  }
  getRootFieldMap() {
    return keyBy2(this.queryType.fields, this.mutationType.fields, "name");
  }
};

// src/runtime/query.ts
var import_chalk5 = __toModule2(require_source3());
var import_indent_string2 = __toModule2(require_indent_string2());

// src/runtime/utils/deep-extend.ts
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
function isSpecificValue(val) {
  return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
}
function cloneSpecificValue(val) {
  if (val instanceof Buffer) {
    const x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
    val.copy(x);
    return x;
  } else if (val instanceof Date) {
    return new Date(val.getTime());
  } else if (val instanceof RegExp) {
    return new RegExp(val);
  } else {
    throw new Error("Unexpected situation");
  }
}
function deepCloneArray(arr) {
  const clone2 = [];
  arr.forEach(function(item, index) {
    if (typeof item === "object" && item !== null) {
      if (Array.isArray(item)) {
        clone2[index] = deepCloneArray(item);
      } else if (isSpecificValue(item)) {
        clone2[index] = cloneSpecificValue(item);
      } else {
        clone2[index] = deepExtend({}, item);
      }
    } else {
      clone2[index] = item;
    }
  });
  return clone2;
}
function safeGetProperty(object, property) {
  return property === "__proto__" ? void 0 : object[property];
}
var deepExtend = function(target, ...args) {
  if (!target || typeof target !== "object") {
    return false;
  }
  if (args.length === 0) {
    return target;
  }
  let val, src;
  for (const obj of args) {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
      continue;
    }
    for (const key of Object.keys(obj)) {
      src = safeGetProperty(target, key);
      val = safeGetProperty(obj, key);
      if (val === target) {
        continue;
      } else if (typeof val !== "object" || val === null) {
        target[key] = val;
        continue;
      } else if (Array.isArray(val)) {
        target[key] = deepCloneArray(val);
        continue;
      } else if (isSpecificValue(val)) {
        target[key] = cloneSpecificValue(val);
        continue;
      } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
        target[key] = deepExtend({}, val);
        continue;
      } else {
        target[key] = deepExtend(src, val);
        continue;
      }
    }
  }
  return target;
};

// src/runtime/utils/deep-set.ts
var keys = (ks) => Array.isArray(ks) ? ks : ks.split(".");
var deepGet = (o, kp) => keys(kp).reduce((o2, k) => o2 && o2[k], o);
var deepSet = (o, kp, v) => keys(kp).reduceRight((v2, k, i, ks) => Object.assign({}, deepGet(o, ks.slice(0, i)), {[k]: v2}), v);

// src/runtime/utils/filterObject.ts
function filterObject(obj, cb) {
  if (!obj || typeof obj !== "object" || typeof obj.hasOwnProperty !== "function") {
    return obj;
  }
  const newObj = {};
  for (const key in obj) {
    const value = obj[key];
    if (Object.hasOwnProperty.call(obj, key) && cb(key, value)) {
      newObj[key] = value;
    }
  }
  return newObj;
}

// src/runtime/utils/omit.ts
function omit(object, path2) {
  const result = {};
  const paths = Array.isArray(path2) ? path2 : [path2];
  for (const key in object) {
    if (Object.hasOwnProperty.call(object, key) && !paths.includes(key)) {
      result[key] = object[key];
    }
  }
  return result;
}

// src/runtime/utils/printJsonErrors.ts
var import_chalk2 = __toModule2(require_source3());
var import_strip_ansi = __toModule2(require_strip_ansi());

// src/runtime/utils/stringifyObject.ts
"use strict";
var isRegexp = require_is_regexp();
var isObj = require_is_obj();
var getOwnEnumPropSymbols = require_lib2().default;
var stringifyObject = (input, options, pad) => {
  const seen = [];
  return function stringifyObject2(input2, options2 = {}, pad2 = "", path2 = []) {
    options2.indent = options2.indent || "	";
    let tokens;
    if (options2.inlineCharacterLimit === void 0) {
      tokens = {
        newLine: "\n",
        newLineOrSpace: "\n",
        pad: pad2,
        indent: pad2 + options2.indent
      };
    } else {
      tokens = {
        newLine: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
        newLineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
        pad: "@@__STRINGIFY_OBJECT_PAD__@@",
        indent: "@@__STRINGIFY_OBJECT_INDENT__@@"
      };
    }
    const expandWhiteSpace = (string) => {
      if (options2.inlineCharacterLimit === void 0) {
        return string;
      }
      const oneLined = string.replace(new RegExp(tokens.newLine, "g"), "").replace(new RegExp(tokens.newLineOrSpace, "g"), " ").replace(new RegExp(tokens.pad + "|" + tokens.indent, "g"), "");
      if (oneLined.length <= options2.inlineCharacterLimit) {
        return oneLined;
      }
      return string.replace(new RegExp(tokens.newLine + "|" + tokens.newLineOrSpace, "g"), "\n").replace(new RegExp(tokens.pad, "g"), pad2).replace(new RegExp(tokens.indent, "g"), pad2 + options2.indent);
    };
    if (seen.indexOf(input2) !== -1) {
      return '"[Circular]"';
    }
    if (Buffer.isBuffer(input2)) {
      return `Buffer(${Buffer.length})`;
    }
    if (input2 === null || input2 === void 0 || typeof input2 === "number" || typeof input2 === "boolean" || typeof input2 === "function" || typeof input2 === "symbol" || isRegexp(input2)) {
      return String(input2);
    }
    if (input2 instanceof Date) {
      return `new Date('${input2.toISOString()}')`;
    }
    if (Array.isArray(input2)) {
      if (input2.length === 0) {
        return "[]";
      }
      seen.push(input2);
      const ret = "[" + tokens.newLine + input2.map((el, i) => {
        const eol = input2.length - 1 === i ? tokens.newLine : "," + tokens.newLineOrSpace;
        let value = stringifyObject2(el, options2, pad2 + options2.indent, [
          ...path2,
          i
        ]);
        if (options2.transformValue) {
          value = options2.transformValue(input2, i, value);
        }
        return tokens.indent + value + eol;
      }).join("") + tokens.pad + "]";
      seen.pop();
      return expandWhiteSpace(ret);
    }
    if (isObj(input2)) {
      let objKeys = Object.keys(input2).concat(getOwnEnumPropSymbols(input2));
      if (options2.filter) {
        objKeys = objKeys.filter((el) => options2.filter(input2, el));
      }
      if (objKeys.length === 0) {
        return "{}";
      }
      seen.push(input2);
      const ret = "{" + tokens.newLine + objKeys.map((el, i) => {
        const eol = objKeys.length - 1 === i ? tokens.newLine : "," + tokens.newLineOrSpace;
        const isSymbol = typeof el === "symbol";
        const isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el);
        const key = isSymbol || isClassic ? el : stringifyObject2(el, options2, void 0, [...path2, el]);
        let value = stringifyObject2(input2[el], options2, pad2 + options2.indent, [...path2, el]);
        if (options2.transformValue) {
          value = options2.transformValue(input2, el, value);
        }
        let line = tokens.indent + String(key) + ": " + value + eol;
        if (options2.transformLine) {
          line = options2.transformLine({
            obj: input2,
            indent: tokens.indent,
            key,
            stringifiedValue: value,
            value: input2[el],
            eol,
            originalLine: line,
            path: path2.concat(key)
          });
        }
        return line;
      }).join("") + tokens.pad + "}";
      seen.pop();
      return expandWhiteSpace(ret);
    }
    input2 = String(input2).replace(/[\r\n]/g, (x) => x === "\n" ? "\\n" : "\\r");
    if (options2.singleQuotes === false) {
      input2 = input2.replace(/"/g, '\\"');
      return `"${input2}"`;
    }
    input2 = input2.replace(/\\?'/g, "\\'");
    return `'${input2}'`;
  }(input, options, pad);
};
var stringifyObject_default = stringifyObject;

// src/runtime/utils/printJsonErrors.ts
var DIM_TOKEN = "@@__DIM_POINTER__@@";
function printJsonWithErrors({
  ast,
  keyPaths,
  valuePaths,
  missingItems
}) {
  let obj = ast;
  for (const {path: path2, type} of missingItems) {
    obj = deepSet(obj, path2, type);
  }
  return stringifyObject_default(obj, {
    indent: "  ",
    transformLine: ({indent: indent3, key, value, stringifiedValue, eol, path: path2}) => {
      const dottedPath = path2.join(".");
      const keyError = keyPaths.includes(dottedPath);
      const valueError = valuePaths.includes(dottedPath);
      const missingItem = missingItems.find((item) => item.path === dottedPath);
      let valueStr = stringifiedValue;
      if (missingItem) {
        if (typeof value === "string") {
          valueStr = valueStr.slice(1, valueStr.length - 1);
        }
        const isRequiredStr = missingItem.isRequired ? "" : "?";
        const prefix = missingItem.isRequired ? "+" : "?";
        const color = missingItem.isRequired ? import_chalk2.default.greenBright : import_chalk2.default.green;
        let output = color(prefixLines(key + isRequiredStr + ": " + valueStr + eol, indent3, prefix));
        if (!missingItem.isRequired) {
          output = import_chalk2.default.dim(output);
        }
        return output;
      } else {
        const isOnMissingItemPath = missingItems.some((item) => dottedPath.startsWith(item.path));
        const isOptional = key[key.length - 2] === "?";
        if (isOptional) {
          key = key.slice(1, key.length - 1);
        }
        if (isOptional && typeof value === "object" && value !== null) {
          valueStr = valueStr.split("\n").map((line, index, arr) => index === arr.length - 1 ? line + DIM_TOKEN : line).join("\n");
        }
        if (isOnMissingItemPath && typeof value === "string") {
          valueStr = valueStr.slice(1, valueStr.length - 1);
          if (!isOptional) {
            valueStr = import_chalk2.default.bold(valueStr);
          }
        }
        if ((typeof value !== "object" || value === null) && !valueError && !isOnMissingItemPath) {
          valueStr = import_chalk2.default.dim(valueStr);
        }
        const keyStr = keyError ? import_chalk2.default.redBright(key) : key;
        valueStr = valueError ? import_chalk2.default.redBright(valueStr) : valueStr;
        let output = indent3 + keyStr + ": " + valueStr + (isOnMissingItemPath ? eol : import_chalk2.default.dim(eol));
        if (keyError || valueError) {
          const lines = output.split("\n");
          const keyLength = String(key).length;
          const keyScribbles = keyError ? import_chalk2.default.redBright("~".repeat(keyLength)) : " ".repeat(keyLength);
          const valueLength = valueError ? getValueLength(indent3, key, value, stringifiedValue) : 0;
          const hideValueScribbles = Boolean(valueError && typeof value === "object" && value !== null);
          const valueScribbles = valueError ? "  " + import_chalk2.default.redBright("~".repeat(valueLength)) : "";
          if (keyScribbles && keyScribbles.length > 0 && !hideValueScribbles) {
            lines.splice(1, 0, indent3 + keyScribbles + valueScribbles);
          }
          if (keyScribbles && keyScribbles.length > 0 && hideValueScribbles) {
            lines.splice(lines.length - 1, 0, indent3.slice(0, indent3.length - 2) + valueScribbles);
          }
          output = lines.join("\n");
        }
        return output;
      }
    }
  });
}
function getValueLength(indent3, key, value, stringifiedValue) {
  if (value === null) {
    return 4;
  }
  if (typeof value === "string") {
    return value.length + 2;
  }
  if (typeof value === "object") {
    return Math.abs(getLongestLine(`${key}: ${import_strip_ansi.default(stringifiedValue)}`) - indent3.length);
  }
  return String(value).length;
}
function getLongestLine(str) {
  return str.split("\n").reduce((max2, curr) => curr.length > max2 ? curr.length : max2, 0);
}
function prefixLines(str, indent3, prefix) {
  return str.split("\n").map((line, index, arr) => index === 0 ? prefix + indent3.slice(1) + line : index < arr.length - 1 ? prefix + line.slice(1) : line).map((line) => {
    return import_strip_ansi.default(line).includes(DIM_TOKEN) ? import_chalk2.default.dim(line.replace(DIM_TOKEN, "")) : line.includes("?") ? import_chalk2.default.dim(line) : line;
  }).join("\n");
}

// src/runtime/utils/printStack.ts
var import_chalk4 = __toModule2(require_source3());
var stackTraceParser = __toModule2(require_stack_trace_parser_cjs());

// src/runtime/highlight/theme.ts
var import_chalk3 = __toModule2(require_source3());
var orange = import_chalk3.default.rgb(246, 145, 95);
var darkBrightBlue = import_chalk3.default.rgb(107, 139, 140);
var blue = import_chalk3.default.cyan;
var brightBlue = import_chalk3.default.rgb(127, 155, 155);
var identity = (str) => str;
var theme = {
  keyword: blue,
  entity: blue,
  value: brightBlue,
  punctuation: darkBrightBlue,
  directive: blue,
  function: blue,
  variable: brightBlue,
  string: import_chalk3.default.greenBright,
  boolean: orange,
  number: import_chalk3.default.cyan,
  comment: import_chalk3.default.grey
};

// src/runtime/highlight/prism.ts
var _self = {};
var uniqueId = 0;
var Prism = {
  manual: _self.Prism && _self.Prism.manual,
  disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
  util: {
    encode: function(tokens) {
      if (tokens instanceof Token) {
        const anyTokens = tokens;
        return new Token(anyTokens.type, Prism.util.encode(anyTokens.content), anyTokens.alias);
      } else if (Array.isArray(tokens)) {
        return tokens.map(Prism.util.encode);
      } else {
        return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
      }
    },
    type: function(o) {
      return Object.prototype.toString.call(o).slice(8, -1);
    },
    objId: function(obj) {
      if (!obj["__id"]) {
        Object.defineProperty(obj, "__id", {value: ++uniqueId});
      }
      return obj["__id"];
    },
    clone: function deepClone(o, visited) {
      let clone2, id, type = Prism.util.type(o);
      visited = visited || {};
      switch (type) {
        case "Object":
          id = Prism.util.objId(o);
          if (visited[id]) {
            return visited[id];
          }
          clone2 = {};
          visited[id] = clone2;
          for (const key in o) {
            if (o.hasOwnProperty(key)) {
              clone2[key] = deepClone(o[key], visited);
            }
          }
          return clone2;
        case "Array":
          id = Prism.util.objId(o);
          if (visited[id]) {
            return visited[id];
          }
          clone2 = [];
          visited[id] = clone2;
          o.forEach(function(v, i) {
            clone2[i] = deepClone(v, visited);
          });
          return clone2;
        default:
          return o;
      }
    }
  },
  languages: {
    extend: function(id, redef) {
      const lang = Prism.util.clone(Prism.languages[id]);
      for (const key in redef) {
        lang[key] = redef[key];
      }
      return lang;
    },
    insertBefore: function(inside, before, insert, root) {
      root = root || Prism.languages;
      const grammar = root[inside];
      const ret = {};
      for (const token in grammar) {
        if (grammar.hasOwnProperty(token)) {
          if (token == before) {
            for (const newToken in insert) {
              if (insert.hasOwnProperty(newToken)) {
                ret[newToken] = insert[newToken];
              }
            }
          }
          if (!insert.hasOwnProperty(token)) {
            ret[token] = grammar[token];
          }
        }
      }
      const old = root[inside];
      root[inside] = ret;
      Prism.languages.DFS(Prism.languages, function(key, value) {
        if (value === old && key != inside) {
          this[key] = ret;
        }
      });
      return ret;
    },
    DFS: function DFS(o, callback, type, visited) {
      visited = visited || {};
      const objId = Prism.util.objId;
      for (const i in o) {
        if (o.hasOwnProperty(i)) {
          callback.call(o, i, o[i], type || i);
          const property = o[i], propertyType = Prism.util.type(property);
          if (propertyType === "Object" && !visited[objId(property)]) {
            visited[objId(property)] = true;
            DFS(property, callback, null, visited);
          } else if (propertyType === "Array" && !visited[objId(property)]) {
            visited[objId(property)] = true;
            DFS(property, callback, i, visited);
          }
        }
      }
    }
  },
  plugins: {},
  highlight: function(text, grammar, language) {
    const env = {
      code: text,
      grammar,
      language
    };
    Prism.hooks.run("before-tokenize", env);
    env.tokens = Prism.tokenize(env.code, env.grammar);
    Prism.hooks.run("after-tokenize", env);
    return Token.stringify(Prism.util.encode(env.tokens), env.language);
  },
  matchGrammar: function(text, strarr, grammar, index, startPos, oneshot, target) {
    for (const token in grammar) {
      if (!grammar.hasOwnProperty(token) || !grammar[token]) {
        continue;
      }
      if (token == target) {
        return;
      }
      let patterns = grammar[token];
      patterns = Prism.util.type(patterns) === "Array" ? patterns : [patterns];
      for (let j = 0; j < patterns.length; ++j) {
        let pattern = patterns[j], inside = pattern.inside, lookbehind = !!pattern.lookbehind, greedy = !!pattern.greedy, lookbehindLength = 0, alias = pattern.alias;
        if (greedy && !pattern.pattern.global) {
          const flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
          pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
        }
        pattern = pattern.pattern || pattern;
        for (let i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {
          let str = strarr[i];
          if (strarr.length > text.length) {
            return;
          }
          if (str instanceof Token) {
            continue;
          }
          if (greedy && i != strarr.length - 1) {
            pattern.lastIndex = pos;
            var match = pattern.exec(text);
            if (!match) {
              break;
            }
            var from = match.index + (lookbehind ? match[1].length : 0), to = match.index + match[0].length, k = i, p = pos;
            for (let len = strarr.length; k < len && (p < to || !strarr[k].type && !strarr[k - 1].greedy); ++k) {
              p += strarr[k].length;
              if (from >= p) {
                ++i;
                pos = p;
              }
            }
            if (strarr[i] instanceof Token) {
              continue;
            }
            delNum = k - i;
            str = text.slice(pos, p);
            match.index -= pos;
          } else {
            pattern.lastIndex = 0;
            var match = pattern.exec(str), delNum = 1;
          }
          if (!match) {
            if (oneshot) {
              break;
            }
            continue;
          }
          if (lookbehind) {
            lookbehindLength = match[1] ? match[1].length : 0;
          }
          var from = match.index + lookbehindLength, match = match[0].slice(lookbehindLength), to = from + match.length, before = str.slice(0, from), after = str.slice(to);
          const args = [i, delNum];
          if (before) {
            ++i;
            pos += before.length;
            args.push(before);
          }
          const wrapped = new Token(token, inside ? Prism.tokenize(match, inside) : match, alias, match, greedy);
          args.push(wrapped);
          if (after) {
            args.push(after);
          }
          Array.prototype.splice.apply(strarr, args);
          if (delNum != 1)
            Prism.matchGrammar(text, strarr, grammar, i, pos, true, token);
          if (oneshot)
            break;
        }
      }
    }
  },
  tokenize: function(text, grammar) {
    const strarr = [text];
    const rest = grammar.rest;
    if (rest) {
      for (const token in rest) {
        grammar[token] = rest[token];
      }
      delete grammar.rest;
    }
    Prism.matchGrammar(text, strarr, grammar, 0, 0, false);
    return strarr;
  },
  hooks: {
    all: {},
    add: function(name, callback) {
      const hooks = Prism.hooks.all;
      hooks[name] = hooks[name] || [];
      hooks[name].push(callback);
    },
    run: function(name, env) {
      const callbacks = Prism.hooks.all[name];
      if (!callbacks || !callbacks.length) {
        return;
      }
      for (var i = 0, callback; callback = callbacks[i++]; ) {
        callback(env);
      }
    }
  },
  Token
};
Prism.languages.clike = {
  comment: [
    {
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: true
    },
    {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: true,
      greedy: true
    }
  ],
  string: {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "class-name": {
    pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
    lookbehind: true,
    inside: {
      punctuation: /[.\\]/
    }
  },
  keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
  boolean: /\b(?:true|false)\b/,
  function: /\w+(?=\()/,
  number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
  operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
  punctuation: /[{}[\];(),.:]/
};
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
      lookbehind: true
    }
  ],
  keyword: [
    {
      pattern: /((?:^|})\s*)(?:catch|finally)\b/,
      lookbehind: true
    },
    {
      pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: true
    }
  ],
  number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
  function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  regex: {
    pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,
    lookbehind: true,
    greedy: true
  },
  "function-variable": {
    pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
    alias: "function"
  },
  parameter: [
    {
      pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }
  ],
  constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
}
Prism.languages.js = Prism.languages.javascript;
Prism.languages.typescript = Prism.languages.extend("javascript", {
  keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,
  builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/
});
Prism.languages.ts = Prism.languages.typescript;
function Token(type, content, alias, matchedStr, greedy) {
  this.type = type;
  this.content = content;
  this.alias = alias;
  this.length = (matchedStr || "").length | 0;
  this.greedy = !!greedy;
}
Token.stringify = function(o, language) {
  if (typeof o == "string") {
    return o;
  }
  if (Array.isArray(o)) {
    return o.map(function(element) {
      return Token.stringify(element, language);
    }).join("");
  }
  return getColorForSyntaxKind(o.type)(o.content);
};
function getColorForSyntaxKind(syntaxKind) {
  return theme[syntaxKind] || identity;
}

// src/runtime/highlight/highlight.ts
function highlightTS(str) {
  return highlight(str, Prism.languages.javascript);
}
function highlight(str, grammar) {
  const tokens = Prism.tokenize(str, grammar);
  return tokens.map((t) => Token.stringify(t)).join("");
}

// src/runtime/utils/dedent.ts
var import_strip_indent = __toModule2(require_strip_indent());
function dedent(str) {
  return import_strip_indent.default(str);
}

// src/runtime/utils/printStack.ts
function renderN(n, max2) {
  const wantedLetters = String(max2).length;
  const hasLetters = String(n).length;
  if (hasLetters >= wantedLetters) {
    return String(n);
  }
  return " ".repeat(wantedLetters - hasLetters) + n;
}
function getIndent(line) {
  let spaceCount = 0;
  for (let i = 0; i < line.length; i++) {
    if (line.charAt(i) !== " ") {
      return spaceCount;
    }
    spaceCount++;
  }
  return spaceCount;
}
function parseStack({
  callsite,
  renderPathRelative,
  originalMethod,
  onUs,
  showColors,
  isValidationError
}) {
  const params = {
    callsiteStr: ":",
    prevLines: "\n",
    functionName: `prisma.${originalMethod}()`,
    afterLines: "",
    indentValue: 0,
    lastErrorHeight: 20
  };
  if (!callsite || typeof window !== "undefined") {
    return params;
  }
  const stack = stackTraceParser.parse(callsite);
  const trace = stack.reverse().find((t) => {
    return t.file && !t.file.includes("@prisma") && !t.file.includes("getPrismaClient") && !t.methodName.includes("new ") && !t.methodName.includes("_getCallsite") && t.methodName.split(".").length < 4;
  });
  if (process.env.NODE_ENV !== "production" && trace && trace.file && trace.lineNumber && trace.column && !trace.file.startsWith("internal/")) {
    const lineNumber = trace.lineNumber;
    const printedFileName = renderPathRelative ? require("path").relative(process.cwd(), trace.file) : trace.file;
    const start = Math.max(0, lineNumber - 4);
    const fs2 = require("fs");
    const exists2 = fs2.existsSync(trace.file);
    if (exists2) {
      const file = fs2.readFileSync(trace.file, "utf-8");
      const slicedFile = file.split("\n").slice(start, lineNumber).join("\n");
      const lines = dedent(slicedFile).split("\n");
      const theLine = lines[lines.length - 1];
      if (!theLine || theLine.trim() === "") {
        params.callsiteStr = ":";
      } else {
        const prismaClientRegex = /(\S+(create|createMany|updateMany|deleteMany|update|delete|findMany|findUnique)\()/;
        const match = prismaClientRegex.exec(theLine);
        if (!match) {
          return params;
        }
        params.functionName = `${match[1]})`;
        params.callsiteStr = ` in
${import_chalk4.default.underline(`${printedFileName}:${trace.lineNumber}:${trace.column}`)}`;
        const slicePoint = theLine.indexOf("{");
        const linesToHighlight = lines.map((l, i, all) => !onUs && i === all.length - 1 ? l.slice(0, slicePoint > -1 ? slicePoint : l.length - 1) : l).join("\n");
        const highlightedLines = showColors ? highlightTS(linesToHighlight).split("\n") : linesToHighlight.split("\n");
        params.prevLines = "\n" + highlightedLines.map((l, i) => import_chalk4.default.grey(renderN(i + start + 1, lineNumber + start + 1) + " ") + import_chalk4.default.reset() + l).map((l, i, arr) => i === arr.length - 1 ? `${import_chalk4.default.red.bold("\u2192")} ${import_chalk4.default.dim(l)}` : import_chalk4.default.dim("  " + l)).join("\n");
        if (!match && !isValidationError) {
          params.prevLines += "\n\n";
        }
        params.afterLines = ")";
        params.indentValue = String(lineNumber + start + 1).length + getIndent(theLine) + 1 + (match ? 2 : 0);
      }
    }
  }
  return params;
}
var printStack = (args) => {
  const {
    callsiteStr,
    prevLines,
    functionName,
    afterLines,
    indentValue,
    lastErrorHeight
  } = parseStack(args);
  const introText = args.onUs ? import_chalk4.default.red(`Oops, an unknown error occured! This is ${import_chalk4.default.bold("on us")}, you did nothing wrong.
It occured in the ${import_chalk4.default.bold(`\`${functionName}\``)} invocation${callsiteStr}`) : import_chalk4.default.red(`Invalid ${import_chalk4.default.bold(`\`${functionName}\``)} invocation${callsiteStr}`);
  const stackStr = `
${introText}
${prevLines}${import_chalk4.default.reset()}`;
  return {indent: indentValue, stack: stackStr, afterLines, lastErrorHeight};
};

// src/runtime/query.ts
var import_strip_ansi2 = __toModule2(require_strip_ansi());

// src/runtime/utils/flatMap.ts
function flatten(array) {
  return Array.prototype.concat.apply([], array);
}
function flatMap(array, callbackFn, thisArg) {
  return flatten(array.map(callbackFn, thisArg));
}

// src/runtime/utils/isObject.ts
var notReallyObjects = {
  "[object Date]": true,
  "[object BitInt]": true,
  "[object Uint8Array]": true,
  "[object Function]": true
};
function isObject(value) {
  return value && typeof value === "object" && !notReallyObjects[Object.prototype.toString.call(value)];
}

// src/runtime/query.ts
var tab = 2;
var Document = class {
  constructor(type, children) {
    this.type = type;
    this.children = children;
    this.printFieldError = ({error}, missingItems, minimal) => {
      if (error.type === "emptySelect") {
        const additional = minimal ? "" : ` Available options are listed in ${import_chalk5.default.greenBright.dim("green")}.`;
        return `The ${import_chalk5.default.redBright("`select`")} statement for type ${import_chalk5.default.bold(getOutputTypeName(error.field.outputType.type))} must not be empty.${additional}`;
      }
      if (error.type === "emptyInclude") {
        if (missingItems.length === 0) {
          return `${import_chalk5.default.bold(getOutputTypeName(error.field.outputType.type))} does not have any relation and therefore can't have an ${import_chalk5.default.redBright("`include`")} statement.`;
        }
        const additional = minimal ? "" : ` Available options are listed in ${import_chalk5.default.greenBright.dim("green")}.`;
        return `The ${import_chalk5.default.redBright("`include`")} statement for type ${import_chalk5.default.bold(getOutputTypeName(error.field.outputType.type))} must not be empty.${additional}`;
      }
      if (error.type === "noTrueSelect") {
        return `The ${import_chalk5.default.redBright("`select`")} statement for type ${import_chalk5.default.bold(getOutputTypeName(error.field.outputType.type))} needs ${import_chalk5.default.bold("at least one truthy value")}.`;
      }
      if (error.type === "includeAndSelect") {
        return `Please ${import_chalk5.default.bold("either")} use ${import_chalk5.default.greenBright("`include`")} or ${import_chalk5.default.greenBright("`select`")}, but ${import_chalk5.default.redBright("not both")} at the same time.`;
      }
      if (error.type === "invalidFieldName") {
        const statement = error.isInclude ? "include" : "select";
        const wording = error.isIncludeScalar ? "Invalid scalar" : "Unknown";
        const additional = minimal ? "" : error.isInclude && missingItems.length === 0 ? `
This model has no relations, so you can't use ${import_chalk5.default.redBright("include")} with it.` : ` Available options are listed in ${import_chalk5.default.greenBright.dim("green")}.`;
        let str = `${wording} field ${import_chalk5.default.redBright(`\`${error.providedName}\``)} for ${import_chalk5.default.bold(statement)} statement on model ${import_chalk5.default.bold.white(error.modelName)}.${additional}`;
        if (error.didYouMean) {
          str += ` Did you mean ${import_chalk5.default.greenBright(`\`${error.didYouMean}\``)}?`;
        }
        if (error.isIncludeScalar) {
          str += `
Note, that ${import_chalk5.default.bold("include")} statements only accept relation fields.`;
        }
        return str;
      }
      if (error.type === "invalidFieldType") {
        const str = `Invalid value ${import_chalk5.default.redBright(`${stringifyObject_default(error.providedValue)}`)} of type ${import_chalk5.default.redBright(getGraphQLType(error.providedValue, void 0))} for field ${import_chalk5.default.bold(`${error.fieldName}`)} on model ${import_chalk5.default.bold.white(error.modelName)}. Expected either ${import_chalk5.default.greenBright("true")} or ${import_chalk5.default.greenBright("false")}.`;
        return str;
      }
    };
    this.printArgError = ({error, path: path2, id}, hasMissingItems, minimal) => {
      if (error.type === "invalidName") {
        let str = `Unknown arg ${import_chalk5.default.redBright(`\`${error.providedName}\``)} in ${import_chalk5.default.bold(path2.join("."))} for type ${import_chalk5.default.bold(error.outputType ? error.outputType.name : getInputTypeName(error.originalType))}.`;
        if (error.didYouMeanField) {
          str += `
\u2192 Did you forget to wrap it with \`${import_chalk5.default.greenBright("select")}\`? ${import_chalk5.default.dim("e.g. " + import_chalk5.default.greenBright(`{ select: { ${error.providedName}: ${error.providedValue} } }`))}`;
        } else if (error.didYouMeanArg) {
          str += ` Did you mean \`${import_chalk5.default.greenBright(error.didYouMeanArg)}\`?`;
          if (!hasMissingItems && !minimal) {
            str += ` ${import_chalk5.default.dim("Available args:")}
` + stringifyInputType(error.originalType, true);
          }
        } else {
          if (error.originalType.fields.length === 0) {
            str += ` The field ${import_chalk5.default.bold(error.originalType.name)} has no arguments.`;
          } else if (!hasMissingItems && !minimal) {
            str += ` Available args:

` + stringifyInputType(error.originalType, true);
          }
        }
        return str;
      }
      if (error.type === "invalidType") {
        let valueStr = stringifyObject_default(error.providedValue, {indent: "  "});
        const multilineValue = valueStr.split("\n").length > 1;
        if (multilineValue) {
          valueStr = `
${valueStr}
`;
        }
        if (error.requiredType.bestFittingType.location === "enumTypes") {
          return `Argument ${import_chalk5.default.bold(error.argName)}: Provided value ${import_chalk5.default.redBright(valueStr)}${multilineValue ? "" : " "}of type ${import_chalk5.default.redBright(getGraphQLType(error.providedValue))} on ${import_chalk5.default.bold(`prisma.${this.children[0].name}`)} is not a ${import_chalk5.default.greenBright(wrapWithList(stringifyGraphQLType(error.requiredType.bestFittingType.location), error.requiredType.bestFittingType.isList))}.
\u2192 Possible values: ${error.requiredType.bestFittingType.type.values.map((v) => import_chalk5.default.greenBright(`${stringifyGraphQLType(error.requiredType.bestFittingType.type)}.${v}`)).join(", ")}`;
        }
        let typeStr = ".";
        if (isInputArgType(error.requiredType.bestFittingType.type)) {
          typeStr = ":\n" + stringifyInputType(error.requiredType.bestFittingType.type);
        }
        let expected = `${error.requiredType.inputType.map((t) => import_chalk5.default.greenBright(wrapWithList(stringifyGraphQLType(t.type), error.requiredType.bestFittingType.isList))).join(" or ")}${typeStr}`;
        const inputType = error.requiredType.inputType.length === 2 && error.requiredType.inputType.find((t) => isInputArgType(t.type)) || null;
        if (inputType) {
          expected += `
` + stringifyInputType(inputType.type, true);
        }
        return `Argument ${import_chalk5.default.bold(error.argName)}: Got invalid value ${import_chalk5.default.redBright(valueStr)}${multilineValue ? "" : " "}on ${import_chalk5.default.bold(`prisma.${this.children[0].name}`)}. Provided ${import_chalk5.default.redBright(getGraphQLType(error.providedValue))}, expected ${expected}`;
      }
      if (error.type === "invalidNullArg") {
        const forStr = path2.length === 1 && path2[0] === error.name ? "" : ` for ${import_chalk5.default.bold(`${path2.join(".")}`)}`;
        const undefinedTip = ` Please use ${import_chalk5.default.bold.greenBright("undefined")} instead.`;
        return `Argument ${import_chalk5.default.greenBright(error.name)}${forStr} must not be ${import_chalk5.default.bold("null")}.${undefinedTip}`;
      }
      if (error.type === "missingArg") {
        const forStr = path2.length === 1 && path2[0] === error.missingName ? "" : ` for ${import_chalk5.default.bold(`${path2.join(".")}`)}`;
        return `Argument ${import_chalk5.default.greenBright(error.missingName)}${forStr} is missing.`;
      }
      if (error.type === "atLeastOne") {
        const additional = minimal ? "" : ` Available args are listed in ${import_chalk5.default.dim.green("green")}.`;
        return `Argument ${import_chalk5.default.bold(path2.join("."))} of type ${import_chalk5.default.bold(error.inputType.name)} needs ${import_chalk5.default.greenBright("at least one")} argument.${additional}`;
      }
      if (error.type === "atMostOne") {
        const additional = minimal ? "" : ` Please choose one. ${import_chalk5.default.dim("Available args:")} 
${stringifyInputType(error.inputType, true)}`;
        return `Argument ${import_chalk5.default.bold(path2.join("."))} of type ${import_chalk5.default.bold(error.inputType.name)} needs ${import_chalk5.default.greenBright("exactly one")} argument, but you provided ${error.providedKeys.map((key) => import_chalk5.default.redBright(key)).join(" and ")}.${additional}`;
      }
    };
    this.type = type;
    this.children = children;
  }
  get [Symbol.toStringTag]() {
    return "Document";
  }
  toString() {
    return `${this.type} {
${import_indent_string2.default(this.children.map(String).join("\n"), tab)}
}`;
  }
  validate(select, isTopLevelQuery = false, originalMethod, errorFormat, validationCallsite) {
    if (!select) {
      select = {};
    }
    const invalidChildren = this.children.filter((child) => child.hasInvalidChild || child.hasInvalidArg);
    if (invalidChildren.length === 0) {
      return;
    }
    const fieldErrors = [];
    const argErrors = [];
    const prefix = select && select.select ? "select" : select.include ? "include" : void 0;
    for (const child of invalidChildren) {
      const errors = child.collectErrors(prefix);
      fieldErrors.push(...errors.fieldErrors.map((e) => ({
        ...e,
        path: isTopLevelQuery ? e.path : e.path.slice(1)
      })));
      argErrors.push(...errors.argErrors.map((e) => ({
        ...e,
        path: isTopLevelQuery ? e.path : e.path.slice(1)
      })));
    }
    const topLevelQueryName = this.children[0].name;
    const queryName = isTopLevelQuery ? this.type : topLevelQueryName;
    const keyPaths = [];
    const valuePaths = [];
    const missingItems = [];
    for (const fieldError of fieldErrors) {
      const path2 = this.normalizePath(fieldError.path, select).join(".");
      if (fieldError.error.type === "invalidFieldName") {
        keyPaths.push(path2);
        const fieldType = fieldError.error.outputType;
        const {isInclude} = fieldError.error;
        fieldType.fields.filter((field) => isInclude ? field.outputType.location === "outputObjectTypes" : true).forEach((field) => {
          const splittedPath = path2.split(".");
          missingItems.push({
            path: `${splittedPath.slice(0, splittedPath.length - 1).join(".")}.${field.name}`,
            type: "true",
            isRequired: false
          });
        });
      } else if (fieldError.error.type === "includeAndSelect") {
        keyPaths.push("select");
        keyPaths.push("include");
      } else {
        valuePaths.push(path2);
      }
      if (fieldError.error.type === "emptySelect" || fieldError.error.type === "noTrueSelect" || fieldError.error.type === "emptyInclude") {
        const selectPathArray = this.normalizePath(fieldError.path, select);
        const selectPath = selectPathArray.slice(0, selectPathArray.length - 1).join(".");
        const fieldType = fieldError.error.field.outputType.type;
        fieldType.fields.filter((field) => fieldError.error.type === "emptyInclude" ? field.outputType.location === "outputObjectTypes" : true).forEach((field) => {
          missingItems.push({
            path: `${selectPath}.${field.name}`,
            type: "true",
            isRequired: false
          });
        });
      }
    }
    for (const argError of argErrors) {
      const path2 = this.normalizePath(argError.path, select).join(".");
      if (argError.error.type === "invalidName") {
        keyPaths.push(path2);
      } else if (argError.error.type !== "missingArg" && argError.error.type !== "atLeastOne") {
        valuePaths.push(path2);
      } else if (argError.error.type === "missingArg") {
        const type = argError.error.missingArg.inputTypes.length === 1 ? argError.error.missingArg.inputTypes[0].type : argError.error.missingArg.inputTypes.map((t) => {
          const inputTypeName = getInputTypeName(t.type);
          if (inputTypeName === "Null") {
            return "null";
          }
          if (t.isList) {
            return inputTypeName + "[]";
          }
          return inputTypeName;
        }).join(" | ");
        missingItems.push({
          path: path2,
          type: inputTypeToJson(type, true, path2.split("where.").length === 2),
          isRequired: argError.error.missingArg.isRequired
        });
      }
    }
    const renderErrorStr = (callsite) => {
      const hasRequiredMissingArgsErrors = argErrors.some((e) => e.error.type === "missingArg" && e.error.missingArg.isRequired);
      const hasOptionalMissingArgsErrors = Boolean(argErrors.find((e) => e.error.type === "missingArg" && !e.error.missingArg.isRequired));
      const hasMissingArgsErrors = hasOptionalMissingArgsErrors || hasRequiredMissingArgsErrors;
      let missingArgsLegend = "";
      if (hasRequiredMissingArgsErrors) {
        missingArgsLegend += `
${import_chalk5.default.dim("Note: Lines with ")}${import_chalk5.default.reset.greenBright("+")} ${import_chalk5.default.dim("are required")}`;
      }
      if (hasOptionalMissingArgsErrors) {
        if (missingArgsLegend.length === 0) {
          missingArgsLegend = "\n";
        }
        if (hasRequiredMissingArgsErrors) {
          missingArgsLegend += import_chalk5.default.dim(`, lines with ${import_chalk5.default.green("?")} are optional`);
        } else {
          missingArgsLegend += import_chalk5.default.dim(`Note: Lines with ${import_chalk5.default.green("?")} are optional`);
        }
        missingArgsLegend += import_chalk5.default.dim(".");
      }
      const relevantArgErrors = argErrors.filter((e) => e.error.type !== "missingArg" || e.error.missingArg.isRequired);
      let errorMessages = relevantArgErrors.map((e) => this.printArgError(e, hasMissingArgsErrors, errorFormat === "minimal")).join("\n");
      errorMessages += `
${fieldErrors.map((e) => this.printFieldError(e, missingItems, errorFormat === "minimal")).join("\n")}`;
      if (errorFormat === "minimal") {
        return import_strip_ansi2.default(errorMessages);
      }
      const {stack, indent: indentValue, afterLines} = printStack({
        callsite,
        originalMethod: originalMethod || queryName,
        showColors: errorFormat && errorFormat === "pretty",
        isValidationError: true
      });
      let printJsonArgs = {
        ast: isTopLevelQuery ? {[topLevelQueryName]: select} : select,
        keyPaths,
        valuePaths,
        missingItems
      };
      if (originalMethod == null ? void 0 : originalMethod.endsWith("aggregate")) {
        printJsonArgs = transformAggregatePrintJsonArgs(printJsonArgs);
      }
      const errorStr = `${stack}${import_indent_string2.default(printJsonWithErrors(printJsonArgs), indentValue).slice(indentValue)}${import_chalk5.default.dim(afterLines)}

${errorMessages}${missingArgsLegend}
`;
      if (process.env.NO_COLOR || errorFormat === "colorless") {
        return import_strip_ansi2.default(errorStr);
      }
      return errorStr;
    };
    const error = new PrismaClientValidationError(renderErrorStr(validationCallsite));
    if (process.env.NODE_ENV !== "production") {
      Object.defineProperty(error, "render", {
        get: () => renderErrorStr,
        enumerable: false
      });
    }
    throw error;
  }
  normalizePath(inputPath, select) {
    const path2 = inputPath.slice();
    const newPath = [];
    let key;
    let pointer = select;
    while ((key = path2.shift()) !== void 0) {
      if (!Array.isArray(pointer) && key === 0) {
        continue;
      }
      if (key === "select") {
        if (!pointer[key]) {
          pointer = pointer.include;
        } else {
          pointer = pointer[key];
        }
      } else if (pointer && pointer[key]) {
        pointer = pointer[key];
      }
      newPath.push(key);
    }
    return newPath;
  }
};
var PrismaClientValidationError = class extends Error {
  get [Symbol.toStringTag]() {
    return "PrismaClientValidationError";
  }
};
var PrismaClientConstructorValidationError = class extends Error {
  constructor(message) {
    super(message + `
Read more at https://pris.ly/d/client-constructor`);
  }
  get [Symbol.toStringTag]() {
    return "PrismaClientConstructorValidationError";
  }
};
var Field = class {
  constructor({name, args, children, error, schemaField}) {
    this.name = name;
    this.args = args;
    this.children = children;
    this.error = error;
    this.schemaField = schemaField;
    this.hasInvalidChild = children ? children.some((child) => Boolean(child.error || child.hasInvalidArg || child.hasInvalidChild)) : false;
    this.hasInvalidArg = args ? args.hasInvalidArg : false;
  }
  get [Symbol.toStringTag]() {
    return "Field";
  }
  toString() {
    let str = this.name;
    if (this.error) {
      return str + " # INVALID_FIELD";
    }
    if (this.args && this.args.args && this.args.args.length > 0) {
      if (this.args.args.length === 1) {
        str += `(${this.args.toString()})`;
      } else {
        str += `(
${import_indent_string2.default(this.args.toString(), tab)}
)`;
      }
    }
    if (this.children) {
      str += ` {
${import_indent_string2.default(this.children.map(String).join("\n"), tab)}
}`;
    }
    return str;
  }
  collectErrors(prefix = "select") {
    const fieldErrors = [];
    const argErrors = [];
    if (this.error) {
      fieldErrors.push({
        path: [this.name],
        error: this.error
      });
    }
    if (this.children) {
      for (const child of this.children) {
        const errors = child.collectErrors(prefix);
        fieldErrors.push(...errors.fieldErrors.map((e) => ({
          ...e,
          path: [this.name, prefix, ...e.path]
        })));
        argErrors.push(...errors.argErrors.map((e) => ({
          ...e,
          path: [this.name, prefix, ...e.path]
        })));
      }
    }
    if (this.args) {
      argErrors.push(...this.args.collectErrors().map((e) => ({...e, path: [this.name, ...e.path]})));
    }
    return {
      fieldErrors,
      argErrors
    };
  }
};
var Args = class {
  constructor(args = []) {
    this.args = args;
    this.hasInvalidArg = args ? args.some((arg) => Boolean(arg.hasError)) : false;
  }
  get [Symbol.toStringTag]() {
    return "Args";
  }
  toString() {
    if (this.args.length === 0) {
      return "";
    }
    return `${this.args.map((arg) => arg.toString()).filter((a) => a).join("\n")}`;
  }
  collectErrors() {
    if (!this.hasInvalidArg) {
      return [];
    }
    return flatMap(this.args, (arg) => arg.collectErrors());
  }
};
function stringify(value, inputType) {
  if (Buffer.isBuffer(value)) {
    return JSON.stringify(value.toString("base64"));
  }
  if (Object.prototype.toString.call(value) === "[object BigInt]") {
    return value.toString();
  }
  if (typeof (inputType == null ? void 0 : inputType.type) === "string" && inputType.type === "Json") {
    if (value === null) {
      return "null";
    }
    if (value && value.values && value.__prismaRawParamaters__) {
      return JSON.stringify(value.values);
    }
    if ((inputType == null ? void 0 : inputType.isList) && Array.isArray(value)) {
      return JSON.stringify(value.map((o) => JSON.stringify(o)));
    }
    return JSON.stringify(JSON.stringify(value));
  }
  if (value === void 0) {
    return null;
  }
  if (value === null) {
    return "null";
  }
  if (decimal_default.isDecimal(value)) {
    return value.toString();
  }
  if ((inputType == null ? void 0 : inputType.location) === "enumTypes" && typeof value === "string") {
    if (Array.isArray(value)) {
      return `[${value.join(", ")}]`;
    }
    return value;
  }
  return JSON.stringify(value, null, 2);
}
var Arg = class {
  constructor({
    key,
    value,
    isEnum = false,
    error,
    schemaArg,
    inputType
  }) {
    this.inputType = inputType;
    this.key = key;
    this.value = value;
    this.isEnum = isEnum;
    this.error = error;
    this.schemaArg = schemaArg;
    this.isNullable = (schemaArg == null ? void 0 : schemaArg.inputTypes.reduce((isNullable) => isNullable && schemaArg.isNullable, true)) || false;
    this.hasError = Boolean(error) || (value instanceof Args ? value.hasInvalidArg : false) || Array.isArray(value) && value.some((v) => v instanceof Args ? v.hasInvalidArg : false);
  }
  get [Symbol.toStringTag]() {
    return "Arg";
  }
  _toString(value, key) {
    var _a;
    if (typeof value === "undefined") {
      return void 0;
    }
    if (value instanceof Args) {
      return `${key}: {
${import_indent_string2.default(value.toString(), 2)}
}`;
    }
    if (Array.isArray(value)) {
      if (((_a = this.inputType) == null ? void 0 : _a.type) === "Json") {
        return `${key}: ${stringify(value, this.inputType)}`;
      }
      const isScalar = !value.some((v) => typeof v === "object");
      return `${key}: [${isScalar ? "" : "\n"}${import_indent_string2.default(value.map((nestedValue) => {
        if (nestedValue instanceof Args) {
          return `{
${import_indent_string2.default(nestedValue.toString(), tab)}
}`;
        }
        return stringify(nestedValue, this.inputType);
      }).join(`,${isScalar ? " " : "\n"}`), isScalar ? 0 : tab)}${isScalar ? "" : "\n"}]`;
    }
    return `${key}: ${stringify(value, this.inputType)}`;
  }
  toString() {
    return this._toString(this.value, this.key);
  }
  collectErrors() {
    var _a;
    if (!this.hasError) {
      return [];
    }
    const errors = [];
    if (this.error) {
      const id = typeof ((_a = this.inputType) == null ? void 0 : _a.type) === "object" ? `${this.inputType.type.name}${this.inputType.isList ? "[]" : ""}` : void 0;
      errors.push({
        error: this.error,
        path: [this.key],
        id
      });
    }
    if (Array.isArray(this.value)) {
      errors.push(...flatMap(this.value, (val, index) => {
        if (!(val == null ? void 0 : val.collectErrors)) {
          return [];
        }
        return val.collectErrors().map((e) => {
          return {...e, path: [this.key, index, ...e.path]};
        });
      }));
    }
    if (this.value instanceof Args) {
      errors.push(...this.value.collectErrors().map((e) => ({...e, path: [this.key, ...e.path]})));
    }
    return errors;
  }
};
function makeDocument({
  dmmf,
  rootTypeName,
  rootField,
  select
}) {
  if (!select) {
    select = {};
  }
  const rootType = rootTypeName === "query" ? dmmf.queryType : dmmf.mutationType;
  const fakeRootField = {
    args: [],
    outputType: {
      isList: false,
      type: rootType,
      location: "outputObjectTypes"
    },
    name: rootTypeName
  };
  const children = selectionToFields(dmmf, {[rootField]: select}, fakeRootField, [rootTypeName]);
  return new Document(rootTypeName, children);
}
function transformDocument(document2) {
  return document2;
}
function selectionToFields(dmmf, selection, schemaField, path2) {
  const outputType = schemaField.outputType.type;
  return Object.entries(selection).reduce((acc, [name, value]) => {
    const field = outputType.fieldMap ? outputType.fieldMap[name] : outputType.fields.find((f) => f.name === name);
    if (!field) {
      acc.push(new Field({
        name,
        children: [],
        error: {
          type: "invalidFieldName",
          modelName: outputType.name,
          providedName: name,
          didYouMean: getSuggestion(name, outputType.fields.map((f) => f.name)),
          outputType
        }
      }));
      return acc;
    }
    if (typeof value !== "boolean" && field.outputType.location === "scalar" && field.name !== "executeRaw" && field.name !== "queryRaw" && outputType.name !== "Query" && !name.startsWith("aggregate") && field.name !== "count") {
      acc.push(new Field({
        name,
        children: [],
        error: {
          type: "invalidFieldType",
          modelName: outputType.name,
          fieldName: name,
          providedValue: value
        }
      }));
      return acc;
    }
    if (value === false) {
      return acc;
    }
    const transformedField = {
      name: field.name,
      fields: field.args,
      constraints: {
        minNumFields: null,
        maxNumFields: null
      }
    };
    const argsWithoutIncludeAndSelect = typeof value === "object" ? omit(value, ["include", "select"]) : void 0;
    const args = argsWithoutIncludeAndSelect ? objectToArgs(argsWithoutIncludeAndSelect, transformedField, [], typeof field === "string" ? void 0 : field.outputType.type) : void 0;
    const isRelation = field.outputType.location === "outputObjectTypes";
    if (value) {
      if (value.select && value.include) {
        acc.push(new Field({
          name,
          children: [
            new Field({
              name: "include",
              args: new Args(),
              error: {
                type: "includeAndSelect",
                field
              }
            })
          ]
        }));
      } else if (value.include) {
        const keys2 = Object.keys(value.include);
        if (keys2.length === 0) {
          acc.push(new Field({
            name,
            children: [
              new Field({
                name: "include",
                args: new Args(),
                error: {
                  type: "emptyInclude",
                  field
                }
              })
            ]
          }));
          return acc;
        }
        if (field.outputType.location === "outputObjectTypes") {
          const fieldOutputType = field.outputType.type;
          const allowedKeys = fieldOutputType.fields.filter((f) => f.outputType.location === "outputObjectTypes").map((f) => f.name);
          const invalidKeys = keys2.filter((key) => !allowedKeys.includes(key));
          if (invalidKeys.length > 0) {
            acc.push(...invalidKeys.map((invalidKey) => new Field({
              name: invalidKey,
              children: [
                new Field({
                  name: invalidKey,
                  args: new Args(),
                  error: {
                    type: "invalidFieldName",
                    modelName: fieldOutputType.name,
                    outputType: fieldOutputType,
                    providedName: invalidKey,
                    didYouMean: getSuggestion(invalidKey, allowedKeys) || void 0,
                    isInclude: true,
                    isIncludeScalar: fieldOutputType.fields.some((f) => f.name === invalidKey)
                  }
                })
              ]
            })));
            return acc;
          }
        }
      } else if (value.select) {
        const values = Object.values(value.select);
        if (values.length === 0) {
          acc.push(new Field({
            name,
            children: [
              new Field({
                name: "select",
                args: new Args(),
                error: {
                  type: "emptySelect",
                  field
                }
              })
            ]
          }));
          return acc;
        }
        const truthyValues = values.filter((v) => v);
        if (truthyValues.length === 0) {
          acc.push(new Field({
            name,
            children: [
              new Field({
                name: "select",
                args: new Args(),
                error: {
                  type: "noTrueSelect",
                  field
                }
              })
            ]
          }));
          return acc;
        }
      }
    }
    const defaultSelection = isRelation ? getDefaultSelection(field.outputType.type) : null;
    let select = defaultSelection;
    if (value) {
      if (value.select) {
        select = value.select;
      } else if (value.include) {
        select = deepExtend(defaultSelection, value.include);
      } else if (value.by && Array.isArray(value.by) && field.outputType.namespace === "prisma" && field.outputType.location === "outputObjectTypes" && isGroupByOutputName(field.outputType.type.name)) {
        select = byToSelect(value.by);
      }
    }
    const children = select !== false && isRelation ? selectionToFields(dmmf, select, field, [...path2, name]) : void 0;
    acc.push(new Field({name, args, children, schemaField: field}));
    return acc;
  }, []);
}
function byToSelect(by) {
  const obj = Object.create(null);
  for (const b of by) {
    obj[b] = true;
  }
  return obj;
}
function getDefaultSelection(outputType) {
  const acc = Object.create(null);
  for (const f of outputType.fields) {
    if (f.outputType.location === "scalar" || f.outputType.location === "enumTypes") {
      acc[f.name] = true;
    } else {
      if (f.outputType.type.isEmbedded) {
        acc[f.name] = {
          select: getDefaultSelection(f.outputType.type)
        };
      }
    }
  }
  return acc;
}
function getInvalidTypeArg(key, value, arg, bestFittingType) {
  const arrg = new Arg({
    key,
    value,
    isEnum: bestFittingType.location === "enumTypes",
    inputType: bestFittingType,
    error: {
      type: "invalidType",
      providedValue: value,
      argName: key,
      requiredType: {
        inputType: arg.inputTypes,
        bestFittingType
      }
    }
  });
  return arrg;
}
function hasCorrectScalarType(value, arg, inputType) {
  const {type, isList} = inputType;
  const expectedType = wrapWithList(stringifyGraphQLType(type), isList);
  const graphQLType = getGraphQLType(value, type);
  if (graphQLType === expectedType) {
    return true;
  }
  if (isList && graphQLType === "List<>") {
    return true;
  }
  if (expectedType === "Json") {
    return true;
  }
  if (graphQLType === "Int" && expectedType === "BigInt") {
    return true;
  }
  if (graphQLType === "List<Int>" && expectedType === "List<BigInt>") {
    return true;
  }
  if (graphQLType === "List<BigInt | Int>" && expectedType === "List<BigInt>") {
    return true;
  }
  if (graphQLType === "List<Int | BigInt>" && expectedType === "List<BigInt>") {
    return true;
  }
  if ((graphQLType === "Int" || graphQLType === "Float") && expectedType === "Decimal") {
    return true;
  }
  if ((graphQLType === "List<Int>" || graphQLType === "List<Float>") && expectedType === "List<Decimal>") {
    return true;
  }
  if (graphQLType === "DateTime" && expectedType === "String") {
    return true;
  }
  if (graphQLType === "List<DateTime>" && expectedType === "List<String>") {
    return true;
  }
  if (graphQLType === "UUID" && expectedType === "String") {
    return true;
  }
  if (graphQLType === "List<UUID>" && expectedType === "List<String>") {
    return true;
  }
  if (graphQLType === "String" && expectedType === "ID") {
    return true;
  }
  if (graphQLType === "List<String>" && expectedType === "List<ID>") {
    return true;
  }
  if (graphQLType === "List<String>" && expectedType === "List<Json>") {
    return true;
  }
  if (expectedType === "List<String>" && (graphQLType === "List<String | UUID>" || graphQLType === "List<UUID | String>")) {
    return true;
  }
  if (graphQLType === "Int" && expectedType === "Float") {
    return true;
  }
  if (graphQLType === "List<Int>" && expectedType === "List<Float>") {
    return true;
  }
  if (graphQLType === "Int" && expectedType === "Long") {
    return true;
  }
  if (graphQLType === "List<Int>" && expectedType === "List<Long>") {
    return true;
  }
  if (graphQLType === "String" && expectedType === "Decimal" && /^\-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i.test(value)) {
    return true;
  }
  if (!arg.isRequired && value === null) {
    return true;
  }
  return false;
}
var cleanObject = (obj) => filterObject(obj, (k, v) => v !== void 0);
function valueToArg(key, value, arg) {
  let maybeArg = null;
  const argsWithErrors = [];
  for (const inputType of arg.inputTypes) {
    maybeArg = tryInferArgs(key, value, arg, inputType);
    if ((maybeArg == null ? void 0 : maybeArg.collectErrors().length) === 0) {
      return maybeArg;
    }
    if (maybeArg && (maybeArg == null ? void 0 : maybeArg.collectErrors())) {
      const argErrors = maybeArg == null ? void 0 : maybeArg.collectErrors();
      if (argErrors && argErrors.length > 0) {
        argsWithErrors.push({arg: maybeArg, errors: argErrors});
      }
    }
  }
  if ((maybeArg == null ? void 0 : maybeArg.hasError) && argsWithErrors.length > 0) {
    const argsWithScores = argsWithErrors.map(({arg: arg2, errors}) => {
      const errorScores = errors.map((e) => {
        let score = 1;
        if (e.error.type === "invalidType") {
          score = 2 * Math.exp(getDepth(e.error.providedValue)) + 1;
        }
        score += Math.log(e.path.length);
        if (e.error.type === "missingArg") {
          if (arg2.inputType && isInputArgType(arg2.inputType.type) && arg2.inputType.type.name.includes("Unchecked")) {
            score *= 2;
          }
        }
        if (e.error.type === "invalidName") {
          if (isInputArgType(e.error.originalType)) {
            if (e.error.originalType.name.includes("Unchecked")) {
              score *= 2;
            }
          }
        }
        return score;
      });
      return {
        score: errors.length + sum(errorScores),
        arg: arg2,
        errors
      };
    });
    let scoresEqual = true;
    const currentScore = argsWithScores[0].score;
    for (const {score} of argsWithScores) {
      if (score !== currentScore) {
        scoresEqual = false;
        break;
      }
    }
    if (!scoresEqual) {
      argsWithScores.sort((a, b) => a.score < b.score ? -1 : 1);
    }
    return argsWithScores[0].arg;
  }
  return maybeArg;
}
function getDepth(object) {
  let level = 1;
  if (!object || typeof object !== "object") {
    return level;
  }
  for (const key in object) {
    if (!Object.prototype.hasOwnProperty.call(object, key)) {
      continue;
    }
    if (typeof object[key] === "object") {
      const depth = getDepth(object[key]) + 1;
      level = Math.max(depth, level);
    }
  }
  return level;
}
function sum(n) {
  return n.reduce((acc, curr) => acc + curr, 0);
}
function tryInferArgs(key, value, arg, inputType) {
  var _a, _b, _c, _d;
  if (typeof value === "undefined") {
    if (!arg.isRequired) {
      return null;
    }
    return new Arg({
      key,
      value,
      isEnum: inputType.location === "enumTypes",
      inputType,
      error: {
        type: "missingArg",
        missingName: key,
        missingArg: arg,
        atLeastOne: false,
        atMostOne: false
      }
    });
  }
  const {isNullable, isRequired} = arg;
  if (value === null && !isNullable && !isRequired) {
    const isAtLeastOne = isInputArgType(inputType.type) ? inputType.type.constraints.minNumFields !== null && inputType.type.constraints.minNumFields > 0 : false;
    if (!isAtLeastOne) {
      return new Arg({
        key,
        value,
        isEnum: inputType.location === "enumTypes",
        inputType,
        error: {
          type: "invalidNullArg",
          name: key,
          invalidType: arg.inputTypes,
          atLeastOne: false,
          atMostOne: false
        }
      });
    }
  }
  if (!inputType.isList) {
    if (isInputArgType(inputType.type)) {
      if (typeof value !== "object" || Array.isArray(value) || inputType.location === "inputObjectTypes" && !isObject(value)) {
        return getInvalidTypeArg(key, value, arg, inputType);
      } else {
        const val = cleanObject(value);
        let error;
        const keys2 = Object.keys(val || {});
        const numKeys = keys2.length;
        if (numKeys === 0 && typeof inputType.type.constraints.minNumFields === "number" && inputType.type.constraints.minNumFields > 0) {
          error = {
            type: "atLeastOne",
            key,
            inputType: inputType.type
          };
        } else if (numKeys > 1 && typeof inputType.type.constraints.maxNumFields === "number" && inputType.type.constraints.maxNumFields < 2) {
          error = {
            type: "atMostOne",
            key,
            inputType: inputType.type,
            providedKeys: keys2
          };
        }
        return new Arg({
          key,
          value: val === null ? null : objectToArgs(val, inputType.type, arg.inputTypes),
          isEnum: inputType.location === "enumTypes",
          error,
          inputType,
          schemaArg: arg
        });
      }
    } else {
      return scalarToArg(key, value, arg, inputType);
    }
  }
  if (!Array.isArray(value) && inputType.isList) {
    if (key !== "updateMany") {
      value = [value];
    }
  }
  if (inputType.location === "enumTypes" || inputType.location === "scalar") {
    return scalarToArg(key, value, arg, inputType);
  }
  const argInputType = inputType.type;
  const hasAtLeastOneError = typeof ((_a = argInputType.constraints) == null ? void 0 : _a.minNumFields) === "number" && ((_b = argInputType.constraints) == null ? void 0 : _b.minNumFields) > 0 ? Array.isArray(value) && value.some((v) => !v || Object.keys(cleanObject(v)).length === 0) : false;
  let err = hasAtLeastOneError ? {
    inputType: argInputType,
    key,
    type: "atLeastOne"
  } : void 0;
  if (!err) {
    const hasOneOfError = typeof ((_c = argInputType.constraints) == null ? void 0 : _c.maxNumFields) === "number" && ((_d = argInputType.constraints) == null ? void 0 : _d.maxNumFields) < 2 ? Array.isArray(value) && value.find((v) => !v || Object.keys(cleanObject(v)).length !== 1) : false;
    if (hasOneOfError) {
      err = {
        inputType: argInputType,
        key,
        type: "atMostOne",
        providedKeys: Object.keys(hasOneOfError)
      };
    }
  }
  if (!Array.isArray(value)) {
    for (const nestedArgInputType of arg.inputTypes) {
      const args = objectToArgs(value, nestedArgInputType.type);
      if (args.collectErrors().length === 0) {
        return new Arg({
          key,
          value: args,
          isEnum: false,
          schemaArg: arg,
          inputType: nestedArgInputType
        });
      }
    }
  }
  return new Arg({
    key,
    value: value.map((v) => {
      if (inputType.isList && typeof v !== "object") {
        return v;
      }
      if (typeof v !== "object" || !value) {
        return getInvalidTypeArg(key, v, arg, inputType);
      }
      return objectToArgs(v, argInputType);
    }),
    isEnum: false,
    inputType,
    schemaArg: arg,
    error: err
  });
}
function isInputArgType(argType) {
  if (typeof argType === "string") {
    return false;
  }
  if (Object.hasOwnProperty.call(argType, "values")) {
    return false;
  }
  return true;
}
function scalarToArg(key, value, arg, inputType) {
  if (hasCorrectScalarType(value, arg, inputType)) {
    return new Arg({
      key,
      value,
      isEnum: inputType.location === "enumTypes",
      schemaArg: arg,
      inputType
    });
  }
  return getInvalidTypeArg(key, value, arg, inputType);
}
function objectToArgs(initialObj, inputType, possibilities, outputType) {
  const obj = cleanObject(initialObj);
  const {fields: args, fieldMap} = inputType;
  const requiredArgs = args.map((arg) => [arg.name, void 0]);
  const objEntries = Object.entries(obj || {});
  const entries = unionBy(objEntries, requiredArgs, (a) => a[0]);
  const argsList = entries.reduce((acc, [argName, value]) => {
    const schemaArg = fieldMap ? fieldMap[argName] : args.find((a) => a.name === argName);
    if (!schemaArg) {
      const didYouMeanField = typeof value === "boolean" && outputType && outputType.fields.some((f) => f.name === argName) ? argName : null;
      acc.push(new Arg({
        key: argName,
        value,
        error: {
          type: "invalidName",
          providedName: argName,
          providedValue: value,
          didYouMeanField,
          didYouMeanArg: !didYouMeanField && getSuggestion(argName, [
            ...args.map((a) => a.name),
            "select"
          ]) || void 0,
          originalType: inputType,
          possibilities,
          outputType
        }
      }));
      return acc;
    }
    const arg = valueToArg(argName, value, schemaArg);
    if (arg) {
      acc.push(arg);
    }
    return acc;
  }, []);
  if (typeof inputType.constraints.minNumFields === "number" && objEntries.length < inputType.constraints.minNumFields || argsList.find((arg) => {
    var _a, _b;
    return ((_a = arg.error) == null ? void 0 : _a.type) === "missingArg" || ((_b = arg.error) == null ? void 0 : _b.type) === "atLeastOne";
  })) {
    const optionalMissingArgs = inputType.fields.filter((field) => !field.isRequired && obj && (typeof obj[field.name] === "undefined" || obj[field.name] === null));
    argsList.push(...optionalMissingArgs.map((arg) => {
      const argInputType = arg.inputTypes[0];
      return new Arg({
        key: arg.name,
        value: void 0,
        isEnum: argInputType.location === "enumTypes",
        error: {
          type: "missingArg",
          missingName: arg.name,
          missingArg: arg,
          atLeastOne: Boolean(inputType.constraints.minNumFields) || false,
          atMostOne: inputType.constraints.maxNumFields === 1 || false
        },
        inputType: argInputType
      });
    }));
  }
  return new Args(argsList);
}
function unpack({document: document2, path: path2, data}) {
  const result = deepGet(data, path2);
  if (result === "undefined") {
    return null;
  }
  if (typeof result !== "object") {
    return result;
  }
  const field = getField(document2, path2);
  return mapScalars({field, data: result});
}
function mapScalars({field, data}) {
  var _a;
  if (!data || typeof data !== "object" || !field.children || !field.schemaField) {
    return data;
  }
  const deserializers = {
    DateTime: (value) => new Date(value),
    Json: (value) => JSON.parse(value),
    Bytes: (value) => Buffer.from(value, "base64"),
    Decimal: (value) => {
      return new decimal_default(value);
    },
    BigInt: (value) => BigInt(value)
  };
  for (const child of field.children) {
    const outputType = (_a = child.schemaField) == null ? void 0 : _a.outputType.type;
    if (outputType && typeof outputType === "string") {
      const deserializer = deserializers[outputType];
      if (deserializer) {
        if (Array.isArray(data)) {
          for (const entry of data) {
            if (typeof entry[child.name] !== "undefined" && entry[child.name] !== null) {
              if (Array.isArray(entry[child.name])) {
                entry[child.name] = entry[child.name].map(deserializer);
              } else {
                entry[child.name] = deserializer(entry[child.name]);
              }
            }
          }
        } else {
          if (typeof data[child.name] !== "undefined" && data[child.name] !== null) {
            if (Array.isArray(data[child.name])) {
              data[child.name] = data[child.name].map(deserializer);
            } else {
              data[child.name] = deserializer(data[child.name]);
            }
          }
        }
      }
    }
    if (child.schemaField && child.schemaField.outputType.location === "outputObjectTypes") {
      if (Array.isArray(data)) {
        for (const entry of data) {
          mapScalars({field: child, data: entry[child.name]});
        }
      } else {
        mapScalars({field: child, data: data[child.name]});
      }
    }
  }
  return data;
}
function getField(document2, path2) {
  const todo = path2.slice();
  const firstElement = todo.shift();
  let pointer = document2.children.find((c) => c.name === firstElement);
  if (!pointer) {
    throw new Error(`Could not find field ${firstElement} in document ${document2}`);
  }
  while (todo.length > 0) {
    const key = todo.shift();
    if (!pointer.children) {
      throw new Error(`Can't get children for field ${pointer} with child ${key}`);
    }
    const child = pointer.children.find((c) => c.name === key);
    if (!child) {
      throw new Error(`Can't find child ${key} of field ${pointer}`);
    }
    pointer = child;
  }
  return pointer;
}
function removeSelectFromPath(path2) {
  return path2.split(".").filter((p) => p !== "select").join(".");
}
function removeSelectFromObject(obj) {
  const type = Object.prototype.toString.call(obj);
  if (type === "[object Object]") {
    const copy = {};
    for (const key in obj) {
      if (key === "select") {
        for (const subKey in obj["select"]) {
          copy[subKey] = removeSelectFromObject(obj["select"][subKey]);
        }
      } else {
        copy[key] = removeSelectFromObject(obj[key]);
      }
    }
    return copy;
  }
  return obj;
}
function transformAggregatePrintJsonArgs({
  ast,
  keyPaths,
  missingItems,
  valuePaths
}) {
  const newKeyPaths = keyPaths.map(removeSelectFromPath);
  const newValuePaths = valuePaths.map(removeSelectFromPath);
  const newMissingItems = missingItems.map((item) => ({
    path: removeSelectFromPath(item.path),
    isRequired: item.isRequired,
    type: item.type
  }));
  const newAst = removeSelectFromObject(ast);
  return {
    ast: newAst,
    keyPaths: newKeyPaths,
    missingItems: newMissingItems,
    valuePaths: newValuePaths
  };
}

// src/runtime/index.ts
var import_engine_core = __toModule2(require_dist11());

// src/runtime/getPrismaClient.ts
var import_debug2 = __toModule2(require_dist7());
var import_NAPIEngine = __toModule2(require_NAPIEngine());
var import_NodeEngine = __toModule2(require_NodeEngine());
var logger2 = __toModule2(require_logger());
var import_mapPreviewFeatures = __toModule2(require_mapPreviewFeatures());
var import_tryLoadEnvs = __toModule2(require_tryLoadEnvs());
var import_async_hooks = __toModule2(require("async_hooks"));
var import_fs = __toModule2(require("fs"));
var import_path2 = __toModule2(require("path"));
var sqlTemplateTag = __toModule2(require_dist12());
var import_strip_ansi3 = __toModule2(require_strip_ansi());

// src/runtime/Dataloader.ts
var Dataloader = class {
  constructor(options) {
    this.options = options;
    this.tickActive = false;
    this.batches = {};
  }
  get [Symbol.toStringTag]() {
    return "Dataloader";
  }
  request(request) {
    const hash = this.options.batchBy(request);
    if (!hash) {
      return this.options.singleLoader(request);
    }
    if (!this.batches[hash]) {
      this.batches[hash] = [];
      if (!this.tickActive) {
        this.tickActive = true;
        process.nextTick(() => {
          this.dispatchBatches();
          this.tickActive = false;
        });
      }
    }
    return new Promise((resolve, reject) => {
      this.batches[hash].push({
        request,
        resolve,
        reject
      });
    });
  }
  dispatchBatches() {
    for (const key in this.batches) {
      const batch = this.batches[key];
      delete this.batches[key];
      if (batch.length === 1) {
        this.options.singleLoader(batch[0].request).then((result) => {
          if (result instanceof Error) {
            batch[0].reject(result);
          } else {
            batch[0].resolve(result);
          }
        }).catch((e) => {
          batch[0].reject(e);
        });
      } else {
        this.options.batchLoader(batch.map((j) => j.request)).then((results) => {
          if (results instanceof Error) {
            for (let i = 0; i < batch.length; i++) {
              batch[i].reject(results);
            }
          } else {
            for (let i = 0; i < batch.length; i++) {
              const value = results[i];
              if (value instanceof Error) {
                batch[i].reject(value);
              } else {
                batch[i].resolve(value);
              }
            }
          }
        }).catch((e) => {
          for (let i = 0; i < batch.length; i++) {
            batch[i].reject(e);
          }
        });
      }
    }
  }
};

// src/runtime/getLogLevel.ts
function getLogLevel(log4) {
  if (typeof log4 === "string") {
    return log4;
  }
  return log4.reduce((acc, curr) => {
    const currentLevel = typeof curr === "string" ? curr : curr.level;
    if (currentLevel === "query") {
      return acc;
    }
    if (!acc) {
      return currentLevel;
    }
    if (curr === "info" || acc === "info") {
      return "info";
    }
    return currentLevel;
  }, void 0);
}

// src/runtime/mergeBy.ts
function mergeBy(arr1, arr2, cb) {
  const groupedArr1 = groupBy(arr1, cb);
  const groupedArr2 = groupBy(arr2, cb);
  const result = Object.values(groupedArr2).map((value) => value[value.length - 1]);
  const arr2Keys = Object.keys(groupedArr2);
  Object.entries(groupedArr1).forEach(([key, value]) => {
    if (!arr2Keys.includes(key)) {
      result.push(value[value.length - 1]);
    }
  });
  return result;
}
var groupBy = (arr, cb) => {
  return arr.reduce((acc, curr) => {
    const key = cb(curr);
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(curr);
    return acc;
  }, {});
};

// src/runtime/utils/clientVersion.ts
var clientVersion = require_package2().version;

// src/runtime/utils/mssqlPreparedStatement.ts
var mssqlPreparedStatement = (template) => {
  return template.reduce((acc, str, idx) => `${acc}@P${idx}${str}`);
};

// src/runtime/utils/rejectOnNotFound.ts
var import_utils = __toModule2(require_utils5());
var NotFoundError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NotFoundError";
    this.stack = void 0;
  }
};
function getRejectOnNotFound(action, modelName, args, clientInstance) {
  let rejectOnNotFound;
  if (args && typeof args === "object" && "rejectOnNotFound" in args && args["rejectOnNotFound"] !== void 0) {
    rejectOnNotFound = args["rejectOnNotFound"];
    delete args["rejectOnNotFound"];
  } else if (typeof clientInstance === "boolean") {
    rejectOnNotFound = clientInstance;
  } else if (clientInstance && typeof clientInstance === "object" && action in clientInstance) {
    const rejectPerOperation = clientInstance[action];
    if (rejectPerOperation && typeof rejectPerOperation === "object") {
      if (modelName in rejectPerOperation) {
        return rejectPerOperation[modelName];
      }
      return void 0;
    }
    rejectOnNotFound = getRejectOnNotFound(action, modelName, args, rejectPerOperation);
  } else if (typeof clientInstance === "function") {
    rejectOnNotFound = clientInstance;
  } else {
    rejectOnNotFound = false;
  }
  return rejectOnNotFound;
}
var REGEX = /(findUnique|findFirst)/;
function throwIfNotFound(data, clientMethod, typeName, rejectOnNotFound) {
  if (rejectOnNotFound && !data && REGEX.exec(clientMethod)) {
    if (typeof rejectOnNotFound === "boolean" && rejectOnNotFound) {
      throw new NotFoundError(`No ${typeName} found`);
    } else if (typeof rejectOnNotFound === "function") {
      throw rejectOnNotFound(new NotFoundError(`No ${typeName} found`));
    } else if (import_utils.isError(rejectOnNotFound)) {
      throw rejectOnNotFound;
    }
    throw new NotFoundError(`No ${typeName} found`);
  }
}

// src/runtime/utils/serializeRawParameters.ts
function serializeRawParameters(data) {
  return JSON.stringify(serializeBigInt(replaceDates(data)));
}
function replaceDates(data) {
  const type = Object.prototype.toString.call(data);
  if (type === "[object Date]") {
    return {
      prisma__type: "date",
      prisma__value: data.toJSON()
    };
  }
  if (type === "[object Object]") {
    const tmp = {};
    for (const key in data) {
      if (key !== "__proto__") {
        tmp[key] = replaceDates(data[key]);
      }
    }
    return tmp;
  }
  if (type === "[object Array]") {
    let k = data.length;
    let tmp;
    for (tmp = new Array(k); k--; ) {
      tmp[k] = replaceDates(data[k]);
    }
    return tmp;
  }
  return data;
}
function serializeBigInt(data) {
  const type = Object.prototype.toString.call(data);
  if (type === "[object BigInt]") {
    return data.toString();
  }
  if (type === "[object Object]") {
    const tmp = {};
    for (const key in data) {
      if (key !== "__proto__") {
        tmp[key] = serializeBigInt(data[key]);
      }
    }
    return tmp;
  }
  if (type === "[object Array]") {
    let k = data.length;
    let tmp;
    for (tmp = new Array(k); k--; ) {
      tmp[k] = serializeBigInt(data[k]);
    }
    return tmp;
  }
  return data;
}

// src/runtime/utils/validatePrismaClientOptions.ts
var import_utils2 = __toModule2(require_utils5());
var import_js_levenshtein2 = __toModule2(require_js_levenshtein());
var knownProperties = [
  "datasources",
  "errorFormat",
  "log",
  "__internal",
  "rejectOnNotFound"
];
var errorFormats = ["pretty", "colorless", "minimal"];
var logLevels = ["info", "query", "warn", "error"];
var validators = {
  datasources: (options, datasourceNames) => {
    if (!options) {
      return;
    }
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options)} for "datasources" provided to PrismaClient constructor`);
    }
    for (const [key, value] of Object.entries(options)) {
      if (!datasourceNames.includes(key)) {
        const didYouMean = getDidYouMean(key, datasourceNames) || `Available datasources: ${datasourceNames.join(", ")}`;
        throw new PrismaClientConstructorValidationError(`Unknown datasource ${key} provided to PrismaClient constructor.${didYouMean}`);
      }
      if (typeof value !== "object" || Array.isArray(value)) {
        throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
      }
      if (value && typeof value === "object") {
        for (const [key1, value1] of Object.entries(value)) {
          if (key1 !== "url") {
            throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
          if (typeof value1 !== "string") {
            throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(value1)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
        }
      }
    }
  },
  errorFormat: (options) => {
    if (!options) {
      return;
    }
    if (typeof options !== "string") {
      throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options)} for "errorFormat" provided to PrismaClient constructor.`);
    }
    if (!errorFormats.includes(options)) {
      const didYouMean = getDidYouMean(options, errorFormats);
      throw new PrismaClientConstructorValidationError(`Invalid errorFormat ${options} provided to PrismaClient constructor.${didYouMean}`);
    }
  },
  log: (options) => {
    if (!options) {
      return;
    }
    if (!Array.isArray(options)) {
      throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options)} for "log" provided to PrismaClient constructor.`);
    }
    function validateLogLevel(level) {
      if (typeof level === "string") {
        if (!logLevels.includes(level)) {
          const didYouMean = getDidYouMean(level, logLevels);
          throw new PrismaClientConstructorValidationError(`Invalid log level "${level}" provided to PrismaClient constructor.${didYouMean}`);
        }
      }
    }
    for (const option of options) {
      validateLogLevel(option);
      const logValidators = {
        level: validateLogLevel,
        emit: (value) => {
          const emits = ["stdout", "event"];
          if (!emits.includes(value)) {
            const didYouMean = getDidYouMean(value, emits);
            throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(value)} for "emit" in logLevel provided to PrismaClient constructor.${didYouMean}`);
          }
        }
      };
      if (option && typeof option === "object") {
        for (const [key, value] of Object.entries(option)) {
          if (logValidators[key]) {
            logValidators[key](value);
          } else {
            throw new PrismaClientConstructorValidationError(`Invalid property ${key} for "log" provided to PrismaClient constructor`);
          }
        }
      }
    }
  },
  __internal: (value) => {
    if (!value) {
      return;
    }
    const knownKeys = [
      "debug",
      "hooks",
      "useUds",
      "engine",
      "measurePerformance"
    ];
    if (typeof value !== "object") {
      throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(value)} for "__internal" to PrismaClient constructor`);
    }
    for (const [key] of Object.entries(value)) {
      if (!knownKeys.includes(key)) {
        const didYouMean = getDidYouMean(key, knownKeys);
        throw new PrismaClientConstructorValidationError(`Invalid property ${JSON.stringify(key)} for "__internal" provided to PrismaClient constructor.${didYouMean}`);
      }
    }
  },
  rejectOnNotFound: (value) => {
    if (!value) {
      return;
    }
    if (import_utils2.isError(value) || typeof value === "boolean" || typeof value === "object" || typeof value === "function") {
      return value;
    }
    throw new PrismaClientConstructorValidationError(`Invalid rejectOnNotFound expected a boolean/Error/{[modelName: Error | boolean]} but received ${JSON.stringify(value)}`);
  }
};
function validatePrismaClientOptions(options, datasourceNames) {
  for (const [key, value] of Object.entries(options)) {
    if (!knownProperties.includes(key)) {
      const didYouMean = getDidYouMean(key, knownProperties);
      throw new PrismaClientConstructorValidationError(`Unknown property ${key} provided to PrismaClient constructor.${didYouMean}`);
    }
    validators[key](value, datasourceNames);
  }
}
function getDidYouMean(str, options) {
  if (options.length === 0) {
    return "";
  }
  if (typeof str !== "string") {
    return "";
  }
  const alternative = getAlternative(str, options);
  if (!alternative) {
    return "";
  }
  return ` Did you mean "${alternative}"?`;
}
function getAlternative(str, options) {
  if (options.length === 0) {
    return null;
  }
  const optionsWithDistances = options.map((value) => ({
    value,
    distance: import_js_levenshtein2.default(str, value)
  }));
  optionsWithDistances.sort((a, b) => {
    return a.distance < b.distance ? -1 : 1;
  });
  const bestAlternative = optionsWithDistances[0];
  if (bestAlternative.distance < 3) {
    return bestAlternative.value;
  }
  return null;
}

// src/runtime/getPrismaClient.ts
var debug3 = import_debug2.default("prisma:client");
var ALTER_RE = /^(\s*alter\s)/i;
function isReadonlyArray(arg) {
  return Array.isArray(arg);
}
function checkAlter(query, values, invalidCall) {
  if (values.length > 0 && ALTER_RE.exec(query)) {
    throw new Error(`Running ALTER using ${invalidCall} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRaw(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  }
}
var actionOperationMap = {
  findUnique: "query",
  findFirst: "query",
  findMany: "query",
  count: "query",
  create: "mutation",
  createMany: "mutation",
  update: "mutation",
  updateMany: "mutation",
  upsert: "mutation",
  delete: "mutation",
  deleteMany: "mutation",
  executeRaw: "mutation",
  queryRaw: "mutation",
  aggregate: "query",
  groupBy: "query"
};
var aggregateKeys = {
  avg: true,
  count: true,
  sum: true,
  min: true,
  max: true
};
function getPrismaClient(config2) {
  class NewPrismaClient {
    constructor(optionsArg) {
      this._middlewares = [];
      this._engineMiddlewares = [];
      this._transactionId = 1;
      var _a, _b, _c, _d, _e;
      if (optionsArg) {
        validatePrismaClientOptions(optionsArg, config2.datasourceNames);
      }
      this._rejectOnNotFound = optionsArg == null ? void 0 : optionsArg.rejectOnNotFound;
      this._clientVersion = (_a = config2.clientVersion) != null ? _a : clientVersion;
      this._activeProvider = config2.activeProvider;
      const envPaths = {
        rootEnvPath: config2.relativeEnvPaths.rootEnvPath && import_path2.default.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
        schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && import_path2.default.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
      };
      const loadedEnv = import_tryLoadEnvs.tryLoadEnvs(envPaths, {conflictCheck: "none"});
      try {
        const options = optionsArg != null ? optionsArg : {};
        const internal = (_b = options.__internal) != null ? _b : {};
        const useDebug = internal.debug === true;
        if (useDebug) {
          import_debug2.default.enable("prisma:client");
        }
        if (internal.hooks) {
          this._hooks = internal.hooks;
        }
        let cwd = import_path2.default.resolve(config2.dirname, config2.relativePath);
        if (!import_fs.default.existsSync(cwd)) {
          cwd = config2.dirname;
        }
        const thedatasources = options.datasources || {};
        const inputDatasources = Object.entries(thedatasources).filter(([_, source]) => {
          return source && source.url;
        }).map(([name, {url}]) => ({
          name,
          url
        }));
        const datasources = mergeBy([], inputDatasources, (source) => source.name);
        const engineConfig = internal.engine || {};
        if (options.errorFormat) {
          this._errorFormat = options.errorFormat;
        } else if (process.env.NODE_ENV === "production") {
          this._errorFormat = "minimal";
        } else if (process.env.NO_COLOR) {
          this._errorFormat = "colorless";
        } else {
          this._errorFormat = "colorless";
        }
        this._dmmf = new DMMFClass(config2.document);
        this._previewFeatures = (_d = (_c = config2.generator) == null ? void 0 : _c.previewFeatures) != null ? _d : [];
        this._engineConfig = {
          cwd,
          dirname: config2.dirname,
          enableDebugLogs: useDebug,
          enableEngineDebugMode: engineConfig.enableEngineDebugMode,
          datamodelPath: import_path2.default.join(config2.dirname, "schema.prisma"),
          prismaPath: (_e = engineConfig.binaryPath) != null ? _e : void 0,
          engineEndpoint: engineConfig.endpoint,
          datasources,
          generator: config2.generator,
          showColors: this._errorFormat === "pretty",
          logLevel: options.log && getLogLevel(options.log),
          logQueries: options.log && Boolean(typeof options.log === "string" ? options.log === "query" : options.log.find((o) => typeof o === "string" ? o === "query" : o.level === "query")),
          env: loadedEnv ? loadedEnv.parsed : {},
          flags: [],
          clientVersion: config2.clientVersion,
          previewFeatures: import_mapPreviewFeatures.mapPreviewFeatures(this._previewFeatures),
          useUds: internal.useUds,
          activeProvider: config2.activeProvider
        };
        if (config2.activeProvider === "mongodb") {
          const previewFeatures = this._engineConfig.previewFeatures ? this._engineConfig.previewFeatures.concat("mongodb") : ["mongodb"];
          this._engineConfig.previewFeatures = previewFeatures;
        }
        debug3(`clientVersion: ${config2.clientVersion}`);
        this._engine = this.getEngine();
        void this._getActiveProvider();
        this._fetcher = new PrismaClientFetcher(this, false, this._hooks);
        if (options.log) {
          for (const log4 of options.log) {
            const level = typeof log4 === "string" ? log4 : log4.emit === "stdout" ? log4.level : null;
            if (level) {
              this.$on(level, (event) => {
                var _a2;
                logger2.log(`${(_a2 = logger2.tags[level]) != null ? _a2 : ""}`, event.message || event.query);
              });
            }
          }
        }
        this._bootstrapClient();
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    get [Symbol.toStringTag]() {
      return "PrismaClient";
    }
    getEngine() {
      if (this._previewFeatures.includes("nApi") || process.env.PRISMA_FORCE_NAPI === "true") {
        return new import_NAPIEngine.NAPIEngine(this._engineConfig);
      } else {
        return new import_NodeEngine.NodeEngine(this._engineConfig);
      }
    }
    $use(namespace, cb) {
      if (typeof namespace === "function") {
        this._middlewares.push(namespace);
      } else if (typeof namespace === "string") {
        if (namespace === "all") {
          this._middlewares.push(cb);
        } else if (namespace === "engine") {
          this._engineMiddlewares.push(cb);
        } else {
          throw new Error(`Unknown middleware hook ${namespace}`);
        }
      } else {
        throw new Error(`Invalid middleware ${namespace}`);
      }
    }
    $on(eventType, callback) {
      if (eventType === "beforeExit") {
        this._engine.on("beforeExit", callback);
      } else {
        this._engine.on(eventType, (event) => {
          var _a, _b, _c, _d;
          const fields = event.fields;
          if (eventType === "query") {
            return callback({
              timestamp: event.timestamp,
              query: (_a = fields == null ? void 0 : fields.query) != null ? _a : event.query,
              params: (_b = fields == null ? void 0 : fields.params) != null ? _b : event.params,
              duration: (_c = fields == null ? void 0 : fields.duration_ms) != null ? _c : event.duration,
              target: event.target
            });
          } else {
            return callback({
              timestamp: event.timestamp,
              message: (_d = fields == null ? void 0 : fields.message) != null ? _d : event.message,
              target: event.target
            });
          }
        });
      }
    }
    $connect() {
      try {
        return this._engine.start();
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    async _runDisconnect() {
      await this._engine.stop();
      delete this._connectionPromise;
      this._engine = this.getEngine();
      delete this._disconnectionPromise;
      delete this._getConfigPromise;
    }
    $disconnect() {
      try {
        return this._engine.stop();
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    async _getActiveProvider() {
      try {
        const configResult = await this._engine.getConfig();
        this._activeProvider = configResult.datasources[0].activeProvider;
      } catch (e) {
      }
    }
    $executeRawInternal(runInTransaction, transactionId, stringOrTemplateStringsArray, ...values) {
      let query = "";
      let parameters = void 0;
      if (typeof stringOrTemplateStringsArray === "string") {
        query = stringOrTemplateStringsArray;
        parameters = {
          values: serializeRawParameters(values || []),
          __prismaRawParamaters__: true
        };
        checkAlter(query, values, "prisma.$executeRaw(<SQL>, [...values])");
      } else if (isReadonlyArray(stringOrTemplateStringsArray)) {
        switch (this._activeProvider) {
          case "sqlite":
          case "mysql": {
            const queryInstance = sqlTemplateTag.sqltag(stringOrTemplateStringsArray, ...values);
            query = queryInstance.sql;
            parameters = {
              values: serializeRawParameters(queryInstance.values),
              __prismaRawParamaters__: true
            };
            break;
          }
          case "postgresql": {
            const queryInstance = sqlTemplateTag.sqltag(stringOrTemplateStringsArray, ...values);
            query = queryInstance.text;
            checkAlter(query, queryInstance.values, "prisma.$executeRaw`<SQL>`");
            parameters = {
              values: serializeRawParameters(queryInstance.values),
              __prismaRawParamaters__: true
            };
            break;
          }
          case "sqlserver": {
            query = mssqlPreparedStatement(stringOrTemplateStringsArray);
            parameters = {
              values: serializeRawParameters(values),
              __prismaRawParamaters__: true
            };
            break;
          }
        }
      } else {
        switch (this._activeProvider) {
          case "sqlite":
          case "mysql":
            query = stringOrTemplateStringsArray.sql;
            break;
          case "postgresql":
            query = stringOrTemplateStringsArray.text;
            checkAlter(query, stringOrTemplateStringsArray.values, "prisma.$executeRaw(sql`<SQL>`)");
            break;
          case "sqlserver":
            query = mssqlPreparedStatement(stringOrTemplateStringsArray.strings);
            break;
        }
        parameters = {
          values: serializeRawParameters(stringOrTemplateStringsArray.values),
          __prismaRawParamaters__: true
        };
      }
      if (parameters == null ? void 0 : parameters.values) {
        debug3(`prisma.$executeRaw(${query}, ${parameters.values})`);
      } else {
        debug3(`prisma.$executeRaw(${query})`);
      }
      const args = {query, parameters};
      debug3(`Prisma Client call:`);
      return this._request({
        args,
        clientMethod: "executeRaw",
        dataPath: [],
        action: "executeRaw",
        callsite: this._getCallsite(),
        runInTransaction,
        transactionId: transactionId != null ? transactionId : void 0
      });
    }
    $executeRaw(stringOrTemplateStringsArray, ...values) {
      const doRequest = (runInTransaction = false, transactionId) => {
        try {
          const promise = this.$executeRawInternal(runInTransaction, transactionId != null ? transactionId : null, stringOrTemplateStringsArray, ...values);
          promise.isExecuteRaw = true;
          return promise;
        } catch (e) {
          e.clientVersion = this._clientVersion;
          throw e;
        }
      };
      return {
        then(onfulfilled, onrejected) {
          return doRequest().then(onfulfilled, onrejected);
        },
        requestTransaction(transactionId) {
          return doRequest(true, transactionId);
        },
        catch(onrejected) {
          return doRequest().catch(onrejected);
        },
        finally(onfinally) {
          return doRequest().finally(onfinally);
        }
      };
    }
    _getCallsite() {
      if (this._errorFormat !== "minimal") {
        return new Error().stack;
      }
      return void 0;
    }
    $queryRawInternal(runInTransaction, transactionId, stringOrTemplateStringsArray, ...values) {
      let query = "";
      let parameters = void 0;
      if (typeof stringOrTemplateStringsArray === "string") {
        query = stringOrTemplateStringsArray;
        parameters = {
          values: serializeRawParameters(values || []),
          __prismaRawParamaters__: true
        };
      } else if (isReadonlyArray(stringOrTemplateStringsArray)) {
        switch (this._activeProvider) {
          case "sqlite":
          case "mysql": {
            const queryInstance = sqlTemplateTag.sqltag(stringOrTemplateStringsArray, ...values);
            query = queryInstance.sql;
            parameters = {
              values: serializeRawParameters(queryInstance.values),
              __prismaRawParamaters__: true
            };
            break;
          }
          case "postgresql": {
            const queryInstance = sqlTemplateTag.sqltag(stringOrTemplateStringsArray, ...values);
            query = queryInstance.text;
            parameters = {
              values: serializeRawParameters(queryInstance.values),
              __prismaRawParamaters__: true
            };
            break;
          }
          case "sqlserver": {
            query = mssqlPreparedStatement(stringOrTemplateStringsArray);
            parameters = {
              values: serializeRawParameters(values),
              __prismaRawParamaters__: true
            };
            break;
          }
        }
      } else {
        switch (this._activeProvider) {
          case "sqlite":
          case "mysql":
            query = stringOrTemplateStringsArray.sql;
            break;
          case "postgresql":
            query = stringOrTemplateStringsArray.text;
            break;
          case "sqlserver":
            query = mssqlPreparedStatement(stringOrTemplateStringsArray.strings);
            break;
        }
        parameters = {
          values: serializeRawParameters(stringOrTemplateStringsArray.values),
          __prismaRawParamaters__: true
        };
      }
      if (parameters == null ? void 0 : parameters.values) {
        debug3(`prisma.queryRaw(${query}, ${parameters.values})`);
      } else {
        debug3(`prisma.queryRaw(${query})`);
      }
      const args = {query, parameters};
      debug3(`Prisma Client call:`);
      return this._request({
        args,
        clientMethod: "queryRaw",
        dataPath: [],
        action: "queryRaw",
        callsite: this._getCallsite(),
        runInTransaction,
        transactionId: transactionId != null ? transactionId : void 0
      });
    }
    $queryRaw(stringOrTemplateStringsArray, ...values) {
      const doRequest = (runInTransaction = false, transactionId) => {
        try {
          const promise = this.$queryRawInternal(runInTransaction, transactionId != null ? transactionId : null, stringOrTemplateStringsArray, ...values);
          promise.isQueryRaw = true;
          return promise;
        } catch (e) {
          e.clientVersion = this._clientVersion;
          throw e;
        }
      };
      return {
        then(onfulfilled, onrejected) {
          return doRequest().then(onfulfilled, onrejected);
        },
        requestTransaction(transactionId) {
          return doRequest(true, transactionId);
        },
        catch(onrejected) {
          return doRequest().catch(onrejected);
        },
        finally(onfinally) {
          return doRequest().finally(onfinally);
        }
      };
    }
    __internal_triggerPanic(fatal) {
      if (!this._engineConfig.enableEngineDebugMode) {
        throw new Error(`In order to use .__internal_triggerPanic(), please enable the debug mode like so:
new PrismaClient({
  __internal: {
    engine: {
      enableEngineDebugMode: true
    }
  }
})`);
      }
      const query = "SELECT 1";
      const headers = fatal ? {"X-DEBUG-FATAL": "1"} : {"X-DEBUG-NON-FATAL": "1"};
      return this._request({
        action: "queryRaw",
        args: {
          query,
          parameters: void 0
        },
        clientMethod: "queryRaw",
        dataPath: [],
        runInTransaction: false,
        headers,
        callsite: this._getCallsite()
      });
    }
    getTransactionId() {
      return this._transactionId++;
    }
    async $transactionInternal(promises) {
      for (const p of promises) {
        if (!p) {
          throw new Error(`All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`);
        }
        if ((!p.requestTransaction || typeof p.requestTransaction !== "function") && !(p == null ? void 0 : p.isQueryRaw) && !(p == null ? void 0 : p.isExecuteRaw)) {
          throw new Error(`All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`);
        }
      }
      const transactionId = this.getTransactionId();
      const requests = await Promise.all(promises.map((p) => {
        if (p.requestTransaction) {
          return p.requestTransaction(transactionId);
        } else {
        }
        return p;
      }));
      return Promise.all(requests.map((r) => {
        if (Object.prototype.toString.call(r) === "[object Promise]") {
          return r;
        }
        if (r && typeof r === "function") {
          return r();
        }
        return r;
      }));
    }
    async $transaction(promises) {
      try {
        return this.$transactionInternal(promises);
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    _request(internalParams) {
      try {
        const resource = new import_async_hooks.AsyncResource("prisma-client-request");
        if (this._middlewares.length > 0) {
          const params = {
            args: internalParams.args,
            dataPath: internalParams.dataPath,
            runInTransaction: internalParams.runInTransaction,
            action: internalParams.action,
            model: internalParams.model
          };
          return resource.runInAsyncScope(() => this._requestWithMiddlewares(params, this._middlewares.slice(), internalParams.clientMethod, internalParams.callsite, internalParams.headers, internalParams.unpacker));
        }
        return resource.runInAsyncScope(() => this._executeRequest(internalParams));
      } catch (e) {
        e.clientVersion = this._clientVersion;
        throw e;
      }
    }
    _requestWithMiddlewares(params, middlewares, clientMethod, callsite, headers, unpacker) {
      const middleware = middlewares.shift();
      if (middleware) {
        return middleware(params, (params2) => this._requestWithMiddlewares(params2, middlewares, clientMethod, callsite, headers, unpacker));
      }
      ;
      params.clientMethod = clientMethod;
      params.callsite = callsite;
      params.headers = headers;
      params.unpacker = unpacker;
      return this._executeRequest(params);
    }
    _executeRequest({
      args,
      clientMethod,
      dataPath,
      callsite,
      runInTransaction,
      action,
      model,
      headers,
      transactionId,
      unpacker
    }) {
      if (action !== "executeRaw" && action !== "queryRaw" && !model) {
        throw new Error(`Model missing for action ${action}`);
      }
      if ((action === "executeRaw" || action === "queryRaw") && model) {
        throw new Error(`executeRaw and queryRaw can't be executed on a model basis. The model ${model} has been provided`);
      }
      let rootField;
      const operation = actionOperationMap[action];
      if (action === "executeRaw" || action === "queryRaw") {
        rootField = action;
      }
      let mapping;
      if (model) {
        mapping = this._dmmf.mappingsMap[model];
        if (!mapping) {
          throw new Error(`Could not find mapping for model ${model}`);
        }
        rootField = mapping[action];
      }
      if (operation !== "query" && operation !== "mutation") {
        throw new Error(`Invalid operation ${operation} for action ${action}`);
      }
      const field = this._dmmf.rootFieldMap[rootField];
      if (!field) {
        throw new Error(`Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`);
      }
      const {isList} = field.outputType;
      const typeName = getOutputTypeName(field.outputType.type);
      const rejectOnNotFound = getRejectOnNotFound(action, typeName, args, this._rejectOnNotFound);
      let document2 = makeDocument({
        dmmf: this._dmmf,
        rootField,
        rootTypeName: operation,
        select: args
      });
      document2.validate(args, false, clientMethod, this._errorFormat, callsite);
      document2 = transformDocument(document2);
      if (import_debug2.default.enabled("prisma:client")) {
        const query = String(document2);
        debug3(`Prisma Client call:`);
        debug3(`prisma.${clientMethod}(${printJsonWithErrors({
          ast: args,
          keyPaths: [],
          valuePaths: [],
          missingItems: []
        })})`);
        debug3(`Generated request:`);
        debug3(query + "\n");
      }
      return this._fetcher.request({
        document: document2,
        clientMethod,
        typeName,
        dataPath,
        rejectOnNotFound,
        isList,
        rootField,
        callsite,
        showColors: this._errorFormat === "pretty",
        args,
        engineHook: this._engineMiddlewares[0],
        runInTransaction,
        headers,
        transactionId,
        unpacker
      });
    }
    _bootstrapClient() {
      const clients = this._dmmf.mappings.modelOperations.reduce((acc, mapping) => {
        const lowerCaseModel = lowerCase(mapping.model);
        const model = this._dmmf.modelMap[mapping.model];
        if (!model) {
          throw new Error(`Invalid mapping ${mapping.model}, can't find model`);
        }
        const prismaClient = ({
          operation,
          actionName,
          args,
          dataPath,
          modelName,
          unpacker
        }) => {
          dataPath = dataPath != null ? dataPath : [];
          const clientMethod = `${lowerCaseModel}.${actionName}`;
          let requestPromise;
          const callsite = this._getCallsite();
          const requestModelName = modelName != null ? modelName : model.name;
          const clientImplementation = {
            then: (onfulfilled, onrejected) => {
              if (!requestPromise) {
                requestPromise = this._request({
                  args,
                  dataPath,
                  action: actionName,
                  model: requestModelName,
                  clientMethod,
                  callsite,
                  runInTransaction: false,
                  unpacker
                });
              }
              return requestPromise.then(onfulfilled, onrejected);
            },
            requestTransaction: (transactionId) => {
              if (!requestPromise) {
                requestPromise = this._request({
                  args,
                  dataPath,
                  action: actionName,
                  model: requestModelName,
                  clientMethod,
                  callsite,
                  runInTransaction: true,
                  transactionId,
                  unpacker
                });
              }
              return requestPromise;
            },
            catch: (onrejected) => {
              if (!requestPromise) {
                requestPromise = this._request({
                  args,
                  dataPath,
                  action: actionName,
                  model: requestModelName,
                  clientMethod,
                  callsite,
                  runInTransaction: false,
                  unpacker
                });
              }
              return requestPromise.catch(onrejected);
            },
            finally: (onfinally) => {
              if (!requestPromise) {
                requestPromise = this._request({
                  args,
                  dataPath,
                  action: actionName,
                  model: requestModelName,
                  clientMethod,
                  callsite,
                  runInTransaction: false,
                  unpacker
                });
              }
              return requestPromise.finally(onfinally);
            }
          };
          for (const field of model.fields.filter((f) => f.kind === "object")) {
            clientImplementation[field.name] = (fieldArgs) => {
              const prefix = dataPath.includes("select") ? "select" : dataPath.includes("include") ? "include" : "select";
              const newDataPath = [...dataPath, prefix, field.name];
              const newArgs = deepSet(args, newDataPath, fieldArgs || true);
              return clients[field.type]({
                operation,
                actionName,
                args: newArgs,
                dataPath: newDataPath,
                isList: field.isList,
                modelName: modelName || model.name
              });
            };
          }
          return clientImplementation;
        };
        acc[model.name] = prismaClient;
        return acc;
      }, {});
      for (const mapping of this._dmmf.mappings.modelOperations) {
        const lowerCaseModel = lowerCase(mapping.model);
        const filteredActionsList = {
          model: true,
          plural: true,
          aggregate: true,
          groupBy: true
        };
        const delegate = Object.keys(mapping).reduce((acc, actionName) => {
          if (!filteredActionsList[actionName]) {
            const operation = getOperation(actionName);
            acc[actionName] = (args) => clients[mapping.model]({
              operation,
              actionName,
              args
            });
          }
          return acc;
        }, {});
        delegate.count = (args) => {
          let select;
          let unpacker;
          if ((args == null ? void 0 : args.select) && typeof (args == null ? void 0 : args.select) === "object") {
            select = {count: {select: args.select}};
          } else {
            select = {count: {select: {_all: true}}};
            unpacker = (data) => {
              var _a;
              data.count = (_a = data.count) == null ? void 0 : _a._all;
              return data;
            };
          }
          return clients[mapping.model]({
            operation: "query",
            actionName: `aggregate`,
            args: {
              ...args != null ? args : {},
              select
            },
            dataPath: ["count"],
            unpacker
          });
        };
        delegate.aggregate = (args) => {
          let unpacker = void 0;
          const select = Object.entries(args).reduce((acc, [key, value]) => {
            if (aggregateKeys[key]) {
              if (!acc.select) {
                acc.select = {};
              }
              if (key === "count") {
                if (typeof value === "object" && value) {
                  acc.select[key] = {select: value};
                } else {
                  acc.select[key] = {select: {_all: value}};
                  unpacker = (data) => {
                    var _a;
                    if (data.count) {
                      data.count = (_a = data.count) == null ? void 0 : _a._all;
                    }
                    return data;
                  };
                }
              } else {
                acc.select[key] = {select: value};
              }
            } else {
              acc[key] = value;
            }
            return acc;
          }, {});
          return clients[mapping.model]({
            operation: "query",
            actionName: "aggregate",
            rootField: mapping.aggregate,
            args: select,
            dataPath: [],
            unpacker
          });
        };
        delegate.groupBy = (args) => {
          let unpacker = void 0;
          const select = Object.entries(args).reduce((acc, [key, value]) => {
            if (aggregateKeys[key]) {
              if (!acc.select) {
                acc.select = {};
              }
              acc.select[key] = {select: value};
            } else {
              acc[key] = value;
            }
            if (key === "count") {
              if (typeof value === "object" && value) {
                acc.select[key] = {select: value};
              } else if (typeof value === "boolean") {
                acc.select[key] = {select: {_all: value}};
                unpacker = (data) => {
                  if (Array.isArray(data)) {
                    data = data.map((row) => {
                      var _a, _b;
                      if (row && typeof row.count === "object" && ((_a = row.count) == null ? void 0 : _a._all)) {
                        row.count = (_b = row.count) == null ? void 0 : _b._all;
                      }
                      return row;
                    });
                  }
                  return data;
                };
              }
            }
            if (key === "by" && Array.isArray(value) && value.length > 0) {
              if (!acc.select) {
                acc.select = {};
              }
              for (const by of value) {
                acc.select[by] = true;
              }
            }
            return acc;
          }, {});
          return clients[mapping.model]({
            operation: "query",
            actionName: "groupBy",
            rootField: mapping.groupBy,
            args: select,
            dataPath: [],
            unpacker
          });
        };
        this[lowerCaseModel] = delegate;
      }
    }
  }
  return NewPrismaClient;
}
var PrismaClientFetcher = class {
  constructor(prisma, enableDebug = false, hooks) {
    this.prisma = prisma;
    this.debug = enableDebug;
    this.hooks = hooks;
    this.dataloader = new Dataloader({
      batchLoader: (requests) => {
        const queries = requests.map((r) => String(r.document));
        const runTransaction = requests[0].runInTransaction;
        return this.prisma._engine.requestBatch(queries, runTransaction);
      },
      singleLoader: (request) => {
        const query = String(request.document);
        return this.prisma._engine.request(query, request.headers);
      },
      batchBy: (request) => {
        var _a;
        if (request.runInTransaction) {
          if (request.transactionId) {
            return `transaction-batch-${request.transactionId}`;
          }
          return "transaction-batch";
        }
        if (!request.document.children[0].name.startsWith("findUnique")) {
          return null;
        }
        const selectionSet = request.document.children[0].children.join(",");
        const args = (_a = request.document.children[0].args) == null ? void 0 : _a.args.map((a) => {
          if (a.value instanceof Args) {
            return `${a.key}-${a.value.args.map((a2) => a2.key).join(",")}`;
          }
          return a.key;
        }).join(",");
        return `${request.document.children[0].name}|${args}|${selectionSet}`;
      }
    });
  }
  get [Symbol.toStringTag]() {
    return "PrismaClientFetcher";
  }
  async request({
    document: document2,
    dataPath = [],
    rootField,
    typeName,
    isList,
    callsite,
    rejectOnNotFound,
    clientMethod,
    runInTransaction,
    showColors,
    engineHook,
    args,
    headers,
    transactionId,
    unpacker
  }) {
    const cb = async () => {
      if (this.hooks && this.hooks.beforeRequest) {
        const query = String(document2);
        this.hooks.beforeRequest({
          query,
          path: dataPath,
          rootField,
          typeName,
          document: document2,
          isList,
          clientMethod,
          args
        });
      }
      try {
        let data, elapsed;
        if (engineHook) {
          const result = await engineHook({
            document: document2,
            runInTransaction
          }, (params) => this.dataloader.request(params));
          data = result.data;
          elapsed = result.elapsed;
        } else {
          const result = await this.dataloader.request({
            document: document2,
            runInTransaction,
            headers,
            transactionId
          });
          data = result == null ? void 0 : result.data;
          elapsed = result == null ? void 0 : result.elapsed;
        }
        const unpackResult = this.unpack(document2, data, dataPath, rootField, unpacker);
        throwIfNotFound(unpackResult, clientMethod, typeName, rejectOnNotFound);
        if (process.env.PRISMA_CLIENT_GET_TIME) {
          return {data: unpackResult, elapsed};
        }
        return unpackResult;
      } catch (e) {
        debug3(e);
        let message = e.message;
        if (callsite) {
          const {stack} = printStack({
            callsite,
            originalMethod: clientMethod,
            onUs: e.isPanic,
            showColors
          });
          message = `${stack}
  ${e.message}`;
        }
        message = this.sanitizeMessage(message);
        if (e.code) {
          throw new import_engine_core.PrismaClientKnownRequestError(message, e.code, this.prisma._clientVersion, e.meta);
        } else if (e.isPanic) {
          throw new import_engine_core.PrismaClientRustPanicError(message, this.prisma._clientVersion);
        } else if (e instanceof import_engine_core.PrismaClientUnknownRequestError) {
          throw new import_engine_core.PrismaClientUnknownRequestError(message, this.prisma._clientVersion);
        } else if (e instanceof import_engine_core.PrismaClientInitializationError) {
          throw new import_engine_core.PrismaClientInitializationError(message, this.prisma._clientVersion);
        } else if (e instanceof import_engine_core.PrismaClientRustPanicError) {
          throw new import_engine_core.PrismaClientRustPanicError(message, this.prisma._clientVersion);
        }
        e.clientVersion = this.prisma._clientVersion;
        throw e;
      }
    };
    if (transactionId) {
      return cb;
    } else {
      return cb();
    }
  }
  sanitizeMessage(message) {
    if (this.prisma._errorFormat && this.prisma._errorFormat !== "pretty") {
      return import_strip_ansi3.default(message);
    }
    return message;
  }
  unpack(document2, data, path2, rootField, unpacker) {
    if (data == null ? void 0 : data.data) {
      data = data.data;
    }
    if (unpacker) {
      data[rootField] = unpacker(data[rootField]);
    }
    const getPath = [];
    if (rootField) {
      getPath.push(rootField);
    }
    getPath.push(...path2.filter((p) => p !== "select" && p !== "include"));
    return unpack({document: document2, data, path: getPath});
  }
};
function getOperation(action) {
  if (action === import_generator_helper.DMMF.ModelAction.findMany || action === import_generator_helper.DMMF.ModelAction.findUnique || action === import_generator_helper.DMMF.ModelAction.findFirst) {
    return "query";
  }
  return "mutation";
}

// src/runtime/index.ts
var import_sql_template_tag = __toModule2(require_dist12());

// src/runtime/warnEnvConflicts.ts
var import_tryLoadEnvs2 = __toModule2(require_tryLoadEnvs());
function warnEnvConflicts(envPaths) {
  import_tryLoadEnvs2.tryLoadEnvs(envPaths, {conflictCheck: "warn"});
}
