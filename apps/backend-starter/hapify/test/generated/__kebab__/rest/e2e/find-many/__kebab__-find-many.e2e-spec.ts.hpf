/* eslint-disable  @typescript-eslint/no-explicit-any */
import { <<Model pascal>>RestModule, } from '@generated/<<Model kebab>>/rest';
import { Module, ValidationPipe } from '@nestjs/common';
import { CoreModule } from '@tractr/nestjs-core';
import { DatabaseModule } from '@tractr/nestjs-database';
import { createTestContext, TestContext } from '@tractr/nestjs-testing';
import request from 'supertest';
import {
  <<Model pascal>>,
  <<for Fields manyMany field>>
  <<field.model pascal>>,
  <<endfor>>
} from '@prisma/client';
import { APP_PIPE } from '@nestjs/core';
 
@Module({
  imports: [
    <<Model pascal>>RestModule.register(),
    DatabaseModule,
    CoreModule,
  ],
  providers: [
    {
      provide: APP_PIPE,
      useValue: new ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
        transformOptions: {
          enableImplicitConversion: true,
        },
      }),
    },
  ],
})
class TestModule {};
  
const context = createTestContext(TestModule) as Required<TestContext>;

let <<Model camel>>: any;
  
beforeEach(async () => {
  const { prisma } = context;
  <<Model camel>> = (await prisma!.<<Model camel>>.findFirst(
<<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
  {
    include: {
  <<for Fields entity field>>
      <<field camel>>: true,
  <<endfor>>
  <<for ReferencedIn ref>>
    <<for ref.fields field>>
      <<ref camel>>As<<field pascal>>: true,
    <<endfor>>
  <<endfor>>
    }
  }
<<<}>>>
  ))
});
 
describe('Find <<Model lower>> (e2e)', () => {

  it('should find up to 100 <<Model lower>>s', () => {
    const { app } = context;
    return request(app.getHttpServer()).get('/<<Model kebab>>')
      .then(({status, body}) => {
        expect(status).toEqual(200);
        expect(body.length).toBeLessThan(100);
      <<for Fields not manyMany field>>
        <<if field not entity>>
        expect(body[0].<<field camel>>).toBeDefined()
        <<else>>
        expect(body[0].<<field camel>>Id).toBeDefined()
        <<endif>>
      <<endfor>>
      });
  });
   
<<for Fields searchable field>>
  it('should correctly filter by <<field lower>>', () => {
    const { app } = context;
    <<if field oneOne or oneMany>>
    const queryDto = { <<field camel>>: <<Model camel>>.<<field camel>>.id};
    <<elseif field manyMany>>
    const queryDto = { <<field camel>>: [<<Model camel>>.<<field camel>>[0].id], populate: ['<<field camel>>']};
    <<else>>
    const queryDto = { <<field camel>>: <<Model camel>>.<<field camel>>};
    <<endif>>
    return request(app.getHttpServer()).get('/<<Model kebab>>')
      .query(queryDto)
      .then(({status, body}) => {
        expect(status).toEqual(200);
        <<if field oneOne or oneMany>>
        (body as <<Model pascal>>[]).forEach(item => expect(item.<<field camel>>Id).toEqual(<<Model camel>>.<<field camel>>.id))
        <<elseif field manyMany>>
        (body as any[]).forEach(item =>
          expect((item.<<field camel>> as <<field.model pascal>>[]).map(({id}) => id)).toContain(<<Model camel>>.<<field camel>>[0].id)
        );
        <<else>>
        (body as <<Model pascal>>[]).forEach(item => expect(body[0].<<field camel>>).toEqual(<<Model camel>>.<<field camel>>));
        <<endif>>
      });
  });
    
<<endfor>>

<<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
  it('should populate relations', () => {
    const { app } = context;
    const relations = [
      <<for Fields entity field>>
          '<<field camel>>',
      <<endfor>>
      <<for ReferencedIn ref>>
        <<for ref.fields field>>
          '<<ref camel>>As<<field pascal>>',
        <<endfor>>
      <<endfor>>
    ];
    const queryDto = { populate: relations };
    return request(app.getHttpServer())
      .get('/<<Model kebab>>')
      .query(queryDto)
      .then(({ status, body }) => {
        expect(status).toEqual(200);
        relations.forEach((relation) =>
          expect(body[0][relation]).toBeDefined(),
        );
      });
  });
<<<}>>>
});
