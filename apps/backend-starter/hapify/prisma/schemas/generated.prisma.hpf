// Generated schema (generated by hapify)
// ------------------------------------------------
<<for Models model>>
  model <<model pascal>> {
    <<for model.fields field>>
        <<if field oneOne or oneMany>>
    // Relation: <<field lower>>
    <<field camel>> <<field.model pascal>><<if field nullable>>?<<endif>> @relation("<<model pascal>>.<<field pascal>>To<<field.model pascal>>.<<model pascal>>As<<field pascal>>",fields: [<<field camel>><<=getReferencedEntityPrimary(field).names.pascal>>], references: [<<=getReferencedEntityPrimary(field).names.camel>>])
    <<field camel>><<=getReferencedEntityPrimary(field).names.pascal>> <<=getReferencedEntityPrimaryType(field)>><<if field nullable>>?<<endif>>
        <<elseif field manyMany>>
    // Relation: <<field lower>>
    // <<field camel>> <<field pascal>>On<<model pascal>>[]
    <<field camel>> <<field.model pascal>>[] @relation("<<model pascal>>.<<field pascal>>To<<field.model pascal>>.<<model pascal>>As<<field pascal>>")
        <<else>>
    <<field camel>> <<=prismaType(field, model)>> <<=primary(field)>> <<=unique(field)>>
        <<endif>>
    <<endfor>>
    <<for model.referencedIn ref>>
    // referencedIn: <<ref lower>>
        <<for ref.fields field>>
            <<if field oneOne>>
    <<ref camel>>As<<field pascal>> <<ref pascal>>? @relation("<<ref pascal>>.<<field pascal>>To<<model pascal>>.<<ref pascal>>As<<field pascal>>")
            <<elseif field oneMany>>
    <<ref camel>>As<<field pascal>> <<ref pascal>>[] @relation("<<ref pascal>>.<<field pascal>>To<<model pascal>>.<<ref pascal>>As<<field pascal>>")
            <<elseif field manyMany>>
    <<ref camel>>As<<field pascal>> <<ref pascal>>[] @relation("<<ref pascal>>.<<field pascal>>To<<model pascal>>.<<ref pascal>>As<<field pascal>>")
    //<<ref camel>>As<<field pascal>> <<field pascal>>On<<ref pascal>>[]
            <<endif>>
        <<endfor>>
    <<endfor>>
  }
   
<<endfor>>
 
<<for Models model>>
    <<for model.fields manyMany field>>
// Many-to-many relations of <<model camel>>.<<field camel>>
// model <<field pascal>>On<<model pascal>> {
//  <<model camel>> <<model pascal>> @relation(fields: [<<model camel>>Id], references: [id])
//  <<model camel>>Id <<=getEntityPrimaryType(model)>> 
//  <<field.model camel>> <<field.model pascal>> @relation(fields: [<<field.model camel>>Id], references: [id])
//  <<field.model camel>>Id <<=getEntityPrimaryType(model)>>
//  createdAt   DateTime @default(now())
//  @@id([<<model camel>>Id, <<field.model camel>>Id])
//}
    <<endfor>>
<<endfor>>
 
<<for Models model>>
  <<for model.fields enum field>>
enum <<model pascal>><<field pascal>> {
   <<for field.enum enumValue>>
 <<enumValue constant>>
   <<endfor>>
}
  <<endfor>>
<<endfor>>

<<<
function getReferencedEntityPrimary(f) {
  return f.model.fields.primary
}
>>>

<<<
function getReferencedEntityPrimaryType(f) {
  if (f.model.fields.primary.type === 'string') return 'String';
  if (f.model.fields.primary.type === 'number') return 'Int';
  throw new Error("Only types 'number' and 'string' are allowed for primary key")
}
>>>

<<<
function getEntityPrimaryType(m) {
  if (m.fields.primary.type === 'string') return 'String';
  if (m.fields.primary.type === 'number') return 'Int';
  throw new Error("Only types 'number' and 'string' are allowed for primary key")
}
>>>

<<<
function prismaType(f, m) {
  let out = "";

  // Generate type for prisma
  if (f.type === "boolean") out += "Boolean";
  else if (f.type === "string") out += "String";
  else if (f.type === "enum") out += `${m.names.pascal}${f.names.pascal}`;
  else if (f.type === "number") out += "Int";
  else if (f.type === "integer") out += "Int";
  else if (f.type === "float") out += "Float";
  else if (f.type === "datetime") out += "DateTime";
  else if (f.type === "entity")  {
    out += f.m.names.pascal;
  }

  // Handle nullable and multiple fields
  if (f.multiple) out += "[]";
  else if (f.nullable) out += "?";
  return out;
}
>>>

<<<
function primary(f) {
  if (!f.primary) return "";
  if (f.type === "string") return "@id @default(uuid())";
  if (f.type === "strnumbering") return "@id @default(autoincrement())";
}
>>>

<<<
function unique(f) {
  return f.unique ? "@unique": "";
}
>>>


