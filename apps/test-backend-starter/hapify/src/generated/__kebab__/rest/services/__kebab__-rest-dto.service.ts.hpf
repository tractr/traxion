import { Injectable } from '@nestjs/common';
import { Prisma } from '@prisma/client';
 
import {
  <<Model pascal>>CountQueryDto,
  <<Model pascal>>CreateBodyDto,
  <<Model pascal>>DeleteParamsDto,
  <<Model pascal>>FindManyQueryDto,
  <<Model pascal>>FindUniqueParamsDto,
  <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
  <<Model pascal>>FindUniqueQueryDto,
  <<<}>>>
  <<Model pascal>>UpdateBodyDto,
  <<Model pascal>>UpdateParamsDto,
  <<Model pascal>>UpsertBodyDto,
  <<Model pascal>>UpsertParamsDto,
} from '../dtos';
<<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
import { 
  formatPopulate,
  formatEntityIds,
} from '../../../helpers';
<<<}>>>
 
@Injectable()
export class <<Model pascal>>RestDtoService {
  public formatCreateDto(
    {
    <<for Fields not internal field>>
      <<field camel>>,
    <<endfor>>
    }: <<Model pascal>>CreateBodyDto
  ): Prisma.<<Model pascal>>CreateArgs {
    const data = {
    <<for Fields not internal field>>
      <<if field oneOne or oneMany>>
    <<field camel>>: { connect: { id: <<field camel>> } },
      <<elseif field manyMany>>
    <<field camel>>: { set: formatEntityIds(<<field camel>>) },
      <<else>>
    <<field camel>>,
      <<endif>>
    <<endfor>>
    }
    return { data };
  }
    
  public formatCountDto(
    {
    <<for Fields searchable field>>
      <<field camel>>,
    <<endfor>>
    }: <<Model pascal>>CountQueryDto): Prisma.<<Model pascal>>CountArgs {
    const where = {
    <<for Fields searchable field>>
      <<if field multiple and not entity>>
        <<field camel>>: <<field camel>> ? { hasSome: <<field camel>> } : undefined,
      <<elseif field oneOne or oneMany>>
        <<field camel>>: { id: <<field camel>> },
      <<elseif field  manyMany>>
        <<field camel>>: <<field camel>> ? { some: { id: { in: <<field camel>> } } }: undefined,
      <<else>>
        <<field camel>>,
      <<endif>>
    <<endfor>>
    }
    return { where };
  }
 
  public formatFindUniqueDtos(
    paramsDto: <<Model pascal>>FindUniqueParamsDto,
    <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
    { populate }: <<Model pascal>>FindUniqueQueryDto
    <<<}>>>
  ): Prisma.<<Model pascal>>FindUniqueArgs {
    <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
    const include = populate ? formatPopulate<Prisma.<<Model pascal>>Include>(populate) : undefined;
    <<<}>>>
    return { 
      where: { ...paramsDto },
      <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
      include,
      <<<}>>>
    };
  }
    
  public formatFindManyDto(
    {
    <<for Fields searchable field>>
      <<field camel>>,
    <<endfor>>
    <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
      populate,
    <<<}>>>
      sort,
      order,
      take,
      skip,
    }: <<Model pascal>>FindManyQueryDto
  ): Prisma.<<Model pascal>>FindManyArgs {
    const where: Prisma.<<Model pascal>>WhereInput = {
    <<for Fields searchable field>>
      <<if field multiple and not entity>>
      <<field camel>>: <<field camel>> ? { hasSome: <<field camel>> } : undefined,
      <<elseif field oneOne or oneMany>>
      <<field camel>>: { id: <<field camel>> },
      <<elseif field  manyMany>>
        <<field camel>>: <<field camel>> ? { some: { id: { in: <<field camel>> } } }: undefined,
      <<else>>
      <<field camel>>,
      <<endif>>
    <<endfor>>
    }
    const orderBy = {[sort]: order}
    <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
    const include = populate ? formatPopulate<Prisma.<<Model pascal>>Include>(populate): undefined;
    <<<}>>>
    return { 
      where,
      take,
      skip,
      orderBy,
    <<<if (root.dependencies.list.length || root.referencedIn.length) {>>>
      include,
    <<<}>>>
    };
  }
    
  public formatUpdateDtos(
    paramsDto: <<Model pascal>>UpdateParamsDto,
    {
    <<for Fields not internal field>>
      <<field camel>>,
    <<endfor>>
    }: <<Model pascal>>UpdateBodyDto
  ): Prisma.<<Model pascal>>UpdateArgs {
    const data = {
    <<for Fields not internal field>>
      <<if field oneOne or oneMany>>
    <<field camel>>: { connect: { id: <<field camel>> } },
      <<elseif field manyMany>>
    <<field camel>>: <<field camel>> ? { set: formatEntityIds(<<field camel>>) } : undefined,
      <<else>>
    <<field camel>>,
      <<endif>>
    <<endfor>>
    }
    return { data, where: { ...paramsDto } };
  }
    
  public formatUpsertDtos(
    paramsDto: <<Model pascal>>UpsertParamsDto,
    {
    <<for Fields not internal field>>
      <<field camel>>,
    <<endfor>>
    }: <<Model pascal>>UpsertBodyDto
  ): Prisma.<<Model pascal>>UpsertArgs {
    const create = {
    <<for Fields not internal field>>
      <<if field oneOne or oneMany>>
    <<field camel>>: { connect: { id: <<field camel>> } },
      <<elseif field manyMany>>
    <<field camel>>: { set: formatEntityIds(<<field camel>>) },
      <<else>>
    <<field camel>>,
      <<endif>>
    <<endfor>>
    };
    const update = { ...create };
    return { 
      create,
      update,
      where: { ...paramsDto } 
    };
  }
  
  public formatDeleteDto(
    paramsDto: <<Model pascal>>DeleteParamsDto
  ): Prisma.<<Model pascal>>DeleteArgs {
    return { where: { ...paramsDto } };
  }
}
